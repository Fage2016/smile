// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h_4 {

    cblas_openblas_h_4() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final String OS = System.getProperty("os.name", "linux").toLowerCase().split(" ")[0];
    static final String LIBRARY_NAME = System.getProperty("smile.blas.library", switch (OS) {
        case "mac" -> "blas"; // macOS's builtin Accelerate framework
        case "windows" -> "mkl_rt"; // Intel's MKL
        default -> "openblas"; // OpenBLAS
    });
    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName(LIBRARY_NAME), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int OPENBLAS_OS_LINUX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OS_LINUX 1
     * }
     */
    public static int OPENBLAS_OS_LINUX() {
        return OPENBLAS_OS_LINUX;
    }
    private static final int OPENBLAS_ARCH_X86_64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ARCH_X86_64 1
     * }
     */
    public static int OPENBLAS_ARCH_X86_64() {
        return OPENBLAS_ARCH_X86_64;
    }
    private static final int OPENBLAS_C_GCC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_C_GCC 1
     * }
     */
    public static int OPENBLAS_C_GCC() {
        return OPENBLAS_C_GCC;
    }
    private static final int OPENBLAS___64BIT__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS___64BIT__ 1
     * }
     */
    public static int OPENBLAS___64BIT__() {
        return OPENBLAS___64BIT__;
    }
    private static final int OPENBLAS_HAVE_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_HAVE_C11 1
     * }
     */
    public static int OPENBLAS_HAVE_C11() {
        return OPENBLAS_HAVE_C11;
    }
    private static final int OPENBLAS_NEEDBUNDERSCORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_NEEDBUNDERSCORE 1
     * }
     */
    public static int OPENBLAS_NEEDBUNDERSCORE() {
        return OPENBLAS_NEEDBUNDERSCORE;
    }
    private static final int OPENBLAS_L1_DATA_SIZE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_SIZE 32768
     * }
     */
    public static int OPENBLAS_L1_DATA_SIZE() {
        return OPENBLAS_L1_DATA_SIZE;
    }
    private static final int OPENBLAS_L1_DATA_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L1_DATA_LINESIZE() {
        return OPENBLAS_L1_DATA_LINESIZE;
    }
    private static final int OPENBLAS_L2_SIZE = (int)512488L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_SIZE 512488
     * }
     */
    public static int OPENBLAS_L2_SIZE() {
        return OPENBLAS_L2_SIZE;
    }
    private static final int OPENBLAS_L2_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L2_LINESIZE() {
        return OPENBLAS_L2_LINESIZE;
    }
    private static final int OPENBLAS_DTB_DEFAULT_ENTRIES = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_DEFAULT_ENTRIES 128
     * }
     */
    public static int OPENBLAS_DTB_DEFAULT_ENTRIES() {
        return OPENBLAS_DTB_DEFAULT_ENTRIES;
    }
    private static final int OPENBLAS_DTB_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_SIZE 4096
     * }
     */
    public static int OPENBLAS_DTB_SIZE() {
        return OPENBLAS_DTB_SIZE;
    }
    private static final int OPENBLAS_L2_ASSOCIATIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_ASSOCIATIVE 8
     * }
     */
    public static int OPENBLAS_L2_ASSOCIATIVE() {
        return OPENBLAS_L2_ASSOCIATIVE;
    }
    private static final int OPENBLAS_SLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_SLOCAL_BUFFER_SIZE() {
        return OPENBLAS_SLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_DLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_DLOCAL_BUFFER_SIZE() {
        return OPENBLAS_DLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_CLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_CLOCAL_BUFFER_SIZE() {
        return OPENBLAS_CLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_ZLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ZLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_ZLOCAL_BUFFER_SIZE() {
        return OPENBLAS_ZLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_GEMM_MULTITHREAD_THRESHOLD 4
     * }
     */
    public static int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD() {
        return OPENBLAS_GEMM_MULTITHREAD_THRESHOLD;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _COMPLEX_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _COMPLEX_H 1
     * }
     */
    public static int _COMPLEX_H() {
        return _COMPLEX_H;
    }
    private static final int _SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SCHED_H 1
     * }
     */
    public static int _SCHED_H() {
        return _SCHED_H;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SCHED_H 1
     * }
     */
    public static int _BITS_SCHED_H() {
        return _BITS_SCHED_H;
    }
    private static final int SCHED_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 0
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 1
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int _BITS_TYPES_STRUCT_SCHED_PARAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_STRUCT_SCHED_PARAM 1
     * }
     */
    public static int _BITS_TYPES_STRUCT_SCHED_PARAM() {
        return _BITS_TYPES_STRUCT_SCHED_PARAM;
    }
    private static final int _BITS_CPU_SET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_CPU_SET_H 1
     * }
     */
    public static int _BITS_CPU_SET_H() {
        return _BITS_CPU_SET_H;
    }
    private static final int __CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __CPU_SETSIZE 1024
     * }
     */
    public static int __CPU_SETSIZE() {
        return __CPU_SETSIZE;
    }
    private static final int OPENBLAS_SEQUENTIAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SEQUENTIAL 0
     * }
     */
    public static int OPENBLAS_SEQUENTIAL() {
        return OPENBLAS_SEQUENTIAL;
    }
    private static final int OPENBLAS_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_THREAD 1
     * }
     */
    public static int OPENBLAS_THREAD() {
        return OPENBLAS_THREAD;
    }
    private static final int OPENBLAS_OPENMP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OPENMP 2
     * }
     */
    public static int OPENBLAS_OPENMP() {
        return OPENBLAS_OPENMP;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int LAPACK_ROW_MAJOR = (int)101L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_ROW_MAJOR 101
     * }
     */
    public static int LAPACK_ROW_MAJOR() {
        return LAPACK_ROW_MAJOR;
    }
    private static final int LAPACK_COL_MAJOR = (int)102L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_COL_MAJOR 102
     * }
     */
    public static int LAPACK_COL_MAJOR() {
        return LAPACK_COL_MAJOR;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long BLASLONG
     * }
     */
    public static final OfLong BLASLONG = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long BLASULONG
     * }
     */
    public static final OfLong BLASULONG = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint16_t bfloat16
     * }
     */
    public static final OfShort bfloat16 = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int blasint
     * }
     */
    public static final OfInt blasint = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = cblas_openblas_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_LONG,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = cblas_openblas_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = cblas_openblas_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = cblas_openblas_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacos$descriptor() {
        return cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MethodHandle cacos$handle() {
        return cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MemorySegment cacos$address() {
        return cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static double cacos(double __z) {
        var mh$ = cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacos$descriptor() {
        return __cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MethodHandle __cacos$handle() {
        return __cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MemorySegment __cacos$address() {
        return __cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static double __cacos(double __z) {
        var mh$ = __cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casin$descriptor() {
        return casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MethodHandle casin$handle() {
        return casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MemorySegment casin$address() {
        return casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static double casin(double __z) {
        var mh$ = casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casin$descriptor() {
        return __casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MethodHandle __casin$handle() {
        return __casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MemorySegment __casin$address() {
        return __casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static double __casin(double __z) {
        var mh$ = __casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catan$descriptor() {
        return catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MethodHandle catan$handle() {
        return catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MemorySegment catan$address() {
        return catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static double catan(double __z) {
        var mh$ = catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catan$descriptor() {
        return __catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MethodHandle __catan$handle() {
        return __catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MemorySegment __catan$address() {
        return __catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static double __catan(double __z) {
        var mh$ = __catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccos$descriptor() {
        return ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MethodHandle ccos$handle() {
        return ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MemorySegment ccos$address() {
        return ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static double ccos(double __z) {
        var mh$ = ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccos$descriptor() {
        return __ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MethodHandle __ccos$handle() {
        return __ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MemorySegment __ccos$address() {
        return __ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static double __ccos(double __z) {
        var mh$ = __ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csin$descriptor() {
        return csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MethodHandle csin$handle() {
        return csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MemorySegment csin$address() {
        return csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static double csin(double __z) {
        var mh$ = csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csin$descriptor() {
        return __csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MethodHandle __csin$handle() {
        return __csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MemorySegment __csin$address() {
        return __csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static double __csin(double __z) {
        var mh$ = __csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctan$descriptor() {
        return ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MethodHandle ctan$handle() {
        return ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MemorySegment ctan$address() {
        return ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static double ctan(double __z) {
        var mh$ = ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctan$descriptor() {
        return __ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MethodHandle __ctan$handle() {
        return __ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MemorySegment __ctan$address() {
        return __ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static double __ctan(double __z) {
        var mh$ = __ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacosh$descriptor() {
        return cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle cacosh$handle() {
        return cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment cacosh$address() {
        return cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static double cacosh(double __z) {
        var mh$ = cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacosh$descriptor() {
        return __cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle __cacosh$handle() {
        return __cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment __cacosh$address() {
        return __cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static double __cacosh(double __z) {
        var mh$ = __cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casinh$descriptor() {
        return casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MethodHandle casinh$handle() {
        return casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MemorySegment casinh$address() {
        return casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static double casinh(double __z) {
        var mh$ = casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casinh$descriptor() {
        return __casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MethodHandle __casinh$handle() {
        return __casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MemorySegment __casinh$address() {
        return __casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static double __casinh(double __z) {
        var mh$ = __casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catanh$descriptor() {
        return catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MethodHandle catanh$handle() {
        return catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MemorySegment catanh$address() {
        return catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static double catanh(double __z) {
        var mh$ = catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catanh$descriptor() {
        return __catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MethodHandle __catanh$handle() {
        return __catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MemorySegment __catanh$address() {
        return __catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static double __catanh(double __z) {
        var mh$ = __catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccosh$descriptor() {
        return ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle ccosh$handle() {
        return ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment ccosh$address() {
        return ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static double ccosh(double __z) {
        var mh$ = ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccosh$descriptor() {
        return __ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle __ccosh$handle() {
        return __ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment __ccosh$address() {
        return __ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static double __ccosh(double __z) {
        var mh$ = __ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csinh$descriptor() {
        return csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MethodHandle csinh$handle() {
        return csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MemorySegment csinh$address() {
        return csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static double csinh(double __z) {
        var mh$ = csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csinh$descriptor() {
        return __csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MethodHandle __csinh$handle() {
        return __csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MemorySegment __csinh$address() {
        return __csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static double __csinh(double __z) {
        var mh$ = __csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctanh$descriptor() {
        return ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle ctanh$handle() {
        return ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment ctanh$address() {
        return ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static double ctanh(double __z) {
        var mh$ = ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctanh$descriptor() {
        return __ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle __ctanh$handle() {
        return __ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment __ctanh$address() {
        return __ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static double __ctanh(double __z) {
        var mh$ = __ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cexp$descriptor() {
        return cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MethodHandle cexp$handle() {
        return cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MemorySegment cexp$address() {
        return cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static double cexp(double __z) {
        var mh$ = cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cexp$descriptor() {
        return __cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MethodHandle __cexp$handle() {
        return __cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MemorySegment __cexp$address() {
        return __cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static double __cexp(double __z) {
        var mh$ = __cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor clog$descriptor() {
        return clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MethodHandle clog$handle() {
        return clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MemorySegment clog$address() {
        return clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static double clog(double __z) {
        var mh$ = clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __clog$descriptor() {
        return __clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MethodHandle __clog$handle() {
        return __clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MemorySegment __clog$address() {
        return __clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static double __clog(double __z) {
        var mh$ = __clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor cpow$descriptor() {
        return cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle cpow$handle() {
        return cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment cpow$address() {
        return cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double cpow(double __x, double __y) {
        var mh$ = cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor __cpow$descriptor() {
        return __cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle __cpow$handle() {
        return __cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment __cpow$address() {
        return __cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double __cpow(double __x, double __y) {
        var mh$ = __cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csqrt$descriptor() {
        return csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle csqrt$handle() {
        return csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment csqrt$address() {
        return csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static double csqrt(double __z) {
        var mh$ = csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csqrt$descriptor() {
        return __csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle __csqrt$handle() {
        return __csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment __csqrt$address() {
        return __csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static double __csqrt(double __z) {
        var mh$ = __csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cabs$descriptor() {
        return cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MethodHandle cabs$handle() {
        return cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MemorySegment cabs$address() {
        return cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static double cabs(double __z) {
        var mh$ = cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cabs$descriptor() {
        return __cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MethodHandle __cabs$handle() {
        return __cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MemorySegment __cabs$address() {
        return __cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static double __cabs(double __z) {
        var mh$ = __cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor carg$descriptor() {
        return carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MethodHandle carg$handle() {
        return carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MemorySegment carg$address() {
        return carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static double carg(double __z) {
        var mh$ = carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __carg$descriptor() {
        return __carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MethodHandle __carg$handle() {
        return __carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MemorySegment __carg$address() {
        return __carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static double __carg(double __z) {
        var mh$ = __carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor conj$descriptor() {
        return conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MethodHandle conj$handle() {
        return conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MemorySegment conj$address() {
        return conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static double conj(double __z) {
        var mh$ = conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __conj$descriptor() {
        return __conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MethodHandle __conj$handle() {
        return __conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MemorySegment __conj$address() {
        return __conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static double __conj(double __z) {
        var mh$ = __conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cproj$descriptor() {
        return cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MethodHandle cproj$handle() {
        return cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MemorySegment cproj$address() {
        return cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static double cproj(double __z) {
        var mh$ = cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cproj$descriptor() {
        return __cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MethodHandle __cproj$handle() {
        return __cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MemorySegment __cproj$address() {
        return __cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static double __cproj(double __z) {
        var mh$ = __cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cimag$descriptor() {
        return cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MethodHandle cimag$handle() {
        return cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MemorySegment cimag$address() {
        return cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static double cimag(double __z) {
        var mh$ = cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cimag$descriptor() {
        return __cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MethodHandle __cimag$handle() {
        return __cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MemorySegment __cimag$address() {
        return __cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static double __cimag(double __z) {
        var mh$ = __cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor creal$descriptor() {
        return creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MethodHandle creal$handle() {
        return creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MemorySegment creal$address() {
        return creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static double creal(double __z) {
        var mh$ = creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __creal$descriptor() {
        return __creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MethodHandle __creal$handle() {
        return __creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MemorySegment __creal$address() {
        return __creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static double __creal(double __z) {
        var mh$ = __creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacosf$descriptor() {
        return cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle cacosf$handle() {
        return cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment cacosf$address() {
        return cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static float cacosf(float __z) {
        var mh$ = cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacosf$descriptor() {
        return __cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacosf$handle() {
        return __cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacosf$address() {
        return __cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static float __cacosf(float __z) {
        var mh$ = __cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinf$descriptor() {
        return casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MethodHandle casinf$handle() {
        return casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MemorySegment casinf$address() {
        return casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static float casinf(float __z) {
        var mh$ = casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinf$descriptor() {
        return __casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinf$handle() {
        return __casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinf$address() {
        return __casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static float __casinf(float __z) {
        var mh$ = __casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanf$descriptor() {
        return catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MethodHandle catanf$handle() {
        return catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MemorySegment catanf$address() {
        return catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static float catanf(float __z) {
        var mh$ = catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanf$descriptor() {
        return __catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanf$handle() {
        return __catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanf$address() {
        return __catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static float __catanf(float __z) {
        var mh$ = __catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccosf$descriptor() {
        return ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle ccosf$handle() {
        return ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment ccosf$address() {
        return ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static float ccosf(float __z) {
        var mh$ = ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccosf$descriptor() {
        return __ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccosf$handle() {
        return __ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccosf$address() {
        return __ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static float __ccosf(float __z) {
        var mh$ = __ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinf$descriptor() {
        return csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MethodHandle csinf$handle() {
        return csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MemorySegment csinf$address() {
        return csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static float csinf(float __z) {
        var mh$ = csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinf$descriptor() {
        return __csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinf$handle() {
        return __csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinf$address() {
        return __csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static float __csinf(float __z) {
        var mh$ = __csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanf$descriptor() {
        return ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanf$handle() {
        return ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanf$address() {
        return ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static float ctanf(float __z) {
        var mh$ = ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanf$descriptor() {
        return __ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanf$handle() {
        return __ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanf$address() {
        return __ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static float __ctanf(float __z) {
        var mh$ = __ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacoshf$descriptor() {
        return cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle cacoshf$handle() {
        return cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment cacoshf$address() {
        return cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static float cacoshf(float __z) {
        var mh$ = cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacoshf$descriptor() {
        return __cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacoshf$handle() {
        return __cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacoshf$address() {
        return __cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static float __cacoshf(float __z) {
        var mh$ = __cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinhf$descriptor() {
        return casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle casinhf$handle() {
        return casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment casinhf$address() {
        return casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static float casinhf(float __z) {
        var mh$ = casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinhf$descriptor() {
        return __casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinhf$handle() {
        return __casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinhf$address() {
        return __casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static float __casinhf(float __z) {
        var mh$ = __casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanhf$descriptor() {
        return catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle catanhf$handle() {
        return catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment catanhf$address() {
        return catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static float catanhf(float __z) {
        var mh$ = catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanhf$descriptor() {
        return __catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanhf$handle() {
        return __catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanhf$address() {
        return __catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static float __catanhf(float __z) {
        var mh$ = __catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccoshf$descriptor() {
        return ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle ccoshf$handle() {
        return ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment ccoshf$address() {
        return ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static float ccoshf(float __z) {
        var mh$ = ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccoshf$descriptor() {
        return __ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccoshf$handle() {
        return __ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccoshf$address() {
        return __ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static float __ccoshf(float __z) {
        var mh$ = __ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinhf$descriptor() {
        return csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle csinhf$handle() {
        return csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment csinhf$address() {
        return csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static float csinhf(float __z) {
        var mh$ = csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinhf$descriptor() {
        return __csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinhf$handle() {
        return __csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinhf$address() {
        return __csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static float __csinhf(float __z) {
        var mh$ = __csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanhf$descriptor() {
        return ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanhf$handle() {
        return ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanhf$address() {
        return ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static float ctanhf(float __z) {
        var mh$ = ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanhf$descriptor() {
        return __ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanhf$handle() {
        return __ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanhf$address() {
        return __ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static float __ctanhf(float __z) {
        var mh$ = __ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cexpf$descriptor() {
        return cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle cexpf$handle() {
        return cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment cexpf$address() {
        return cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static float cexpf(float __z) {
        var mh$ = cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cexpf$descriptor() {
        return __cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle __cexpf$handle() {
        return __cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment __cexpf$address() {
        return __cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static float __cexpf(float __z) {
        var mh$ = __cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor clogf$descriptor() {
        return clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MethodHandle clogf$handle() {
        return clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MemorySegment clogf$address() {
        return clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static float clogf(float __z) {
        var mh$ = clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __clogf$descriptor() {
        return __clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MethodHandle __clogf$handle() {
        return __clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MemorySegment __clogf$address() {
        return __clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static float __clogf(float __z) {
        var mh$ = __clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor cpowf$descriptor() {
        return cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle cpowf$handle() {
        return cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment cpowf$address() {
        return cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float cpowf(float __x, float __y) {
        var mh$ = cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor __cpowf$descriptor() {
        return __cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle __cpowf$handle() {
        return __cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment __cpowf$address() {
        return __cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float __cpowf(float __x, float __y) {
        var mh$ = __cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csqrtf$descriptor() {
        return csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle csqrtf$handle() {
        return csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment csqrtf$address() {
        return csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static float csqrtf(float __z) {
        var mh$ = csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csqrtf$descriptor() {
        return __csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle __csqrtf$handle() {
        return __csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment __csqrtf$address() {
        return __csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static float __csqrtf(float __z) {
        var mh$ = __csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cabsf$descriptor() {
        return cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle cabsf$handle() {
        return cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment cabsf$address() {
        return cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static float cabsf(float __z) {
        var mh$ = cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cabsf$descriptor() {
        return __cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle __cabsf$handle() {
        return __cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment __cabsf$address() {
        return __cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static float __cabsf(float __z) {
        var mh$ = __cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cargf$descriptor() {
        return cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MethodHandle cargf$handle() {
        return cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MemorySegment cargf$address() {
        return cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static float cargf(float __z) {
        var mh$ = cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cargf$descriptor() {
        return __cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MethodHandle __cargf$handle() {
        return __cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MemorySegment __cargf$address() {
        return __cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static float __cargf(float __z) {
        var mh$ = __cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor conjf$descriptor() {
        return conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MethodHandle conjf$handle() {
        return conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MemorySegment conjf$address() {
        return conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static float conjf(float __z) {
        var mh$ = conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __conjf$descriptor() {
        return __conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MethodHandle __conjf$handle() {
        return __conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MemorySegment __conjf$address() {
        return __conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static float __conjf(float __z) {
        var mh$ = __conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cprojf$descriptor() {
        return cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle cprojf$handle() {
        return cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment cprojf$address() {
        return cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static float cprojf(float __z) {
        var mh$ = cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cprojf$descriptor() {
        return __cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle __cprojf$handle() {
        return __cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment __cprojf$address() {
        return __cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static float __cprojf(float __z) {
        var mh$ = __cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cimagf$descriptor() {
        return cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle cimagf$handle() {
        return cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment cimagf$address() {
        return cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static float cimagf(float __z) {
        var mh$ = cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cimagf$descriptor() {
        return __cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle __cimagf$handle() {
        return __cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment __cimagf$address() {
        return __cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static float __cimagf(float __z) {
        var mh$ = __cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor crealf$descriptor() {
        return crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MethodHandle crealf$handle() {
        return crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MemorySegment crealf$address() {
        return crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static float crealf(float __z) {
        var mh$ = crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __crealf$descriptor() {
        return __crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MethodHandle __crealf$handle() {
        return __crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MemorySegment __crealf$address() {
        return __crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static float __crealf(float __z) {
        var mh$ = __crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = cblas_openblas_h.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor openblas_set_num_threads$descriptor() {
        return openblas_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle openblas_set_num_threads$handle() {
        return openblas_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment openblas_set_num_threads$address() {
        return openblas_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static void openblas_set_num_threads(int num_threads) {
        var mh$ = openblas_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class goto_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("goto_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor goto_set_num_threads$descriptor() {
        return goto_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle goto_set_num_threads$handle() {
        return goto_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment goto_set_num_threads$address() {
        return goto_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static void goto_set_num_threads(int num_threads) {
        var mh$ = goto_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("goto_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static FunctionDescriptor openblas_get_num_threads$descriptor() {
        return openblas_get_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MethodHandle openblas_get_num_threads$handle() {
        return openblas_get_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MemorySegment openblas_get_num_threads$address() {
        return openblas_get_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static int openblas_get_num_threads() {
        var mh$ = openblas_get_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_threads");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_procs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_num_procs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static FunctionDescriptor openblas_get_num_procs$descriptor() {
        return openblas_get_num_procs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MethodHandle openblas_get_num_procs$handle() {
        return openblas_get_num_procs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MemorySegment openblas_get_num_procs$address() {
        return openblas_get_num_procs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static int openblas_get_num_procs() {
        var mh$ = openblas_get_num_procs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_procs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static FunctionDescriptor openblas_get_config$descriptor() {
        return openblas_get_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MethodHandle openblas_get_config$handle() {
        return openblas_get_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config$address() {
        return openblas_get_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config() {
        var mh$ = openblas_get_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_config");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_corename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_corename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static FunctionDescriptor openblas_get_corename$descriptor() {
        return openblas_get_corename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MethodHandle openblas_get_corename$handle() {
        return openblas_get_corename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename$address() {
        return openblas_get_corename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename() {
        var mh$ = openblas_get_corename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_corename");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_setaffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_setaffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static FunctionDescriptor openblas_setaffinity$descriptor() {
        return openblas_setaffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MethodHandle openblas_setaffinity$handle() {
        return openblas_setaffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MemorySegment openblas_setaffinity$address() {
        return openblas_setaffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static int openblas_setaffinity(int thread_idx, long cpusetsize, MemorySegment cpu_set) {
        var mh$ = openblas_setaffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_setaffinity", thread_idx, cpusetsize, cpu_set);
            }
            return (int)mh$.invokeExact(thread_idx, cpusetsize, cpu_set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_parallel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_parallel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static FunctionDescriptor openblas_get_parallel$descriptor() {
        return openblas_get_parallel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MethodHandle openblas_get_parallel$handle() {
        return openblas_get_parallel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MemorySegment openblas_get_parallel$address() {
        return openblas_get_parallel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static int openblas_get_parallel() {
        var mh$ = openblas_get_parallel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_parallel");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CblasRowMajor = (int)101L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasRowMajor = 101
     * }
     */
    public static int CblasRowMajor() {
        return CblasRowMajor;
    }
    private static final int CblasColMajor = (int)102L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasColMajor = 102
     * }
     */
    public static int CblasColMajor() {
        return CblasColMajor;
    }
    private static final int CblasNoTrans = (int)111L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasNoTrans = 111
     * }
     */
    public static int CblasNoTrans() {
        return CblasNoTrans;
    }
    private static final int CblasTrans = (int)112L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasTrans = 112
     * }
     */
    public static int CblasTrans() {
        return CblasTrans;
    }
    private static final int CblasConjTrans = (int)113L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjTrans = 113
     * }
     */
    public static int CblasConjTrans() {
        return CblasConjTrans;
    }
    private static final int CblasConjNoTrans = (int)114L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjNoTrans = 114
     * }
     */
    public static int CblasConjNoTrans() {
        return CblasConjNoTrans;
    }
    private static final int CblasUpper = (int)121L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasUpper = 121
     * }
     */
    public static int CblasUpper() {
        return CblasUpper;
    }
    private static final int CblasLower = (int)122L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasLower = 122
     * }
     */
    public static int CblasLower() {
        return CblasLower;
    }
    private static final int CblasNonUnit = (int)131L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasNonUnit = 131
     * }
     */
    public static int CblasNonUnit() {
        return CblasNonUnit;
    }
    private static final int CblasUnit = (int)132L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasUnit = 132
     * }
     */
    public static int CblasUnit() {
        return CblasUnit;
    }
    private static final int CblasLeft = (int)141L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasLeft = 141
     * }
     */
    public static int CblasLeft() {
        return CblasLeft;
    }
    private static final int CblasRight = (int)142L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasRight = 142
     * }
     */
    public static int CblasRight() {
        return CblasRight;
    }

    private static class cblas_sdsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sdsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdsdot$descriptor() {
        return cblas_sdsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdsdot$handle() {
        return cblas_sdsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdsdot$address() {
        return cblas_sdsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdsdot(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdsdot", n, alpha, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dsdot$descriptor() {
        return cblas_dsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dsdot$handle() {
        return cblas_dsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dsdot$address() {
        return cblas_dsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static double cblas_dsdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsdot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdot$descriptor() {
        return cblas_sdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdot$handle() {
        return cblas_sdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdot$address() {
        return cblas_sdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ddot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ddot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ddot$descriptor() {
        return cblas_ddot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ddot$handle() {
        return cblas_ddot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ddot$address() {
        return cblas_ddot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static double cblas_ddot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ddot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ddot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotu$descriptor() {
        return cblas_cdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotu$handle() {
        return cblas_cdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotu$address() {
        return cblas_cdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotc$descriptor() {
        return cblas_cdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotc$handle() {
        return cblas_cdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotc$address() {
        return cblas_cdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotu$descriptor() {
        return cblas_zdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotu$handle() {
        return cblas_zdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotu$address() {
        return cblas_zdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotc$descriptor() {
        return cblas_zdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotc$handle() {
        return cblas_zdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotc$address() {
        return cblas_zdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotu_sub$descriptor() {
        return cblas_cdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotu_sub$handle() {
        return cblas_cdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotu_sub$address() {
        return cblas_cdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotc_sub$descriptor() {
        return cblas_cdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotc_sub$handle() {
        return cblas_cdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotc_sub$address() {
        return cblas_cdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotu_sub$descriptor() {
        return cblas_zdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotu_sub$handle() {
        return cblas_zdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotu_sub$address() {
        return cblas_zdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotc_sub$descriptor() {
        return cblas_zdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotc_sub$handle() {
        return cblas_zdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotc_sub$address() {
        return cblas_zdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_sasum$descriptor() {
        return cblas_sasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_sasum$handle() {
        return cblas_sasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_sasum$address() {
        return cblas_sasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_sasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_sasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dasum$descriptor() {
        return cblas_dasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dasum$handle() {
        return cblas_dasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dasum$address() {
        return cblas_dasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scasum$descriptor() {
        return cblas_scasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scasum$handle() {
        return cblas_scasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scasum$address() {
        return cblas_scasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dzasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzasum$descriptor() {
        return cblas_dzasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzasum$handle() {
        return cblas_dzasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzasum$address() {
        return cblas_dzasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ssum$descriptor() {
        return cblas_ssum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ssum$handle() {
        return cblas_ssum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ssum$address() {
        return cblas_ssum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_ssum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ssum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dsum$descriptor() {
        return cblas_dsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dsum$handle() {
        return cblas_dsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dsum$address() {
        return cblas_dsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scsum$descriptor() {
        return cblas_scsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scsum$handle() {
        return cblas_scsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scsum$address() {
        return cblas_scsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scsum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dzsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzsum$descriptor() {
        return cblas_dzsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzsum$handle() {
        return cblas_dzsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzsum$address() {
        return cblas_dzsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_snrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_snrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_snrm2$descriptor() {
        return cblas_snrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_snrm2$handle() {
        return cblas_snrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_snrm2$address() {
        return cblas_snrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static float cblas_snrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_snrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_snrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dnrm2$descriptor() {
        return cblas_dnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dnrm2$handle() {
        return cblas_dnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dnrm2$address() {
        return cblas_dnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static double cblas_dnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dnrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_scnrm2$descriptor() {
        return cblas_scnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_scnrm2$handle() {
        return cblas_scnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_scnrm2$address() {
        return cblas_scnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static float cblas_scnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_scnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scnrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dznrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dznrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dznrm2$descriptor() {
        return cblas_dznrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dznrm2$handle() {
        return cblas_dznrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dznrm2$address() {
        return cblas_dznrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static double cblas_dznrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dznrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dznrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_isamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamax$descriptor() {
        return cblas_isamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamax$handle() {
        return cblas_isamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamax$address() {
        return cblas_isamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamax$descriptor() {
        return cblas_idamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamax$handle() {
        return cblas_idamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamax$address() {
        return cblas_idamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamax$descriptor() {
        return cblas_icamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamax$handle() {
        return cblas_icamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamax$address() {
        return cblas_icamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamax$descriptor() {
        return cblas_izamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamax$handle() {
        return cblas_izamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamax$address() {
        return cblas_izamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_isamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamin$descriptor() {
        return cblas_isamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamin$handle() {
        return cblas_isamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamin$address() {
        return cblas_isamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamin$descriptor() {
        return cblas_idamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamin$handle() {
        return cblas_idamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamin$address() {
        return cblas_idamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamin$descriptor() {
        return cblas_icamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamin$handle() {
        return cblas_icamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamin$address() {
        return cblas_icamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamin$descriptor() {
        return cblas_izamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamin$handle() {
        return cblas_izamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamin$address() {
        return cblas_izamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ismax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismax$descriptor() {
        return cblas_ismax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismax$handle() {
        return cblas_ismax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismax$address() {
        return cblas_ismax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmax$descriptor() {
        return cblas_idmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmax$handle() {
        return cblas_idmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmax$address() {
        return cblas_idmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmax$descriptor() {
        return cblas_icmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmax$handle() {
        return cblas_icmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmax$address() {
        return cblas_icmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmax$descriptor() {
        return cblas_izmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmax$handle() {
        return cblas_izmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmax$address() {
        return cblas_izmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ismin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismin$descriptor() {
        return cblas_ismin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismin$handle() {
        return cblas_ismin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismin$address() {
        return cblas_ismin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmin$descriptor() {
        return cblas_idmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmin$handle() {
        return cblas_idmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmin$address() {
        return cblas_idmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmin$descriptor() {
        return cblas_icmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmin$handle() {
        return cblas_icmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmin$address() {
        return cblas_icmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmin$descriptor() {
        return cblas_izmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmin$handle() {
        return cblas_izmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmin$address() {
        return cblas_izmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_saxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_saxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpy$descriptor() {
        return cblas_saxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpy$handle() {
        return cblas_saxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpy$address() {
        return cblas_saxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpy(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_saxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_daxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpy$descriptor() {
        return cblas_daxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpy$handle() {
        return cblas_daxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpy$address() {
        return cblas_daxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpy(int n, double alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_daxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_caxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpy$descriptor() {
        return cblas_caxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpy$handle() {
        return cblas_caxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpy$address() {
        return cblas_caxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_caxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zaxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpy$descriptor() {
        return cblas_zaxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpy$handle() {
        return cblas_zaxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpy$address() {
        return cblas_zaxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_scopy$descriptor() {
        return cblas_scopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_scopy$handle() {
        return cblas_scopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_scopy$address() {
        return cblas_scopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_scopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_scopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dcopy$descriptor() {
        return cblas_dcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dcopy$handle() {
        return cblas_dcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dcopy$address() {
        return cblas_dcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ccopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ccopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ccopy$descriptor() {
        return cblas_ccopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ccopy$handle() {
        return cblas_ccopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ccopy$address() {
        return cblas_ccopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_ccopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ccopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ccopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zcopy$descriptor() {
        return cblas_zcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zcopy$handle() {
        return cblas_zcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zcopy$address() {
        return cblas_zcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sswap$descriptor() {
        return cblas_sswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sswap$handle() {
        return cblas_sswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sswap$address() {
        return cblas_sswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_sswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dswap$descriptor() {
        return cblas_dswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dswap$handle() {
        return cblas_dswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dswap$address() {
        return cblas_dswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cswap$descriptor() {
        return cblas_cswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cswap$handle() {
        return cblas_cswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cswap$address() {
        return cblas_cswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_cswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zswap$descriptor() {
        return cblas_zswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zswap$handle() {
        return cblas_zswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zswap$address() {
        return cblas_zswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_srot$descriptor() {
        return cblas_srot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_srot$handle() {
        return cblas_srot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_srot$address() {
        return cblas_srot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_srot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, float c, float s) {
        var mh$ = cblas_srot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_drot$descriptor() {
        return cblas_drot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_drot$handle() {
        return cblas_drot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_drot$address() {
        return cblas_drot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_drot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, double c, double s) {
        var mh$ = cblas_drot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_csrot$descriptor() {
        return cblas_csrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_csrot$handle() {
        return cblas_csrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_csrot$address() {
        return cblas_csrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_csrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, float c, float s) {
        var mh$ = cblas_csrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_zdrot$descriptor() {
        return cblas_zdrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_zdrot$handle() {
        return cblas_zdrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_zdrot$address() {
        return cblas_zdrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_zdrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, double c, double s) {
        var mh$ = cblas_zdrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static FunctionDescriptor cblas_srotg$descriptor() {
        return cblas_srotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MethodHandle cblas_srotg$handle() {
        return cblas_srotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MemorySegment cblas_srotg$address() {
        return cblas_srotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static void cblas_srotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_srotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static FunctionDescriptor cblas_drotg$descriptor() {
        return cblas_drotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MethodHandle cblas_drotg$handle() {
        return cblas_drotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MemorySegment cblas_drotg$address() {
        return cblas_drotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static void cblas_drotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_drotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_crotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_crotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_crotg$descriptor() {
        return cblas_crotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MethodHandle cblas_crotg$handle() {
        return cblas_crotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MemorySegment cblas_crotg$address() {
        return cblas_crotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static void cblas_crotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_crotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_crotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zrotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zrotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_zrotg$descriptor() {
        return cblas_zrotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MethodHandle cblas_zrotg$handle() {
        return cblas_zrotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MemorySegment cblas_zrotg$address() {
        return cblas_zrotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static void cblas_zrotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_zrotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zrotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotm$descriptor() {
        return cblas_srotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MethodHandle cblas_srotm$handle() {
        return cblas_srotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MemorySegment cblas_srotm$address() {
        return cblas_srotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static void cblas_srotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_srotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotm$descriptor() {
        return cblas_drotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MethodHandle cblas_drotm$handle() {
        return cblas_drotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MemorySegment cblas_drotm$address() {
        return cblas_drotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static void cblas_drotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_drotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotmg$descriptor() {
        return cblas_srotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MethodHandle cblas_srotmg$handle() {
        return cblas_srotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MemorySegment cblas_srotmg$address() {
        return cblas_srotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static void cblas_srotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, float b2, MemorySegment P) {
        var mh$ = cblas_srotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotmg$descriptor() {
        return cblas_drotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MethodHandle cblas_drotmg$handle() {
        return cblas_drotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MemorySegment cblas_drotmg$address() {
        return cblas_drotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static void cblas_drotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, double b2, MemorySegment P) {
        var mh$ = cblas_drotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_sscal$descriptor() {
        return cblas_sscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_sscal$handle() {
        return cblas_sscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_sscal$address() {
        return cblas_sscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static void cblas_sscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_sscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dscal$descriptor() {
        return cblas_dscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dscal$handle() {
        return cblas_dscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dscal$address() {
        return cblas_dscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static void cblas_dscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_dscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_cscal$descriptor() {
        return cblas_cscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_cscal$handle() {
        return cblas_cscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_cscal$address() {
        return cblas_cscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_cscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_cscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zscal$descriptor() {
        return cblas_zscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zscal$handle() {
        return cblas_zscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zscal$address() {
        return cblas_zscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_csscal$descriptor() {
        return cblas_csscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_csscal$handle() {
        return cblas_csscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_csscal$address() {
        return cblas_csscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_csscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_csscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zdscal$descriptor() {
        return cblas_zdscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zdscal$handle() {
        return cblas_zdscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zdscal$address() {
        return cblas_zdscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zdscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zdscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sgemv$descriptor() {
        return cblas_sgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sgemv$handle() {
        return cblas_sgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sgemv$address() {
        return cblas_sgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dgemv$descriptor() {
        return cblas_dgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dgemv$handle() {
        return cblas_dgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dgemv$address() {
        return cblas_dgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_dgemv(int order, int trans, int m, int n, double alpha, MemorySegment a, int lda, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_dgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cgemv$descriptor() {
        return cblas_cgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cgemv$handle() {
        return cblas_cgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cgemv$address() {
        return cblas_cgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_cgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_cgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zgemv$descriptor() {
        return cblas_zgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zgemv$handle() {
        return cblas_zgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zgemv$address() {
        return cblas_zgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_sger$descriptor() {
        return cblas_sger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_sger$handle() {
        return cblas_sger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_sger$address() {
        return cblas_sger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_sger(int order, int M, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_sger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dger$descriptor() {
        return cblas_dger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dger$handle() {
        return cblas_dger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dger$address() {
        return cblas_dger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dger(int order, int M, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgeru$descriptor() {
        return cblas_cgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgeru$handle() {
        return cblas_cgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgeru$address() {
        return cblas_cgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgerc$descriptor() {
        return cblas_cgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgerc$handle() {
        return cblas_cgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgerc$address() {
        return cblas_cgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgeru$descriptor() {
        return cblas_zgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgeru$handle() {
        return cblas_zgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgeru$address() {
        return cblas_zgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgerc$descriptor() {
        return cblas_zgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgerc$handle() {
        return cblas_zgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgerc$address() {
        return cblas_zgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strsv$descriptor() {
        return cblas_strsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strsv$handle() {
        return cblas_strsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strsv$address() {
        return cblas_strsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrsv$descriptor() {
        return cblas_dtrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrsv$handle() {
        return cblas_dtrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrsv$address() {
        return cblas_dtrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrsv$descriptor() {
        return cblas_ctrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrsv$handle() {
        return cblas_ctrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrsv$address() {
        return cblas_ctrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrsv$descriptor() {
        return cblas_ztrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrsv$handle() {
        return cblas_ztrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrsv$address() {
        return cblas_ztrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strmv$descriptor() {
        return cblas_strmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strmv$handle() {
        return cblas_strmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strmv$address() {
        return cblas_strmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrmv$descriptor() {
        return cblas_dtrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrmv$handle() {
        return cblas_dtrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrmv$address() {
        return cblas_dtrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrmv$descriptor() {
        return cblas_ctrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrmv$handle() {
        return cblas_ctrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrmv$address() {
        return cblas_ctrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrmv$descriptor() {
        return cblas_ztrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrmv$handle() {
        return cblas_ztrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrmv$address() {
        return cblas_ztrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr$descriptor() {
        return cblas_ssyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr$handle() {
        return cblas_ssyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr$address() {
        return cblas_ssyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr$descriptor() {
        return cblas_dsyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr$handle() {
        return cblas_dsyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr$address() {
        return cblas_dsyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher$descriptor() {
        return cblas_cher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher$handle() {
        return cblas_cher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher$address() {
        return cblas_cher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_cher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher$descriptor() {
        return cblas_zher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher$handle() {
        return cblas_zher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher$address() {
        return cblas_zher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_zher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2$descriptor() {
        return cblas_ssyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr2$handle() {
        return cblas_ssyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr2$address() {
        return cblas_ssyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2$descriptor() {
        return cblas_dsyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr2$handle() {
        return cblas_dsyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr2$address() {
        return cblas_dsyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher2$descriptor() {
        return cblas_cher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher2$handle() {
        return cblas_cher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher2$address() {
        return cblas_cher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher2$descriptor() {
        return cblas_zher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher2$handle() {
        return cblas_zher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher2$address() {
        return cblas_zher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sgbmv$descriptor() {
        return cblas_sgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sgbmv$handle() {
        return cblas_sgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sgbmv$address() {
        return cblas_sgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sgbmv(int order, int TransA, int M, int N, int KL, int KU, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dgbmv$descriptor() {
        return cblas_dgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dgbmv$handle() {
        return cblas_dgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dgbmv$address() {
        return cblas_dgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dgbmv(int order, int TransA, int M, int N, int KL, int KU, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_cgbmv$descriptor() {
        return cblas_cgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_cgbmv$handle() {
        return cblas_cgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_cgbmv$address() {
        return cblas_cgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_cgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_cgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zgbmv$descriptor() {
        return cblas_zgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zgbmv$handle() {
        return cblas_zgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zgbmv$address() {
        return cblas_zgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssbmv$descriptor() {
        return cblas_ssbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssbmv$handle() {
        return cblas_ssbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssbmv$address() {
        return cblas_ssbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssbmv(int order, int Uplo, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsbmv$descriptor() {
        return cblas_dsbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsbmv$handle() {
        return cblas_dsbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsbmv$address() {
        return cblas_dsbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsbmv(int order, int Uplo, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbmv$descriptor() {
        return cblas_stbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbmv$handle() {
        return cblas_stbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbmv$address() {
        return cblas_stbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbmv$descriptor() {
        return cblas_dtbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbmv$handle() {
        return cblas_dtbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbmv$address() {
        return cblas_dtbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbmv$descriptor() {
        return cblas_ctbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbmv$handle() {
        return cblas_ctbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbmv$address() {
        return cblas_ctbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbmv$descriptor() {
        return cblas_ztbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbmv$handle() {
        return cblas_ztbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbmv$address() {
        return cblas_ztbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbsv$descriptor() {
        return cblas_stbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbsv$handle() {
        return cblas_stbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbsv$address() {
        return cblas_stbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbsv$descriptor() {
        return cblas_dtbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbsv$handle() {
        return cblas_dtbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbsv$address() {
        return cblas_dtbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbsv$descriptor() {
        return cblas_ctbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbsv$handle() {
        return cblas_ctbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbsv$address() {
        return cblas_ctbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbsv$descriptor() {
        return cblas_ztbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbsv$handle() {
        return cblas_ztbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbsv$address() {
        return cblas_ztbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpmv$descriptor() {
        return cblas_stpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpmv$handle() {
        return cblas_stpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpmv$address() {
        return cblas_stpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpmv$descriptor() {
        return cblas_dtpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpmv$handle() {
        return cblas_dtpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpmv$address() {
        return cblas_dtpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpmv$descriptor() {
        return cblas_ctpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpmv$handle() {
        return cblas_ctpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpmv$address() {
        return cblas_ctpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpmv$descriptor() {
        return cblas_ztpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpmv$handle() {
        return cblas_ztpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpmv$address() {
        return cblas_ztpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpsv$descriptor() {
        return cblas_stpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpsv$handle() {
        return cblas_stpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpsv$address() {
        return cblas_stpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpsv$descriptor() {
        return cblas_dtpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpsv$handle() {
        return cblas_dtpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpsv$address() {
        return cblas_dtpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpsv$descriptor() {
        return cblas_ctpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpsv$handle() {
        return cblas_ctpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpsv$address() {
        return cblas_ctpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpsv$descriptor() {
        return cblas_ztpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpsv$handle() {
        return cblas_ztpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpsv$address() {
        return cblas_ztpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssymv$descriptor() {
        return cblas_ssymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssymv$handle() {
        return cblas_ssymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssymv$address() {
        return cblas_ssymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssymv(int order, int Uplo, int N, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsymv$descriptor() {
        return cblas_dsymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsymv$handle() {
        return cblas_dsymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsymv$address() {
        return cblas_dsymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsymv(int order, int Uplo, int N, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chemv$descriptor() {
        return cblas_chemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chemv$handle() {
        return cblas_chemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chemv$address() {
        return cblas_chemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhemv$descriptor() {
        return cblas_zhemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhemv$handle() {
        return cblas_zhemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhemv$address() {
        return cblas_zhemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sspmv$descriptor() {
        return cblas_sspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sspmv$handle() {
        return cblas_sspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sspmv$address() {
        return cblas_sspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sspmv(int order, int Uplo, int N, float alpha, MemorySegment Ap, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dspmv$descriptor() {
        return cblas_dspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dspmv$handle() {
        return cblas_dspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dspmv$address() {
        return cblas_dspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dspmv(int order, int Uplo, int N, double alpha, MemorySegment Ap, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static FunctionDescriptor cblas_sspr$descriptor() {
        return cblas_sspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MethodHandle cblas_sspr$handle() {
        return cblas_sspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MemorySegment cblas_sspr$address() {
        return cblas_sspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static void cblas_sspr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_sspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static FunctionDescriptor cblas_dspr$descriptor() {
        return cblas_dspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MethodHandle cblas_dspr$handle() {
        return cblas_dspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MemorySegment cblas_dspr$address() {
        return cblas_dspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static void cblas_dspr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_dspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_chpr$descriptor() {
        return cblas_chpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_chpr$handle() {
        return cblas_chpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_chpr$address() {
        return cblas_chpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_chpr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_chpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_zhpr$descriptor() {
        return cblas_zhpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_zhpr$handle() {
        return cblas_zhpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_zhpr$address() {
        return cblas_zhpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_zhpr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_zhpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static FunctionDescriptor cblas_sspr2$descriptor() {
        return cblas_sspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MethodHandle cblas_sspr2$handle() {
        return cblas_sspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MemorySegment cblas_sspr2$address() {
        return cblas_sspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static void cblas_sspr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_sspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static FunctionDescriptor cblas_dspr2$descriptor() {
        return cblas_dspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MethodHandle cblas_dspr2$handle() {
        return cblas_dspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MemorySegment cblas_dspr2$address() {
        return cblas_dspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static void cblas_dspr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_dspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_chpr2$descriptor() {
        return cblas_chpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_chpr2$handle() {
        return cblas_chpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_chpr2$address() {
        return cblas_chpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_chpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_chpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_zhpr2$descriptor() {
        return cblas_zhpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_zhpr2$handle() {
        return cblas_zhpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_zhpr2$address() {
        return cblas_zhpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_zhpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_zhpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chbmv$descriptor() {
        return cblas_chbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chbmv$handle() {
        return cblas_chbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chbmv$address() {
        return cblas_chbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhbmv$descriptor() {
        return cblas_zhbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhbmv$handle() {
        return cblas_zhbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhbmv$address() {
        return cblas_zhbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chpmv$descriptor() {
        return cblas_chpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chpmv$handle() {
        return cblas_chpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chpmv$address() {
        return cblas_chpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhpmv$descriptor() {
        return cblas_zhpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhpmv$handle() {
        return cblas_zhpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhpmv$address() {
        return cblas_zhpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sgemm$descriptor() {
        return cblas_sgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sgemm$handle() {
        return cblas_sgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sgemm$address() {
        return cblas_sgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dgemm$descriptor() {
        return cblas_dgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dgemm$handle() {
        return cblas_dgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dgemm$address() {
        return cblas_dgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dgemm(int Order, int TransA, int TransB, int M, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm$descriptor() {
        return cblas_cgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm$handle() {
        return cblas_cgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm$address() {
        return cblas_cgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm3m$descriptor() {
        return cblas_cgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm3m$handle() {
        return cblas_cgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm3m$address() {
        return cblas_cgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm$descriptor() {
        return cblas_zgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm$handle() {
        return cblas_zgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm$address() {
        return cblas_zgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm3m$descriptor() {
        return cblas_zgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm3m$handle() {
        return cblas_zgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm3m$address() {
        return cblas_zgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssymm$descriptor() {
        return cblas_ssymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssymm$handle() {
        return cblas_ssymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssymm$address() {
        return cblas_ssymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssymm(int Order, int Side, int Uplo, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsymm$descriptor() {
        return cblas_dsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsymm$handle() {
        return cblas_dsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsymm$address() {
        return cblas_dsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsymm(int Order, int Side, int Uplo, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csymm$descriptor() {
        return cblas_csymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csymm$handle() {
        return cblas_csymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csymm$address() {
        return cblas_csymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsymm$descriptor() {
        return cblas_zsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsymm$handle() {
        return cblas_zsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsymm$address() {
        return cblas_zsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyrk$descriptor() {
        return cblas_ssyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyrk$handle() {
        return cblas_ssyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyrk$address() {
        return cblas_ssyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyrk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyrk$descriptor() {
        return cblas_dsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyrk$handle() {
        return cblas_dsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyrk$address() {
        return cblas_dsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyrk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyrk$descriptor() {
        return cblas_csyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyrk$handle() {
        return cblas_csyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyrk$address() {
        return cblas_csyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyrk$descriptor() {
        return cblas_zsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyrk$handle() {
        return cblas_zsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyrk$address() {
        return cblas_zsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2k$descriptor() {
        return cblas_ssyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyr2k$handle() {
        return cblas_ssyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyr2k$address() {
        return cblas_ssyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyr2k(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2k$descriptor() {
        return cblas_dsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyr2k$handle() {
        return cblas_dsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyr2k$address() {
        return cblas_dsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyr2k(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyr2k$descriptor() {
        return cblas_csyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyr2k$handle() {
        return cblas_csyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyr2k$address() {
        return cblas_csyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyr2k$descriptor() {
        return cblas_zsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyr2k$handle() {
        return cblas_zsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyr2k$address() {
        return cblas_zsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strmm$descriptor() {
        return cblas_strmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strmm$handle() {
        return cblas_strmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strmm$address() {
        return cblas_strmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrmm$descriptor() {
        return cblas_dtrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrmm$handle() {
        return cblas_dtrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrmm$address() {
        return cblas_dtrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrmm$descriptor() {
        return cblas_ctrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrmm$handle() {
        return cblas_ctrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrmm$address() {
        return cblas_ctrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrmm$descriptor() {
        return cblas_ztrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrmm$handle() {
        return cblas_ztrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrmm$address() {
        return cblas_ztrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strsm$descriptor() {
        return cblas_strsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strsm$handle() {
        return cblas_strsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strsm$address() {
        return cblas_strsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrsm$descriptor() {
        return cblas_dtrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrsm$handle() {
        return cblas_dtrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrsm$address() {
        return cblas_dtrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrsm$descriptor() {
        return cblas_ctrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrsm$handle() {
        return cblas_ctrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrsm$address() {
        return cblas_ctrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrsm$descriptor() {
        return cblas_ztrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrsm$handle() {
        return cblas_ztrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrsm$address() {
        return cblas_ztrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_chemm$descriptor() {
        return cblas_chemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_chemm$handle() {
        return cblas_chemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_chemm$address() {
        return cblas_chemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_chemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_chemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zhemm$descriptor() {
        return cblas_zhemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zhemm$handle() {
        return cblas_zhemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zhemm$address() {
        return cblas_zhemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zhemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zhemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cherk$descriptor() {
        return cblas_cherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cherk$handle() {
        return cblas_cherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cherk$address() {
        return cblas_cherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cherk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zherk$descriptor() {
        return cblas_zherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zherk$handle() {
        return cblas_zherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zherk$address() {
        return cblas_zherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zherk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cher2k$descriptor() {
        return cblas_cher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cher2k$handle() {
        return cblas_cher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cher2k$address() {
        return cblas_cher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zher2k$descriptor() {
        return cblas_zher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zher2k$handle() {
        return cblas_zher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zher2k$address() {
        return cblas_zher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void cblas_xerbla(blasint p, char *rout, char *form, ...)
     * }
     */
    public static class cblas_xerbla {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_xerbla");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private cblas_xerbla(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void cblas_xerbla(blasint p, char *rout, char *form, ...)
         * }
         */
        public static cblas_xerbla makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new cblas_xerbla(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int p, MemorySegment rout, MemorySegment form, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("cblas_xerbla", p, rout, form, x3);
                }
                 spreader.invokeExact(p, rout, form, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class cblas_saxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_saxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpby$descriptor() {
        return cblas_saxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpby$handle() {
        return cblas_saxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpby$address() {
        return cblas_saxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpby(int n, float alpha, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_saxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_daxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpby$descriptor() {
        return cblas_daxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpby$handle() {
        return cblas_daxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpby$address() {
        return cblas_daxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpby(int n, double alpha, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_daxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_caxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpby$descriptor() {
        return cblas_caxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpby$handle() {
        return cblas_caxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpby$address() {
        return cblas_caxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_caxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zaxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpby$descriptor() {
        return cblas_zaxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpby$handle() {
        return cblas_zaxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpby$address() {
        return cblas_zaxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_somatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_somatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_somatcopy$descriptor() {
        return cblas_somatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_somatcopy$handle() {
        return cblas_somatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_somatcopy$address() {
        return cblas_somatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_somatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_somatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_somatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_domatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_domatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_domatcopy$descriptor() {
        return cblas_domatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_domatcopy$handle() {
        return cblas_domatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_domatcopy$address() {
        return cblas_domatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_domatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_domatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_domatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_comatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_comatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_comatcopy$descriptor() {
        return cblas_comatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_comatcopy$handle() {
        return cblas_comatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_comatcopy$address() {
        return cblas_comatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_comatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_comatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_comatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zomatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zomatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zomatcopy$descriptor() {
        return cblas_zomatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zomatcopy$handle() {
        return cblas_zomatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zomatcopy$address() {
        return cblas_zomatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_zomatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_zomatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zomatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_simatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_simatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_simatcopy$descriptor() {
        return cblas_simatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_simatcopy$handle() {
        return cblas_simatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_simatcopy$address() {
        return cblas_simatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_simatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_simatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_simatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_dimatcopy$descriptor() {
        return cblas_dimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_dimatcopy$handle() {
        return cblas_dimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_dimatcopy$address() {
        return cblas_dimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_dimatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_dimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_cimatcopy$descriptor() {
        return cblas_cimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_cimatcopy$handle() {
        return cblas_cimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_cimatcopy$address() {
        return cblas_cimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_cimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_cimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zimatcopy$descriptor() {
        return cblas_zimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zimatcopy$handle() {
        return cblas_zimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zimatcopy$address() {
        return cblas_zimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_zimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_zimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_sgeadd$descriptor() {
        return cblas_sgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_sgeadd$handle() {
        return cblas_sgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_sgeadd$address() {
        return cblas_sgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_sgeadd(int CORDER, int crows, int ccols, float calpha, MemorySegment a, int clda, float cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_sgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_dgeadd$descriptor() {
        return cblas_dgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_dgeadd$handle() {
        return cblas_dgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_dgeadd$address() {
        return cblas_dgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_dgeadd(int CORDER, int crows, int ccols, double calpha, MemorySegment a, int clda, double cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_dgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_cgeadd$descriptor() {
        return cblas_cgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_cgeadd$handle() {
        return cblas_cgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_cgeadd$address() {
        return cblas_cgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_cgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_cgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_zgeadd$descriptor() {
        return cblas_zgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_zgeadd$handle() {
        return cblas_zgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_zgeadd$address() {
        return cblas_zgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_zgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_zgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbstobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbstobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbstobf16$descriptor() {
        return cblas_sbstobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbstobf16$handle() {
        return cblas_sbstobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbstobf16$address() {
        return cblas_sbstobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbstobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbstobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbstobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdtobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbdtobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbdtobf16$descriptor() {
        return cblas_sbdtobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbdtobf16$handle() {
        return cblas_sbdtobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbdtobf16$address() {
        return cblas_sbdtobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbdtobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbdtobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdtobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbf16tos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbf16tos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbf16tos$descriptor() {
        return cblas_sbf16tos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbf16tos$handle() {
        return cblas_sbf16tos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbf16tos$address() {
        return cblas_sbf16tos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static void cblas_sbf16tos(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbf16tos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbf16tos", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dbf16tod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dbf16tod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_dbf16tod$descriptor() {
        return cblas_dbf16tod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_dbf16tod$handle() {
        return cblas_dbf16tod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_dbf16tod$address() {
        return cblas_dbf16tod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static void cblas_dbf16tod(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_dbf16tod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dbf16tod", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbdot$descriptor() {
        return cblas_sbdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbdot$handle() {
        return cblas_sbdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbdot$address() {
        return cblas_sbdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static float cblas_sbdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sbdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbgemv$descriptor() {
        return cblas_sbgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbgemv$handle() {
        return cblas_sbgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbgemv$address() {
        return cblas_sbgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sbgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sbgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sbgemm$descriptor() {
        return cblas_sbgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sbgemm$handle() {
        return cblas_sbgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sbgemm$address() {
        return cblas_sbgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sbgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sbgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = cblas_openblas_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = cblas_openblas_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            cblas_openblas_h.C_LONG_LONG,
            cblas_openblas_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float lapack_float_return
     * }
     */
    public static final OfFloat lapack_float_return = cblas_openblas_h.C_FLOAT;

    private static class lsame_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lsame_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static FunctionDescriptor lsame_$descriptor() {
        return lsame_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static MethodHandle lsame_$handle() {
        return lsame_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static MemorySegment lsame_$address() {
        return lsame_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static int lsame_(MemorySegment ca, MemorySegment cb, int lca, int lcb, long x4, long x5) {
        var mh$ = lsame_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsame_", ca, cb, lca, lcb, x4, x5);
            }
            return (int)mh$.invokeExact(ca, cb, lca, lcb, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cbbcsd_$descriptor() {
        return cbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cbbcsd_$handle() {
        return cbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cbbcsd_$address() {
        return cbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = cbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbbcsd_$descriptor() {
        return dbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dbbcsd_$handle() {
        return dbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dbbcsd_$address() {
        return dbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, MemorySegment lwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = dbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, b21d, b21e, b22d, b22e, work, lwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, b21d, b21e, b22d, b22e, work, lwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbbcsd_$descriptor() {
        return sbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sbbcsd_$handle() {
        return sbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sbbcsd_$address() {
        return sbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment work, MemorySegment lwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = sbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, work, lwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, work, lwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zbbcsd_$descriptor() {
        return zbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zbbcsd_$handle() {
        return zbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zbbcsd_$address() {
        return zbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = zbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbdsdc_$descriptor() {
        return dbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dbdsdc_$handle() {
        return dbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dbdsdc_$address() {
        return dbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dbdsdc_(MemorySegment uplo, MemorySegment compq, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment Q, MemorySegment IQ, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14, long x15) {
        var mh$ = dbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsdc_", uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
            }
            mh$.invokeExact(uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbdsdc_$descriptor() {
        return sbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sbdsdc_$handle() {
        return sbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sbdsdc_$address() {
        return sbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sbdsdc_(MemorySegment uplo, MemorySegment compq, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment Q, MemorySegment IQ, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14, long x15) {
        var mh$ = sbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsdc_", uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
            }
            mh$.invokeExact(uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cbdsqr_$descriptor() {
        return cbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cbdsqr_$handle() {
        return cbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cbdsqr_$address() {
        return cbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static void cbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = cbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dbdsqr_$descriptor() {
        return dbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dbdsqr_$handle() {
        return dbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dbdsqr_$address() {
        return dbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static void dbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x15) {
        var mh$ = dbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sbdsqr_$descriptor() {
        return sbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sbdsqr_$handle() {
        return sbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sbdsqr_$address() {
        return sbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static void sbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x15) {
        var mh$ = sbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zbdsqr_$descriptor() {
        return zbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zbdsqr_$handle() {
        return zbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zbdsqr_$address() {
        return zbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static void zbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dbdsvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbdsvdx_$descriptor() {
        return dbdsvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dbdsvdx_$handle() {
        return dbdsvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dbdsvdx_$address() {
        return dbdsvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dbdsvdx_(MemorySegment uplo, MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = dbdsvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsvdx_", uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbdsvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbdsvdx_$descriptor() {
        return sbdsvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sbdsvdx_$handle() {
        return sbdsvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sbdsvdx_$address() {
        return sbdsvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sbdsvdx_(MemorySegment uplo, MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = sbdsvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsvdx_", uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ddisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ddisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ddisna_$descriptor() {
        return ddisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static MethodHandle ddisna_$handle() {
        return ddisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static MemorySegment ddisna_$address() {
        return ddisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static void ddisna_(MemorySegment job, MemorySegment m, MemorySegment n, MemorySegment D, MemorySegment SEP, MemorySegment info, long x6) {
        var mh$ = ddisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ddisna_", job, m, n, D, SEP, info, x6);
            }
            mh$.invokeExact(job, m, n, D, SEP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sdisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sdisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sdisna_$descriptor() {
        return sdisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static MethodHandle sdisna_$handle() {
        return sdisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static MemorySegment sdisna_$address() {
        return sdisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static void sdisna_(MemorySegment job, MemorySegment m, MemorySegment n, MemorySegment D, MemorySegment SEP, MemorySegment info, long x6) {
        var mh$ = sdisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sdisna_", job, m, n, D, SEP, info, x6);
            }
            mh$.invokeExact(job, m, n, D, SEP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbbrd_$descriptor() {
        return cgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbbrd_$handle() {
        return cgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbbrd_$address() {
        return cgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = cgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbbrd_$descriptor() {
        return dgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dgbbrd_$handle() {
        return dgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dgbbrd_$address() {
        return dgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static void dgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x18) {
        var mh$ = dgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbbrd_$descriptor() {
        return sgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sgbbrd_$handle() {
        return sgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sgbbrd_$address() {
        return sgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static void sgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x18) {
        var mh$ = sgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbbrd_$descriptor() {
        return zgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbbrd_$handle() {
        return zgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbbrd_$address() {
        return zgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = zgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbcon_$descriptor() {
        return cgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbcon_$handle() {
        return cgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbcon_$address() {
        return cgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12) {
        var mh$ = cgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbcon_$descriptor() {
        return dgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgbcon_$handle() {
        return dgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgbcon_$address() {
        return dgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = dgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbcon_$descriptor() {
        return sgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgbcon_$handle() {
        return sgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgbcon_$address() {
        return sgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = sgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbcon_$descriptor() {
        return zgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbcon_$handle() {
        return zgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbcon_$address() {
        return zgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12) {
        var mh$ = zgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgbequ_$descriptor() {
        return cgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgbequ_$handle() {
        return cgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgbequ_$address() {
        return cgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgbequ_$descriptor() {
        return dgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgbequ_$handle() {
        return dgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgbequ_$address() {
        return dgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgbequ_$descriptor() {
        return sgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgbequ_$handle() {
        return sgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgbequ_$address() {
        return sgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgbequ_$descriptor() {
        return zgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgbequ_$handle() {
        return zgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgbequ_$address() {
        return zgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgbequb_$descriptor() {
        return cgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgbequb_$handle() {
        return cgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgbequb_$address() {
        return cgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgbequb_$descriptor() {
        return dgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgbequb_$handle() {
        return dgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgbequb_$address() {
        return dgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgbequb_$descriptor() {
        return sgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgbequb_$handle() {
        return sgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgbequb_$address() {
        return sgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgbequb_$descriptor() {
        return zgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgbequb_$handle() {
        return zgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgbequb_$address() {
        return zgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbrfs_$descriptor() {
        return cgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbrfs_$handle() {
        return cgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbrfs_$address() {
        return cgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = cgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbrfs_$descriptor() {
        return dgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgbrfs_$handle() {
        return dgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgbrfs_$address() {
        return dgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x19) {
        var mh$ = dgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbrfs_$descriptor() {
        return sgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgbrfs_$handle() {
        return sgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgbrfs_$address() {
        return sgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x19) {
        var mh$ = sgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbrfs_$descriptor() {
        return zgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbrfs_$handle() {
        return zgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbrfs_$address() {
        return zgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = zgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbrfsx_$descriptor() {
        return cgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgbrfsx_$handle() {
        return cgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgbrfsx_$address() {
        return cgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28) {
        var mh$ = cgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbrfsx_$descriptor() {
        return dgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgbrfsx_$handle() {
        return dgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgbrfsx_$address() {
        return dgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28) {
        var mh$ = dgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbrfsx_$descriptor() {
        return sgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgbrfsx_$handle() {
        return sgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgbrfsx_$address() {
        return sgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28) {
        var mh$ = sgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbrfsx_$descriptor() {
        return zgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgbrfsx_$handle() {
        return zgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgbrfsx_$address() {
        return zgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28) {
        var mh$ = zgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgbsv_$descriptor() {
        return cgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgbsv_$handle() {
        return cgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgbsv_$address() {
        return cgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgbsv_$descriptor() {
        return dgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgbsv_$handle() {
        return dgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgbsv_$address() {
        return dgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgbsv_$descriptor() {
        return sgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgbsv_$handle() {
        return sgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgbsv_$address() {
        return sgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgbsv_$descriptor() {
        return zgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgbsv_$handle() {
        return zgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgbsv_$address() {
        return zgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbsvx_$descriptor() {
        return cgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgbsvx_$handle() {
        return cgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgbsvx_$address() {
        return cgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = cgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbsvx_$descriptor() {
        return dgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgbsvx_$handle() {
        return dgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgbsvx_$address() {
        return dgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbsvx_$descriptor() {
        return sgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgbsvx_$handle() {
        return sgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgbsvx_$address() {
        return sgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbsvx_$descriptor() {
        return zgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgbsvx_$handle() {
        return zgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgbsvx_$address() {
        return zgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbsvxx_$descriptor() {
        return cgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgbsvxx_$handle() {
        return cgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgbsvxx_$address() {
        return cgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = cgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbsvxx_$descriptor() {
        return dgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgbsvxx_$handle() {
        return dgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgbsvxx_$address() {
        return dgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = dgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbsvxx_$descriptor() {
        return sgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgbsvxx_$handle() {
        return sgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgbsvxx_$address() {
        return sgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = sgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbsvxx_$descriptor() {
        return zgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgbsvxx_$handle() {
        return zgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgbsvxx_$address() {
        return zgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = zgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgbtrf_$descriptor() {
        return cgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgbtrf_$handle() {
        return cgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgbtrf_$address() {
        return cgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void cgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgbtrf_$descriptor() {
        return dgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgbtrf_$handle() {
        return dgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgbtrf_$address() {
        return dgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void dgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgbtrf_$descriptor() {
        return sgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgbtrf_$handle() {
        return sgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgbtrf_$address() {
        return sgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void sgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgbtrf_$descriptor() {
        return zgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgbtrf_$handle() {
        return zgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgbtrf_$address() {
        return zgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void zgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbtrs_$descriptor() {
        return cgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgbtrs_$handle() {
        return cgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgbtrs_$address() {
        return cgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = cgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbtrs_$descriptor() {
        return dgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgbtrs_$handle() {
        return dgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgbtrs_$address() {
        return dgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = dgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbtrs_$descriptor() {
        return sgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgbtrs_$handle() {
        return sgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgbtrs_$address() {
        return sgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = sgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbtrs_$descriptor() {
        return zgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgbtrs_$handle() {
        return zgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgbtrs_$address() {
        return zgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = zgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgebak_$descriptor() {
        return cgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgebak_$handle() {
        return cgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgebak_$address() {
        return cgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void cgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = cgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgebak_$descriptor() {
        return dgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgebak_$handle() {
        return dgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgebak_$address() {
        return dgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void dgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = dgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgebak_$descriptor() {
        return sgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgebak_$handle() {
        return sgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgebak_$address() {
        return sgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void sgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = sgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgebak_$descriptor() {
        return zgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgebak_$handle() {
        return zgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgebak_$address() {
        return zgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void zgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = zgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgebal_$descriptor() {
        return cgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MethodHandle cgebal_$handle() {
        return cgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MemorySegment cgebal_$address() {
        return cgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static void cgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = cgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgebal_$descriptor() {
        return dgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MethodHandle dgebal_$handle() {
        return dgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MemorySegment dgebal_$address() {
        return dgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static void dgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = dgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgebal_$descriptor() {
        return sgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MethodHandle sgebal_$handle() {
        return sgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MemorySegment sgebal_$address() {
        return sgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static void sgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = sgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgebal_$descriptor() {
        return zgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MethodHandle zgebal_$handle() {
        return zgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MemorySegment zgebal_$address() {
        return zgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static void zgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = zgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgebrd_$descriptor() {
        return cgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgebrd_$handle() {
        return cgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgebrd_$address() {
        return cgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgebrd_$descriptor() {
        return dgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgebrd_$handle() {
        return dgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgebrd_$address() {
        return dgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgebrd_$descriptor() {
        return sgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgebrd_$handle() {
        return sgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgebrd_$address() {
        return sgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgebrd_$descriptor() {
        return zgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgebrd_$handle() {
        return zgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgebrd_$address() {
        return zgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgecon_$descriptor() {
        return cgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgecon_$handle() {
        return cgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgecon_$address() {
        return cgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = cgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgecon_", norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgecon_$descriptor() {
        return dgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgecon_$handle() {
        return dgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgecon_$address() {
        return dgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgecon_", norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgecon_$descriptor() {
        return sgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgecon_$handle() {
        return sgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgecon_$address() {
        return sgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = sgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgecon_", norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgecon_$descriptor() {
        return zgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgecon_$handle() {
        return zgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgecon_$address() {
        return zgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = zgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgecon_", norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgeequ_$descriptor() {
        return cgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgeequ_$handle() {
        return cgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgeequ_$address() {
        return cgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgeequ_$descriptor() {
        return dgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgeequ_$handle() {
        return dgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgeequ_$address() {
        return dgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgeequ_$descriptor() {
        return sgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgeequ_$handle() {
        return sgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgeequ_$address() {
        return sgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgeequ_$descriptor() {
        return zgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgeequ_$handle() {
        return zgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgeequ_$address() {
        return zgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgeequb_$descriptor() {
        return cgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgeequb_$handle() {
        return cgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgeequb_$address() {
        return cgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgeequb_$descriptor() {
        return dgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgeequb_$handle() {
        return dgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgeequb_$address() {
        return dgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgeequb_$descriptor() {
        return sgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgeequb_$handle() {
        return sgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgeequb_$address() {
        return sgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgeequb_$descriptor() {
        return zgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgeequb_$handle() {
        return zgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgeequb_$address() {
        return zgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgees_$descriptor() {
        return cgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgees_$handle() {
        return cgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgees_$address() {
        return cgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void cgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = cgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgees_", jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgees_$descriptor() {
        return dgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgees_$handle() {
        return dgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgees_$address() {
        return dgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void dgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = dgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgees_", jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgees_$descriptor() {
        return sgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgees_$handle() {
        return sgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgees_$address() {
        return sgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void sgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = sgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgees_", jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgees_$descriptor() {
        return zgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgees_$handle() {
        return zgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgees_$address() {
        return zgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void zgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = zgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgees_", jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeesx_$descriptor() {
        return cgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgeesx_$handle() {
        return cgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgeesx_$address() {
        return cgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = cgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeesx_$descriptor() {
        return dgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgeesx_$handle() {
        return dgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgeesx_$address() {
        return dgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeesx_$descriptor() {
        return sgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgeesx_$handle() {
        return sgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgeesx_$address() {
        return sgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeesx_$descriptor() {
        return zgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgeesx_$handle() {
        return zgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgeesx_$address() {
        return zgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = zgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeev_$descriptor() {
        return cgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgeev_$handle() {
        return cgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgeev_$address() {
        return cgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeev_", jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeev_$descriptor() {
        return dgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgeev_$handle() {
        return dgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgeev_$address() {
        return dgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeev_", jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeev_$descriptor() {
        return sgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgeev_$handle() {
        return sgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgeev_$address() {
        return sgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeev_", jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeev_$descriptor() {
        return zgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgeev_$handle() {
        return zgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgeev_$address() {
        return zgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeev_", jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeevx_$descriptor() {
        return cgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgeevx_$handle() {
        return cgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgeevx_$address() {
        return cgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24, long x25) {
        var mh$ = cgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeevx_$descriptor() {
        return dgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgeevx_$handle() {
        return dgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgeevx_$address() {
        return dgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25, long x26) {
        var mh$ = dgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeevx_$descriptor() {
        return sgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgeevx_$handle() {
        return sgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgeevx_$address() {
        return sgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25, long x26) {
        var mh$ = sgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeevx_$descriptor() {
        return zgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgeevx_$handle() {
        return zgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgeevx_$address() {
        return zgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24, long x25) {
        var mh$ = zgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgehrd_$descriptor() {
        return cgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgehrd_$handle() {
        return cgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgehrd_$address() {
        return cgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgehrd_$descriptor() {
        return dgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgehrd_$handle() {
        return dgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgehrd_$address() {
        return dgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgehrd_$descriptor() {
        return sgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgehrd_$handle() {
        return sgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgehrd_$address() {
        return sgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgehrd_$descriptor() {
        return zgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgehrd_$handle() {
        return zgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgehrd_$address() {
        return zgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgejsv_$descriptor() {
        return cgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgejsv_$handle() {
        return cgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgejsv_$address() {
        return cgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = cgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgejsv_$descriptor() {
        return dgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgejsv_$handle() {
        return dgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgejsv_$address() {
        return dgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x19, long x20, long x21, long x22, long x23, long x24) {
        var mh$ = dgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgejsv_$descriptor() {
        return sgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgejsv_$handle() {
        return sgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgejsv_$address() {
        return sgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x19, long x20, long x21, long x22, long x23, long x24) {
        var mh$ = sgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgejsv_$descriptor() {
        return zgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgejsv_$handle() {
        return zgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgejsv_$address() {
        return zgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = zgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelq_$descriptor() {
        return cgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgelq_$handle() {
        return cgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgelq_$address() {
        return cgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelq_$descriptor() {
        return dgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelq_$handle() {
        return dgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelq_$address() {
        return dgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelq_$descriptor() {
        return sgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelq_$handle() {
        return sgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelq_$address() {
        return sgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelq_$descriptor() {
        return zgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgelq_$handle() {
        return zgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgelq_$address() {
        return zgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgelq2_$descriptor() {
        return cgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgelq2_$handle() {
        return cgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgelq2_$address() {
        return cgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgelq2_$descriptor() {
        return dgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgelq2_$handle() {
        return dgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgelq2_$address() {
        return dgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgelq2_$descriptor() {
        return sgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgelq2_$handle() {
        return sgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgelq2_$address() {
        return sgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgelq2_$descriptor() {
        return zgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgelq2_$handle() {
        return zgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgelq2_$address() {
        return zgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelqf_$descriptor() {
        return cgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgelqf_$handle() {
        return cgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgelqf_$address() {
        return cgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelqf_$descriptor() {
        return dgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelqf_$handle() {
        return dgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelqf_$address() {
        return dgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelqf_$descriptor() {
        return sgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelqf_$handle() {
        return sgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelqf_$address() {
        return sgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelqf_$descriptor() {
        return zgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgelqf_$handle() {
        return zgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgelqf_$address() {
        return zgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgels_$descriptor() {
        return cgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgels_$handle() {
        return cgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgels_$address() {
        return cgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = cgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgels_$descriptor() {
        return dgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgels_$handle() {
        return dgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgels_$address() {
        return dgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgels_$descriptor() {
        return sgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgels_$handle() {
        return sgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgels_$address() {
        return sgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = sgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgels_$descriptor() {
        return zgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgels_$handle() {
        return zgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgels_$address() {
        return zgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelsd_$descriptor() {
        return cgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle cgelsd_$handle() {
        return cgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment cgelsd_$address() {
        return cgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static void cgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = cgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelsd_$descriptor() {
        return dgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle dgelsd_$handle() {
        return dgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment dgelsd_$address() {
        return dgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static void dgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = dgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelsd_$descriptor() {
        return sgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle sgelsd_$handle() {
        return sgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment sgelsd_$address() {
        return sgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static void sgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = sgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelsd_$descriptor() {
        return zgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle zgelsd_$handle() {
        return zgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment zgelsd_$address() {
        return zgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static void zgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = zgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelss_$descriptor() {
        return cgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgelss_$handle() {
        return cgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgelss_$address() {
        return cgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelss_$descriptor() {
        return dgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelss_$handle() {
        return dgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelss_$address() {
        return dgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelss_$descriptor() {
        return sgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelss_$handle() {
        return sgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelss_$address() {
        return sgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelss_$descriptor() {
        return zgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgelss_$handle() {
        return zgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgelss_$address() {
        return zgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelsy_$descriptor() {
        return cgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgelsy_$handle() {
        return cgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgelsy_$address() {
        return cgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelsy_$descriptor() {
        return dgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelsy_$handle() {
        return dgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelsy_$address() {
        return dgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelsy_$descriptor() {
        return sgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelsy_$handle() {
        return sgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelsy_$address() {
        return sgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelsy_$descriptor() {
        return zgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgelsy_$handle() {
        return zgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgelsy_$address() {
        return zgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemlq_$descriptor() {
        return cgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemlq_$handle() {
        return cgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemlq_$address() {
        return cgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemlq_$descriptor() {
        return dgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemlq_$handle() {
        return dgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemlq_$address() {
        return dgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemlq_$descriptor() {
        return sgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemlq_$handle() {
        return sgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemlq_$address() {
        return sgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemlq_$descriptor() {
        return zgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemlq_$handle() {
        return zgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemlq_$address() {
        return zgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemqr_$descriptor() {
        return cgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemqr_$handle() {
        return cgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemqr_$address() {
        return cgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemqr_$descriptor() {
        return dgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemqr_$handle() {
        return dgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemqr_$address() {
        return dgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemqr_$descriptor() {
        return sgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemqr_$handle() {
        return sgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemqr_$address() {
        return sgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemqr_$descriptor() {
        return zgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemqr_$handle() {
        return zgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemqr_$address() {
        return zgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemqrt_$descriptor() {
        return cgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemqrt_$handle() {
        return cgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemqrt_$address() {
        return cgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void cgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = cgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemqrt_$descriptor() {
        return dgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemqrt_$handle() {
        return dgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemqrt_$address() {
        return dgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemqrt_$descriptor() {
        return sgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemqrt_$handle() {
        return sgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemqrt_$address() {
        return sgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = sgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemqrt_$descriptor() {
        return zgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemqrt_$handle() {
        return zgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemqrt_$address() {
        return zgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void zgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = zgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeql2_$descriptor() {
        return cgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeql2_$handle() {
        return cgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeql2_$address() {
        return cgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeql2_$descriptor() {
        return dgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeql2_$handle() {
        return dgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeql2_$address() {
        return dgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeql2_$descriptor() {
        return sgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeql2_$handle() {
        return sgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeql2_$address() {
        return sgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeql2_$descriptor() {
        return zgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeql2_$handle() {
        return zgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeql2_$address() {
        return zgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqlf_$descriptor() {
        return cgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqlf_$handle() {
        return cgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqlf_$address() {
        return cgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqlf_$descriptor() {
        return dgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqlf_$handle() {
        return dgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqlf_$address() {
        return dgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqlf_$descriptor() {
        return sgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqlf_$handle() {
        return sgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqlf_$address() {
        return sgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqlf_$descriptor() {
        return zgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqlf_$handle() {
        return zgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqlf_$address() {
        return zgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqpf_$descriptor() {
        return sgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqpf_$handle() {
        return sgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqpf_$address() {
        return sgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static void sgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqpf_", m, n, a, lda, jpvt, tau, work, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqpf_$descriptor() {
        return dgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqpf_$handle() {
        return dgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqpf_$address() {
        return dgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static void dgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqpf_", m, n, a, lda, jpvt, tau, work, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqpf_$descriptor() {
        return cgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgeqpf_$handle() {
        return cgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgeqpf_$address() {
        return cgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static void cgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqpf_", m, n, a, lda, jpvt, tau, work, rwork, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqpf_$descriptor() {
        return zgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgeqpf_$handle() {
        return zgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgeqpf_$address() {
        return zgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static void zgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqpf_", m, n, a, lda, jpvt, tau, work, rwork, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqp3_$descriptor() {
        return cgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgeqp3_$handle() {
        return cgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgeqp3_$address() {
        return cgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqp3_$descriptor() {
        return dgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqp3_$handle() {
        return dgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqp3_$address() {
        return dgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqp3_$descriptor() {
        return sgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqp3_$handle() {
        return sgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqp3_$address() {
        return sgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqp3_$descriptor() {
        return zgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgeqp3_$handle() {
        return zgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgeqp3_$address() {
        return zgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqr_$descriptor() {
        return cgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqr_$handle() {
        return cgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqr_$address() {
        return cgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqr_$descriptor() {
        return dgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqr_$handle() {
        return dgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqr_$address() {
        return dgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqr_$descriptor() {
        return sgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqr_$handle() {
        return sgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqr_$address() {
        return sgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqr_$descriptor() {
        return zgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqr_$handle() {
        return zgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqr_$address() {
        return zgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeqr2_$descriptor() {
        return cgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeqr2_$handle() {
        return cgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeqr2_$address() {
        return cgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqr2_$descriptor() {
        return dgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqr2_$handle() {
        return dgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqr2_$address() {
        return dgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqr2_$descriptor() {
        return sgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqr2_$handle() {
        return sgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqr2_$address() {
        return sgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeqr2_$descriptor() {
        return zgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeqr2_$handle() {
        return zgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeqr2_$address() {
        return zgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrf_$descriptor() {
        return cgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqrf_$handle() {
        return cgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqrf_$address() {
        return cgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrf_$descriptor() {
        return dgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqrf_$handle() {
        return dgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqrf_$address() {
        return dgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrf_$descriptor() {
        return sgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqrf_$handle() {
        return sgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqrf_$address() {
        return sgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrf_$descriptor() {
        return zgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqrf_$handle() {
        return zgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqrf_$address() {
        return zgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrfp_$descriptor() {
        return cgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqrfp_$handle() {
        return cgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqrfp_$address() {
        return cgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrfp_$descriptor() {
        return dgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqrfp_$handle() {
        return dgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqrfp_$address() {
        return dgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrfp_$descriptor() {
        return sgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqrfp_$handle() {
        return sgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqrfp_$address() {
        return sgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrfp_$descriptor() {
        return zgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqrfp_$handle() {
        return zgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqrfp_$address() {
        return zgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt_$descriptor() {
        return cgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeqrt_$handle() {
        return cgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeqrt_$address() {
        return cgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void cgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = cgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt_$descriptor() {
        return dgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqrt_$handle() {
        return dgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqrt_$address() {
        return dgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt_$descriptor() {
        return sgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqrt_$handle() {
        return sgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqrt_$address() {
        return sgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void sgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt_$descriptor() {
        return zgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeqrt_$handle() {
        return zgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeqrt_$address() {
        return zgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void zgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = zgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt2_$descriptor() {
        return cgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle cgeqrt2_$handle() {
        return cgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment cgeqrt2_$address() {
        return cgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void cgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = cgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt2_$descriptor() {
        return dgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dgeqrt2_$handle() {
        return dgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dgeqrt2_$address() {
        return dgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static void dgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt2_$descriptor() {
        return sgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle sgeqrt2_$handle() {
        return sgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment sgeqrt2_$address() {
        return sgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static void sgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = sgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt2_$descriptor() {
        return zgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle zgeqrt2_$handle() {
        return zgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment zgeqrt2_$address() {
        return zgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void zgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = zgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt3_$descriptor() {
        return cgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle cgeqrt3_$handle() {
        return cgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment cgeqrt3_$address() {
        return cgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void cgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = cgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

