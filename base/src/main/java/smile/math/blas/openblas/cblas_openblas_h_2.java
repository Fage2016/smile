// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h_2 extends cblas_openblas_h_3 {

    cblas_openblas_h_2() {
        // Should not be called directly
    }

    private static class stpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpmqrt_$descriptor() {
        return stpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpmqrt_$handle() {
        return stpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpmqrt_$address() {
        return stpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = stpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpmqrt_$descriptor() {
        return ztpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpmqrt_$handle() {
        return ztpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpmqrt_$address() {
        return ztpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void ztpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ztpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor ctpqrt_$descriptor() {
        return ctpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle ctpqrt_$handle() {
        return ctpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment ctpqrt_$address() {
        return ctpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void ctpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ctpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dtpqrt_$descriptor() {
        return dtpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dtpqrt_$handle() {
        return dtpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dtpqrt_$address() {
        return dtpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dtpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dtpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor stpqrt_$descriptor() {
        return stpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle stpqrt_$handle() {
        return stpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment stpqrt_$address() {
        return stpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void stpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = stpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor ztpqrt_$descriptor() {
        return ztpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle ztpqrt_$handle() {
        return ztpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment ztpqrt_$address() {
        return ztpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void ztpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ztpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ctpqrt2_$descriptor() {
        return ctpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ctpqrt2_$handle() {
        return ctpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ctpqrt2_$address() {
        return ctpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void ctpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ctpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dtpqrt2_$descriptor() {
        return dtpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dtpqrt2_$handle() {
        return dtpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dtpqrt2_$address() {
        return dtpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static void dtpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dtpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor stpqrt2_$descriptor() {
        return stpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle stpqrt2_$handle() {
        return stpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment stpqrt2_$address() {
        return stpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static void stpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = stpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ztpqrt2_$descriptor() {
        return ztpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ztpqrt2_$handle() {
        return ztpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ztpqrt2_$address() {
        return ztpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void ztpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ztpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctprfb_$descriptor() {
        return ctprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctprfb_$handle() {
        return ctprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctprfb_$address() {
        return ctprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ctprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = ctprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtprfb_$descriptor() {
        return dtprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtprfb_$handle() {
        return dtprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtprfb_$address() {
        return dtprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dtprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = dtprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stprfb_$descriptor() {
        return stprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stprfb_$handle() {
        return stprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stprfb_$address() {
        return stprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void stprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = stprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztprfb_$descriptor() {
        return ztprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztprfb_$handle() {
        return ztprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztprfb_$address() {
        return ztprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ztprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = ztprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctprfs_$descriptor() {
        return ctprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctprfs_$handle() {
        return ctprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctprfs_$address() {
        return ctprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = ctprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtprfs_$descriptor() {
        return dtprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtprfs_$handle() {
        return dtprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtprfs_$address() {
        return dtprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = dtprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stprfs_$descriptor() {
        return stprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stprfs_$handle() {
        return stprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stprfs_$address() {
        return stprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = stprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztprfs_$descriptor() {
        return ztprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztprfs_$handle() {
        return ztprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztprfs_$address() {
        return ztprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = ztprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctptri_$descriptor() {
        return ctptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctptri_$handle() {
        return ctptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctptri_$address() {
        return ctptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static void ctptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = ctptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtptri_$descriptor() {
        return dtptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtptri_$handle() {
        return dtptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtptri_$address() {
        return dtptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static void dtptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = dtptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stptri_$descriptor() {
        return stptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stptri_$handle() {
        return stptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stptri_$address() {
        return stptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static void stptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = stptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztptri_$descriptor() {
        return ztptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztptri_$handle() {
        return ztptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztptri_$address() {
        return ztptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static void ztptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = ztptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctptrs_$descriptor() {
        return ctptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctptrs_$handle() {
        return ctptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctptrs_$address() {
        return ctptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ctptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtptrs_$descriptor() {
        return dtptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtptrs_$handle() {
        return dtptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtptrs_$address() {
        return dtptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = dtptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stptrs_$descriptor() {
        return stptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stptrs_$handle() {
        return stptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stptrs_$address() {
        return stptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = stptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztptrs_$descriptor() {
        return ztptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztptrs_$handle() {
        return ztptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztptrs_$address() {
        return ztptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ztptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpttf_$descriptor() {
        return ctpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpttf_$handle() {
        return ctpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpttf_$address() {
        return ctpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ctpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = ctpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpttf_$descriptor() {
        return dtpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpttf_$handle() {
        return dtpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpttf_$address() {
        return dtpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void dtpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = dtpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpttf_$descriptor() {
        return stpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpttf_$handle() {
        return stpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpttf_$address() {
        return stpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void stpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = stpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpttf_$descriptor() {
        return ztpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpttf_$handle() {
        return ztpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpttf_$address() {
        return ztpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ztpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = ztpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctpttr_$descriptor() {
        return ctpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle ctpttr_$handle() {
        return ctpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment ctpttr_$address() {
        return ctpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void ctpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = ctpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtpttr_$descriptor() {
        return dtpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dtpttr_$handle() {
        return dtpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dtpttr_$address() {
        return dtpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dtpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = dtpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor stpttr_$descriptor() {
        return stpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle stpttr_$handle() {
        return stpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment stpttr_$address() {
        return stpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void stpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = stpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztpttr_$descriptor() {
        return ztpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle ztpttr_$handle() {
        return ztpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment ztpttr_$address() {
        return ztpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void ztpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = ztpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrcon_$descriptor() {
        return ctrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrcon_$handle() {
        return ctrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrcon_$address() {
        return ctrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ctrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrcon_", norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrcon_$descriptor() {
        return dtrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrcon_$handle() {
        return dtrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrcon_$address() {
        return dtrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = dtrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrcon_", norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strcon_$descriptor() {
        return strcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strcon_$handle() {
        return strcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strcon_$address() {
        return strcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = strcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcon_", norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrcon_$descriptor() {
        return ztrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrcon_$handle() {
        return ztrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrcon_$address() {
        return ztrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ztrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrcon_", norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrevc_$descriptor() {
        return ctrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrevc_$handle() {
        return ctrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrevc_$address() {
        return ctrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = ctrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrevc_$descriptor() {
        return dtrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrevc_$handle() {
        return dtrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrevc_$address() {
        return dtrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dtrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strevc_$descriptor() {
        return strevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strevc_$handle() {
        return strevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strevc_$address() {
        return strevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static void strevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = strevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrevc_$descriptor() {
        return ztrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrevc_$handle() {
        return ztrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrevc_$address() {
        return ztrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = ztrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrevc3_$descriptor() {
        return ctrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrevc3_$handle() {
        return ctrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrevc3_$address() {
        return ctrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x17, long x18) {
        var mh$ = ctrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrevc3_$descriptor() {
        return dtrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrevc3_$handle() {
        return dtrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrevc3_$address() {
        return dtrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = dtrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strevc3_$descriptor() {
        return strevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strevc3_$handle() {
        return strevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strevc3_$address() {
        return strevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void strevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = strevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrevc3_$descriptor() {
        return ztrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrevc3_$handle() {
        return ztrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrevc3_$address() {
        return ztrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x17, long x18) {
        var mh$ = ztrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctrexc_$descriptor() {
        return ctrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MethodHandle ctrexc_$handle() {
        return ctrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MemorySegment ctrexc_$address() {
        return ctrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static void ctrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment info, long x9) {
        var mh$ = ctrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtrexc_$descriptor() {
        return dtrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dtrexc_$handle() {
        return dtrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dtrexc_$address() {
        return dtrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static void dtrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = dtrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor strexc_$descriptor() {
        return strexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle strexc_$handle() {
        return strexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment strexc_$address() {
        return strexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static void strexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = strexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztrexc_$descriptor() {
        return ztrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MethodHandle ztrexc_$handle() {
        return ztrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MemorySegment ztrexc_$address() {
        return ztrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static void ztrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment info, long x9) {
        var mh$ = ztrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrrfs_$descriptor() {
        return ctrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrrfs_$handle() {
        return ctrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrrfs_$address() {
        return ctrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = ctrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrrfs_$descriptor() {
        return dtrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrrfs_$handle() {
        return dtrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrrfs_$address() {
        return dtrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = dtrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strrfs_$descriptor() {
        return strrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strrfs_$handle() {
        return strrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strrfs_$address() {
        return strrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = strrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrrfs_$descriptor() {
        return ztrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrrfs_$handle() {
        return ztrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrrfs_$address() {
        return ztrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = ztrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsen_$descriptor() {
        return ctrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsen_$handle() {
        return ctrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsen_$address() {
        return ctrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment W, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = ctrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsen_", job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsen_$descriptor() {
        return dtrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsen_$handle() {
        return dtrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsen_$address() {
        return dtrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment WR, MemorySegment WI, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x18, long x19) {
        var mh$ = dtrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsen_", job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsen_$descriptor() {
        return strsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsen_$handle() {
        return strsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsen_$address() {
        return strsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void strsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment WR, MemorySegment WI, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x18, long x19) {
        var mh$ = strsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsen_", job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsen_$descriptor() {
        return ztrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsen_$handle() {
        return ztrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsen_$address() {
        return ztrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment W, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = ztrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsen_", job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsna_$descriptor() {
        return ctrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsna_$handle() {
        return ctrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsna_$address() {
        return ctrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment rwork, MemorySegment info, long x18, long x19) {
        var mh$ = ctrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsna_$descriptor() {
        return dtrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsna_$handle() {
        return dtrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsna_$address() {
        return dtrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = dtrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsna_$descriptor() {
        return strsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsna_$handle() {
        return strsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsna_$address() {
        return strsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void strsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = strsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsna_$descriptor() {
        return ztrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsna_$handle() {
        return ztrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsna_$address() {
        return ztrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment rwork, MemorySegment info, long x18, long x19) {
        var mh$ = ztrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsyl_$descriptor() {
        return ctrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsyl_$handle() {
        return ctrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsyl_$address() {
        return ctrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static void ctrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = ctrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsyl_$descriptor() {
        return dtrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsyl_$handle() {
        return dtrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsyl_$address() {
        return dtrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static void dtrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = dtrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsyl_$descriptor() {
        return strsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsyl_$handle() {
        return strsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsyl_$address() {
        return strsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static void strsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = strsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsyl_$descriptor() {
        return ztrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsyl_$handle() {
        return ztrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsyl_$address() {
        return ztrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static void ztrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = ztrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrtri_$descriptor() {
        return ctrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrtri_$handle() {
        return ctrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrtri_$address() {
        return ctrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ctrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = ctrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrtri_$descriptor() {
        return dtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrtri_$handle() {
        return dtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrtri_$address() {
        return dtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void dtrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = dtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strtri_$descriptor() {
        return strtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strtri_$handle() {
        return strtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strtri_$address() {
        return strtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void strtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = strtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrtri_$descriptor() {
        return ztrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrtri_$handle() {
        return ztrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrtri_$address() {
        return ztrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ztrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = ztrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrtrs_$descriptor() {
        return ctrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrtrs_$handle() {
        return ctrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrtrs_$address() {
        return ctrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ctrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrtrs_$descriptor() {
        return dtrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrtrs_$handle() {
        return dtrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrtrs_$address() {
        return dtrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = dtrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strtrs_$descriptor() {
        return strtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strtrs_$handle() {
        return strtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strtrs_$address() {
        return strtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = strtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrtrs_$descriptor() {
        return ztrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrtrs_$handle() {
        return ztrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrtrs_$address() {
        return ztrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ztrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrttf_$descriptor() {
        return ctrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrttf_$handle() {
        return ctrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrttf_$address() {
        return ctrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ctrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = ctrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrttf_$descriptor() {
        return dtrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrttf_$handle() {
        return dtrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrttf_$address() {
        return dtrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void dtrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = dtrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strttf_$descriptor() {
        return strttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strttf_$handle() {
        return strttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strttf_$address() {
        return strttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void strttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = strttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrttf_$descriptor() {
        return ztrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrttf_$handle() {
        return ztrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrttf_$address() {
        return ztrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ztrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = ztrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctrttp_$descriptor() {
        return ctrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle ctrttp_$handle() {
        return ctrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment ctrttp_$address() {
        return ctrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void ctrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = ctrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtrttp_$descriptor() {
        return dtrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dtrttp_$handle() {
        return dtrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dtrttp_$address() {
        return dtrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static void dtrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = dtrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor strttp_$descriptor() {
        return strttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle strttp_$handle() {
        return strttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment strttp_$address() {
        return strttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static void strttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = strttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztrttp_$descriptor() {
        return ztrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle ztrttp_$handle() {
        return ztrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment ztrttp_$address() {
        return ztrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void ztrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = ztrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor ctzrzf_$descriptor() {
        return ctzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle ctzrzf_$handle() {
        return ctzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment ctzrzf_$address() {
        return ctzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void ctzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = ctzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dtzrzf_$descriptor() {
        return dtzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dtzrzf_$handle() {
        return dtzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dtzrzf_$address() {
        return dtzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dtzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dtzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor stzrzf_$descriptor() {
        return stzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle stzrzf_$handle() {
        return stzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment stzrzf_$address() {
        return stzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void stzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = stzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor ztzrzf_$descriptor() {
        return ztzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle ztzrzf_$handle() {
        return ztzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment ztzrzf_$address() {
        return ztzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void ztzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = ztzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunbdb_$descriptor() {
        return cunbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunbdb_$handle() {
        return cunbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunbdb_$address() {
        return cunbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = cunbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunbdb_$descriptor() {
        return zunbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunbdb_$handle() {
        return zunbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunbdb_$address() {
        return zunbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = zunbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cuncsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cuncsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cuncsd_$descriptor() {
        return cuncsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cuncsd_$handle() {
        return cuncsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cuncsd_$address() {
        return cuncsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cuncsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x32, long x33, long x34, long x35, long x36, long x37) {
        var mh$ = cuncsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cuncsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zuncsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zuncsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zuncsd_$descriptor() {
        return zuncsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zuncsd_$handle() {
        return zuncsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zuncsd_$address() {
        return zuncsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zuncsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x32, long x33, long x34, long x35, long x36, long x37) {
        var mh$ = zuncsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zuncsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cuncsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cuncsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cuncsd2by1_$descriptor() {
        return cuncsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cuncsd2by1_$handle() {
        return cuncsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cuncsd2by1_$address() {
        return cuncsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cuncsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cuncsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cuncsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zuncsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zuncsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zuncsd2by1_$descriptor() {
        return zuncsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zuncsd2by1_$handle() {
        return zuncsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zuncsd2by1_$address() {
        return zuncsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zuncsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zuncsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zuncsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cungbr_$descriptor() {
        return cungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cungbr_$handle() {
        return cungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cungbr_$address() {
        return cungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cungbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = cungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zungbr_$descriptor() {
        return zungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zungbr_$handle() {
        return zungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zungbr_$address() {
        return zungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zungbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = zungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cunghr_$descriptor() {
        return cunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cunghr_$handle() {
        return cunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cunghr_$address() {
        return cunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cunghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zunghr_$descriptor() {
        return zunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zunghr_$handle() {
        return zunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zunghr_$address() {
        return zunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zunghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cunglq_$descriptor() {
        return cunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cunglq_$handle() {
        return cunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cunglq_$address() {
        return cunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cunglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zunglq_$descriptor() {
        return zunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zunglq_$handle() {
        return zunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zunglq_$address() {
        return zunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zunglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungql_$descriptor() {
        return cungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungql_$handle() {
        return cungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungql_$address() {
        return cungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungql_$descriptor() {
        return zungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungql_$handle() {
        return zungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungql_$address() {
        return zungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungqr_$descriptor() {
        return cungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungqr_$handle() {
        return cungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungqr_$address() {
        return cungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungqr_$descriptor() {
        return zungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungqr_$handle() {
        return zungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungqr_$address() {
        return zungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungrq_$descriptor() {
        return cungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungrq_$handle() {
        return cungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungrq_$address() {
        return cungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungrq_$descriptor() {
        return zungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungrq_$handle() {
        return zungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungrq_$address() {
        return zungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cungtr_$descriptor() {
        return cungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cungtr_$handle() {
        return cungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cungtr_$address() {
        return cungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cungtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = cungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zungtr_$descriptor() {
        return zungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zungtr_$handle() {
        return zungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zungtr_$address() {
        return zungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zungtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cungtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungtsqr_row_$descriptor() {
        return cungtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungtsqr_row_$handle() {
        return cungtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungtsqr_row_$address() {
        return cungtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zungtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungtsqr_row_$descriptor() {
        return zungtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungtsqr_row_$handle() {
        return zungtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungtsqr_row_$address() {
        return zungtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmbr_$descriptor() {
        return cunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cunmbr_$handle() {
        return cunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cunmbr_$address() {
        return cunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cunmbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = cunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmbr_$descriptor() {
        return zunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zunmbr_$handle() {
        return zunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zunmbr_$address() {
        return zunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zunmbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = zunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmhr_$descriptor() {
        return cunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmhr_$handle() {
        return cunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmhr_$address() {
        return cunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmhr_$descriptor() {
        return zunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmhr_$handle() {
        return zunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmhr_$address() {
        return zunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmlq_$descriptor() {
        return cunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmlq_$handle() {
        return cunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmlq_$address() {
        return cunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmlq_$descriptor() {
        return zunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmlq_$handle() {
        return zunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmlq_$address() {
        return zunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmql_$descriptor() {
        return cunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmql_$handle() {
        return cunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmql_$address() {
        return cunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmql_$descriptor() {
        return zunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmql_$handle() {
        return zunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmql_$address() {
        return zunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmqr_$descriptor() {
        return cunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmqr_$handle() {
        return cunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmqr_$address() {
        return cunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmqr_$descriptor() {
        return zunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmqr_$handle() {
        return zunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmqr_$address() {
        return zunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmrq_$descriptor() {
        return cunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmrq_$handle() {
        return cunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmrq_$address() {
        return cunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmrq_$descriptor() {
        return zunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmrq_$handle() {
        return zunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmrq_$address() {
        return zunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmrz_$descriptor() {
        return cunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmrz_$handle() {
        return cunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmrz_$address() {
        return cunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmrz_$descriptor() {
        return zunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmrz_$handle() {
        return zunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmrz_$address() {
        return zunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmtr_$descriptor() {
        return cunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cunmtr_$handle() {
        return cunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cunmtr_$address() {
        return cunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cunmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = cunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmtr_$descriptor() {
        return zunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zunmtr_$handle() {
        return zunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zunmtr_$address() {
        return zunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zunmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = zunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cupgtr_$descriptor() {
        return cupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cupgtr_$handle() {
        return cupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cupgtr_$address() {
        return cupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cupgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zupgtr_$descriptor() {
        return zupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zupgtr_$handle() {
        return zupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zupgtr_$address() {
        return zupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zupgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cupmtr_$descriptor() {
        return cupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cupmtr_$handle() {
        return cupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cupmtr_$address() {
        return cupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cupmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = cupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zupmtr_$descriptor() {
        return zupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zupmtr_$handle() {
        return zupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zupmtr_$address() {
        return zupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zupmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = zupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lapack_make_complex_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lapack_make_complex_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static FunctionDescriptor lapack_make_complex_float$descriptor() {
        return lapack_make_complex_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static MethodHandle lapack_make_complex_float$handle() {
        return lapack_make_complex_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static MemorySegment lapack_make_complex_float$address() {
        return lapack_make_complex_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static float lapack_make_complex_float(float re, float im) {
        var mh$ = lapack_make_complex_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lapack_make_complex_float", re, im);
            }
            return (float)mh$.invokeExact(re, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lapack_make_complex_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("lapack_make_complex_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static FunctionDescriptor lapack_make_complex_double$descriptor() {
        return lapack_make_complex_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static MethodHandle lapack_make_complex_double$handle() {
        return lapack_make_complex_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static MemorySegment lapack_make_complex_double$address() {
        return lapack_make_complex_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static double lapack_make_complex_double(double re, double im) {
        var mh$ = lapack_make_complex_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lapack_make_complex_double", re, im);
            }
            return (double)mh$.invokeExact(re, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsdc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsdc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsdc$descriptor() {
        return LAPACKE_sbdsdc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static MethodHandle LAPACKE_sbdsdc$handle() {
        return LAPACKE_sbdsdc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static MemorySegment LAPACKE_sbdsdc$address() {
        return LAPACKE_sbdsdc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static int LAPACKE_sbdsdc(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq) {
        var mh$ = LAPACKE_sbdsdc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsdc", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsdc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsdc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsdc$descriptor() {
        return LAPACKE_dbdsdc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static MethodHandle LAPACKE_dbdsdc$handle() {
        return LAPACKE_dbdsdc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static MemorySegment LAPACKE_dbdsdc$address() {
        return LAPACKE_dbdsdc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static int LAPACKE_dbdsdc(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq) {
        var mh$ = LAPACKE_dbdsdc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsdc", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsqr$descriptor() {
        return LAPACKE_sbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sbdsqr$handle() {
        return LAPACKE_sbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sbdsqr$address() {
        return LAPACKE_sbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsqr$descriptor() {
        return LAPACKE_dbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dbdsqr$handle() {
        return LAPACKE_dbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dbdsqr$address() {
        return LAPACKE_dbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbdsqr$descriptor() {
        return LAPACKE_cbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cbdsqr$handle() {
        return LAPACKE_cbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cbdsqr$address() {
        return LAPACKE_cbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbdsqr$descriptor() {
        return LAPACKE_zbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zbdsqr$handle() {
        return LAPACKE_zbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zbdsqr$address() {
        return LAPACKE_zbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsvdx$descriptor() {
        return LAPACKE_sbdsvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_sbdsvdx$handle() {
        return LAPACKE_sbdsvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_sbdsvdx$address() {
        return LAPACKE_sbdsvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static int LAPACKE_sbdsvdx(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment superb) {
        var mh$ = LAPACKE_sbdsvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsvdx", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsvdx$descriptor() {
        return LAPACKE_dbdsvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_dbdsvdx$handle() {
        return LAPACKE_dbdsvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_dbdsvdx$address() {
        return LAPACKE_dbdsvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static int LAPACKE_dbdsvdx(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment superb) {
        var mh$ = LAPACKE_dbdsvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsvdx", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sdisna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sdisna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_sdisna$descriptor() {
        return LAPACKE_sdisna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_sdisna$handle() {
        return LAPACKE_sdisna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_sdisna$address() {
        return LAPACKE_sdisna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static int LAPACKE_sdisna(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_sdisna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sdisna", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ddisna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ddisna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ddisna$descriptor() {
        return LAPACKE_ddisna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ddisna$handle() {
        return LAPACKE_ddisna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ddisna$address() {
        return LAPACKE_ddisna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static int LAPACKE_ddisna(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_ddisna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ddisna", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbbrd$descriptor() {
        return LAPACKE_sgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgbbrd$handle() {
        return LAPACKE_sgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgbbrd$address() {
        return LAPACKE_sgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbbrd$descriptor() {
        return LAPACKE_dgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgbbrd$handle() {
        return LAPACKE_dgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgbbrd$address() {
        return LAPACKE_dgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbbrd$descriptor() {
        return LAPACKE_cgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgbbrd$handle() {
        return LAPACKE_cgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgbbrd$address() {
        return LAPACKE_cgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbbrd$descriptor() {
        return LAPACKE_zgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgbbrd$handle() {
        return LAPACKE_zgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgbbrd$address() {
        return LAPACKE_zgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbcon$descriptor() {
        return LAPACKE_sgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgbcon$handle() {
        return LAPACKE_sgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgbcon$address() {
        return LAPACKE_sgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbcon$descriptor() {
        return LAPACKE_dgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgbcon$handle() {
        return LAPACKE_dgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgbcon$address() {
        return LAPACKE_dgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbcon$descriptor() {
        return LAPACKE_cgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgbcon$handle() {
        return LAPACKE_cgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgbcon$address() {
        return LAPACKE_cgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbcon$descriptor() {
        return LAPACKE_zgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgbcon$handle() {
        return LAPACKE_zgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgbcon$address() {
        return LAPACKE_zgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequ$descriptor() {
        return LAPACKE_sgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequ$handle() {
        return LAPACKE_sgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequ$address() {
        return LAPACKE_sgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequ$descriptor() {
        return LAPACKE_dgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequ$handle() {
        return LAPACKE_dgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequ$address() {
        return LAPACKE_dgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequ$descriptor() {
        return LAPACKE_cgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequ$handle() {
        return LAPACKE_cgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequ$address() {
        return LAPACKE_cgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequ$descriptor() {
        return LAPACKE_zgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequ$handle() {
        return LAPACKE_zgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequ$address() {
        return LAPACKE_zgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequb$descriptor() {
        return LAPACKE_sgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequb$handle() {
        return LAPACKE_sgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequb$address() {
        return LAPACKE_sgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequb$descriptor() {
        return LAPACKE_dgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequb$handle() {
        return LAPACKE_dgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequb$address() {
        return LAPACKE_dgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequb$descriptor() {
        return LAPACKE_cgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequb$handle() {
        return LAPACKE_cgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequb$address() {
        return LAPACKE_cgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequb$descriptor() {
        return LAPACKE_zgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequb$handle() {
        return LAPACKE_zgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequb$address() {
        return LAPACKE_zgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfs$descriptor() {
        return LAPACKE_sgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfs$handle() {
        return LAPACKE_sgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfs$address() {
        return LAPACKE_sgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfs$descriptor() {
        return LAPACKE_dgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfs$handle() {
        return LAPACKE_dgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfs$address() {
        return LAPACKE_dgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfs$descriptor() {
        return LAPACKE_cgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfs$handle() {
        return LAPACKE_cgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfs$address() {
        return LAPACKE_cgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfs$descriptor() {
        return LAPACKE_zgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfs$handle() {
        return LAPACKE_zgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfs$address() {
        return LAPACKE_zgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfsx$descriptor() {
        return LAPACKE_sgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfsx$handle() {
        return LAPACKE_sgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfsx$address() {
        return LAPACKE_sgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfsx$descriptor() {
        return LAPACKE_dgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfsx$handle() {
        return LAPACKE_dgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfsx$address() {
        return LAPACKE_dgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfsx$descriptor() {
        return LAPACKE_cgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfsx$handle() {
        return LAPACKE_cgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfsx$address() {
        return LAPACKE_cgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfsx$descriptor() {
        return LAPACKE_zgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfsx$handle() {
        return LAPACKE_zgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfsx$address() {
        return LAPACKE_zgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsv$descriptor() {
        return LAPACKE_sgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbsv$handle() {
        return LAPACKE_sgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbsv$address() {
        return LAPACKE_sgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsv$descriptor() {
        return LAPACKE_dgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbsv$handle() {
        return LAPACKE_dgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbsv$address() {
        return LAPACKE_dgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsv$descriptor() {
        return LAPACKE_cgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbsv$handle() {
        return LAPACKE_cgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbsv$address() {
        return LAPACKE_cgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsv$descriptor() {
        return LAPACKE_zgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbsv$handle() {
        return LAPACKE_zgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbsv$address() {
        return LAPACKE_zgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvx$descriptor() {
        return LAPACKE_sgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvx$handle() {
        return LAPACKE_sgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvx$address() {
        return LAPACKE_sgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_sgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_sgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvx$descriptor() {
        return LAPACKE_dgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvx$handle() {
        return LAPACKE_dgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvx$address() {
        return LAPACKE_dgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_dgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_dgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvx$descriptor() {
        return LAPACKE_cgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvx$handle() {
        return LAPACKE_cgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvx$address() {
        return LAPACKE_cgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_cgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_cgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvx$descriptor() {
        return LAPACKE_zgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvx$handle() {
        return LAPACKE_zgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvx$address() {
        return LAPACKE_zgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_zgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_zgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvxx$descriptor() {
        return LAPACKE_sgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvxx$handle() {
        return LAPACKE_sgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvxx$address() {
        return LAPACKE_sgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvxx$descriptor() {
        return LAPACKE_dgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvxx$handle() {
        return LAPACKE_dgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvxx$address() {
        return LAPACKE_dgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvxx$descriptor() {
        return LAPACKE_cgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvxx$handle() {
        return LAPACKE_cgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvxx$address() {
        return LAPACKE_cgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvxx$descriptor() {
        return LAPACKE_zgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvxx$handle() {
        return LAPACKE_zgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvxx$address() {
        return LAPACKE_zgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrf$descriptor() {
        return LAPACKE_sgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrf$handle() {
        return LAPACKE_sgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrf$address() {
        return LAPACKE_sgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrf$descriptor() {
        return LAPACKE_dgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrf$handle() {
        return LAPACKE_dgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrf$address() {
        return LAPACKE_dgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrf$descriptor() {
        return LAPACKE_cgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrf$handle() {
        return LAPACKE_cgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrf$address() {
        return LAPACKE_cgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrf$descriptor() {
        return LAPACKE_zgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrf$handle() {
        return LAPACKE_zgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrf$address() {
        return LAPACKE_zgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrs$descriptor() {
        return LAPACKE_sgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrs$handle() {
        return LAPACKE_sgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrs$address() {
        return LAPACKE_sgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrs$descriptor() {
        return LAPACKE_dgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrs$handle() {
        return LAPACKE_dgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrs$address() {
        return LAPACKE_dgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrs$descriptor() {
        return LAPACKE_cgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrs$handle() {
        return LAPACKE_cgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrs$address() {
        return LAPACKE_cgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrs$descriptor() {
        return LAPACKE_zgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrs$handle() {
        return LAPACKE_zgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrs$address() {
        return LAPACKE_zgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebak$descriptor() {
        return LAPACKE_sgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sgebak$handle() {
        return LAPACKE_sgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sgebak$address() {
        return LAPACKE_sgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebak$descriptor() {
        return LAPACKE_dgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dgebak$handle() {
        return LAPACKE_dgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dgebak$address() {
        return LAPACKE_dgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebak$descriptor() {
        return LAPACKE_cgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cgebak$handle() {
        return LAPACKE_cgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cgebak$address() {
        return LAPACKE_cgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebak$descriptor() {
        return LAPACKE_zgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zgebak$handle() {
        return LAPACKE_zgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zgebak$address() {
        return LAPACKE_zgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebal$descriptor() {
        return LAPACKE_sgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_sgebal$handle() {
        return LAPACKE_sgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_sgebal$address() {
        return LAPACKE_sgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_sgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_sgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebal$descriptor() {
        return LAPACKE_dgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dgebal$handle() {
        return LAPACKE_dgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dgebal$address() {
        return LAPACKE_dgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_dgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_dgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebal$descriptor() {
        return LAPACKE_cgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_cgebal$handle() {
        return LAPACKE_cgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_cgebal$address() {
        return LAPACKE_cgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_cgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_cgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebal$descriptor() {
        return LAPACKE_zgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_zgebal$handle() {
        return LAPACKE_zgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_zgebal$address() {
        return LAPACKE_zgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_zgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_zgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebrd$descriptor() {
        return LAPACKE_sgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static MethodHandle LAPACKE_sgebrd$handle() {
        return LAPACKE_sgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static MemorySegment LAPACKE_sgebrd$address() {
        return LAPACKE_sgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static int LAPACKE_sgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_sgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebrd$descriptor() {
        return LAPACKE_dgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static MethodHandle LAPACKE_dgebrd$handle() {
        return LAPACKE_dgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static MemorySegment LAPACKE_dgebrd$address() {
        return LAPACKE_dgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static int LAPACKE_dgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_dgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebrd$descriptor() {
        return LAPACKE_cgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static MethodHandle LAPACKE_cgebrd$handle() {
        return LAPACKE_cgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static MemorySegment LAPACKE_cgebrd$address() {
        return LAPACKE_cgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static int LAPACKE_cgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_cgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebrd$descriptor() {
        return LAPACKE_zgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static MethodHandle LAPACKE_zgebrd$handle() {
        return LAPACKE_zgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static MemorySegment LAPACKE_zgebrd$address() {
        return LAPACKE_zgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static int LAPACKE_zgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_zgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgecon$descriptor() {
        return LAPACKE_sgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgecon$handle() {
        return LAPACKE_sgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgecon$address() {
        return LAPACKE_sgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgecon$descriptor() {
        return LAPACKE_dgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgecon$handle() {
        return LAPACKE_dgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgecon$address() {
        return LAPACKE_dgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgecon$descriptor() {
        return LAPACKE_cgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgecon$handle() {
        return LAPACKE_cgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgecon$address() {
        return LAPACKE_cgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgecon$descriptor() {
        return LAPACKE_zgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgecon$handle() {
        return LAPACKE_zgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgecon$address() {
        return LAPACKE_zgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequ$descriptor() {
        return LAPACKE_sgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequ$handle() {
        return LAPACKE_sgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequ$address() {
        return LAPACKE_sgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequ$descriptor() {
        return LAPACKE_dgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequ$handle() {
        return LAPACKE_dgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequ$address() {
        return LAPACKE_dgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequ$descriptor() {
        return LAPACKE_cgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequ$handle() {
        return LAPACKE_cgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequ$address() {
        return LAPACKE_cgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequ$descriptor() {
        return LAPACKE_zgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequ$handle() {
        return LAPACKE_zgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequ$address() {
        return LAPACKE_zgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequb$descriptor() {
        return LAPACKE_sgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequb$handle() {
        return LAPACKE_sgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequb$address() {
        return LAPACKE_sgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequb$descriptor() {
        return LAPACKE_dgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequb$handle() {
        return LAPACKE_dgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequb$address() {
        return LAPACKE_dgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequb$descriptor() {
        return LAPACKE_cgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequb$handle() {
        return LAPACKE_cgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequb$address() {
        return LAPACKE_cgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequb$descriptor() {
        return LAPACKE_zgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequb$handle() {
        return LAPACKE_zgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequb$address() {
        return LAPACKE_zgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgees$descriptor() {
        return LAPACKE_sgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_sgees$handle() {
        return LAPACKE_sgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_sgees$address() {
        return LAPACKE_sgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static int LAPACKE_sgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_sgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgees$descriptor() {
        return LAPACKE_dgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_dgees$handle() {
        return LAPACKE_dgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_dgees$address() {
        return LAPACKE_dgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static int LAPACKE_dgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_dgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgees$descriptor() {
        return LAPACKE_cgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_cgees$handle() {
        return LAPACKE_cgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_cgees$address() {
        return LAPACKE_cgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static int LAPACKE_cgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_cgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgees$descriptor() {
        return LAPACKE_zgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_zgees$handle() {
        return LAPACKE_zgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_zgees$address() {
        return LAPACKE_zgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static int LAPACKE_zgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_zgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeesx$descriptor() {
        return LAPACKE_sgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sgeesx$handle() {
        return LAPACKE_sgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sgeesx$address() {
        return LAPACKE_sgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeesx$descriptor() {
        return LAPACKE_dgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dgeesx$handle() {
        return LAPACKE_dgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dgeesx$address() {
        return LAPACKE_dgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeesx$descriptor() {
        return LAPACKE_cgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cgeesx$handle() {
        return LAPACKE_cgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cgeesx$address() {
        return LAPACKE_cgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeesx$descriptor() {
        return LAPACKE_zgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zgeesx$handle() {
        return LAPACKE_zgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zgeesx$address() {
        return LAPACKE_zgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeev$descriptor() {
        return LAPACKE_sgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sgeev$handle() {
        return LAPACKE_sgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sgeev$address() {
        return LAPACKE_sgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeev", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeev$descriptor() {
        return LAPACKE_dgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dgeev$handle() {
        return LAPACKE_dgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dgeev$address() {
        return LAPACKE_dgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeev", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeev$descriptor() {
        return LAPACKE_cgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cgeev$handle() {
        return LAPACKE_cgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cgeev$address() {
        return LAPACKE_cgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeev", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeev$descriptor() {
        return LAPACKE_zgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zgeev$handle() {
        return LAPACKE_zgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zgeev$address() {
        return LAPACKE_zgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeev", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeevx$descriptor() {
        return LAPACKE_sgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sgeevx$handle() {
        return LAPACKE_sgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sgeevx$address() {
        return LAPACKE_sgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeevx$descriptor() {
        return LAPACKE_dgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dgeevx$handle() {
        return LAPACKE_dgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dgeevx$address() {
        return LAPACKE_dgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeevx$descriptor() {
        return LAPACKE_cgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cgeevx$handle() {
        return LAPACKE_cgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cgeevx$address() {
        return LAPACKE_cgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeevx$descriptor() {
        return LAPACKE_zgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zgeevx$handle() {
        return LAPACKE_zgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zgeevx$address() {
        return LAPACKE_zgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgehrd$descriptor() {
        return LAPACKE_sgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgehrd$handle() {
        return LAPACKE_sgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgehrd$address() {
        return LAPACKE_sgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgehrd$descriptor() {
        return LAPACKE_dgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgehrd$handle() {
        return LAPACKE_dgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgehrd$address() {
        return LAPACKE_dgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgehrd$descriptor() {
        return LAPACKE_cgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgehrd$handle() {
        return LAPACKE_cgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgehrd$address() {
        return LAPACKE_cgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgehrd$descriptor() {
        return LAPACKE_zgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgehrd$handle() {
        return LAPACKE_zgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgehrd$address() {
        return LAPACKE_zgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgejsv$descriptor() {
        return LAPACKE_sgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_sgejsv$handle() {
        return LAPACKE_sgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_sgejsv$address() {
        return LAPACKE_sgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static int LAPACKE_sgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_sgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgejsv$descriptor() {
        return LAPACKE_dgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_dgejsv$handle() {
        return LAPACKE_dgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_dgejsv$address() {
        return LAPACKE_dgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static int LAPACKE_dgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_dgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgejsv$descriptor() {
        return LAPACKE_cgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_cgejsv$handle() {
        return LAPACKE_cgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_cgejsv$address() {
        return LAPACKE_cgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static int LAPACKE_cgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_cgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgejsv$descriptor() {
        return LAPACKE_zgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_zgejsv$handle() {
        return LAPACKE_zgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_zgejsv$address() {
        return LAPACKE_zgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static int LAPACKE_zgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_zgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq2$descriptor() {
        return LAPACKE_sgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgelq2$handle() {
        return LAPACKE_sgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgelq2$address() {
        return LAPACKE_sgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq2$descriptor() {
        return LAPACKE_dgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgelq2$handle() {
        return LAPACKE_dgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgelq2$address() {
        return LAPACKE_dgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq2$descriptor() {
        return LAPACKE_cgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgelq2$handle() {
        return LAPACKE_cgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgelq2$address() {
        return LAPACKE_cgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq2$descriptor() {
        return LAPACKE_zgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgelq2$handle() {
        return LAPACKE_zgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgelq2$address() {
        return LAPACKE_zgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelqf$descriptor() {
        return LAPACKE_sgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgelqf$handle() {
        return LAPACKE_sgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgelqf$address() {
        return LAPACKE_sgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelqf$descriptor() {
        return LAPACKE_dgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgelqf$handle() {
        return LAPACKE_dgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgelqf$address() {
        return LAPACKE_dgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelqf$descriptor() {
        return LAPACKE_cgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgelqf$handle() {
        return LAPACKE_cgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgelqf$address() {
        return LAPACKE_cgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelqf$descriptor() {
        return LAPACKE_zgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgelqf$handle() {
        return LAPACKE_zgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgelqf$address() {
        return LAPACKE_zgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgels$descriptor() {
        return LAPACKE_sgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgels$handle() {
        return LAPACKE_sgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgels$address() {
        return LAPACKE_sgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgels$descriptor() {
        return LAPACKE_dgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgels$handle() {
        return LAPACKE_dgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgels$address() {
        return LAPACKE_dgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgels$descriptor() {
        return LAPACKE_cgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgels$handle() {
        return LAPACKE_cgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgels$address() {
        return LAPACKE_cgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgels$descriptor() {
        return LAPACKE_zgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgels$handle() {
        return LAPACKE_zgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgels$address() {
        return LAPACKE_zgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsd$descriptor() {
        return LAPACKE_sgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelsd$handle() {
        return LAPACKE_sgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelsd$address() {
        return LAPACKE_sgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsd$descriptor() {
        return LAPACKE_dgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelsd$handle() {
        return LAPACKE_dgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelsd$address() {
        return LAPACKE_dgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsd$descriptor() {
        return LAPACKE_cgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelsd$handle() {
        return LAPACKE_cgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelsd$address() {
        return LAPACKE_cgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsd$descriptor() {
        return LAPACKE_zgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelsd$handle() {
        return LAPACKE_zgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelsd$address() {
        return LAPACKE_zgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelss$descriptor() {
        return LAPACKE_sgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelss$handle() {
        return LAPACKE_sgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelss$address() {
        return LAPACKE_sgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelss$descriptor() {
        return LAPACKE_dgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelss$handle() {
        return LAPACKE_dgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelss$address() {
        return LAPACKE_dgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelss$descriptor() {
        return LAPACKE_cgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelss$handle() {
        return LAPACKE_cgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelss$address() {
        return LAPACKE_cgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelss$descriptor() {
        return LAPACKE_zgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelss$handle() {
        return LAPACKE_zgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelss$address() {
        return LAPACKE_zgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsy$descriptor() {
        return LAPACKE_sgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelsy$handle() {
        return LAPACKE_sgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelsy$address() {
        return LAPACKE_sgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsy$descriptor() {
        return LAPACKE_dgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelsy$handle() {
        return LAPACKE_dgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelsy$address() {
        return LAPACKE_dgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsy$descriptor() {
        return LAPACKE_cgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelsy$handle() {
        return LAPACKE_cgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelsy$address() {
        return LAPACKE_cgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsy$descriptor() {
        return LAPACKE_zgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelsy$handle() {
        return LAPACKE_zgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelsy$address() {
        return LAPACKE_zgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqlf$descriptor() {
        return LAPACKE_sgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqlf$handle() {
        return LAPACKE_sgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqlf$address() {
        return LAPACKE_sgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqlf$descriptor() {
        return LAPACKE_dgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqlf$handle() {
        return LAPACKE_dgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqlf$address() {
        return LAPACKE_dgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqlf$descriptor() {
        return LAPACKE_cgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqlf$handle() {
        return LAPACKE_cgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqlf$address() {
        return LAPACKE_cgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqlf$descriptor() {
        return LAPACKE_zgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqlf$handle() {
        return LAPACKE_zgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqlf$address() {
        return LAPACKE_zgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqp3$descriptor() {
        return LAPACKE_sgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqp3$handle() {
        return LAPACKE_sgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqp3$address() {
        return LAPACKE_sgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static int LAPACKE_sgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqp3$descriptor() {
        return LAPACKE_dgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqp3$handle() {
        return LAPACKE_dgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqp3$address() {
        return LAPACKE_dgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static int LAPACKE_dgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqp3$descriptor() {
        return LAPACKE_cgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqp3$handle() {
        return LAPACKE_cgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqp3$address() {
        return LAPACKE_cgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqp3$descriptor() {
        return LAPACKE_zgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqp3$handle() {
        return LAPACKE_zgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqp3$address() {
        return LAPACKE_zgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqpf$descriptor() {
        return LAPACKE_sgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqpf$handle() {
        return LAPACKE_sgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqpf$address() {
        return LAPACKE_sgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static int LAPACKE_sgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqpf$descriptor() {
        return LAPACKE_dgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqpf$handle() {
        return LAPACKE_dgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqpf$address() {
        return LAPACKE_dgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static int LAPACKE_dgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqpf$descriptor() {
        return LAPACKE_cgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqpf$handle() {
        return LAPACKE_cgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqpf$address() {
        return LAPACKE_cgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqpf$descriptor() {
        return LAPACKE_zgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqpf$handle() {
        return LAPACKE_zgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqpf$address() {
        return LAPACKE_zgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr2$descriptor() {
        return LAPACKE_sgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr2$handle() {
        return LAPACKE_sgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr2$address() {
        return LAPACKE_sgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr2$descriptor() {
        return LAPACKE_dgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr2$handle() {
        return LAPACKE_dgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr2$address() {
        return LAPACKE_dgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr2$descriptor() {
        return LAPACKE_cgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr2$handle() {
        return LAPACKE_cgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr2$address() {
        return LAPACKE_cgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr2$descriptor() {
        return LAPACKE_zgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr2$handle() {
        return LAPACKE_zgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr2$address() {
        return LAPACKE_zgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrf$descriptor() {
        return LAPACKE_sgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrf$handle() {
        return LAPACKE_sgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrf$address() {
        return LAPACKE_sgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrf$descriptor() {
        return LAPACKE_dgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrf$handle() {
        return LAPACKE_dgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrf$address() {
        return LAPACKE_dgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrf$descriptor() {
        return LAPACKE_cgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrf$handle() {
        return LAPACKE_cgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrf$address() {
        return LAPACKE_cgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrf$descriptor() {
        return LAPACKE_zgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrf$handle() {
        return LAPACKE_zgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrf$address() {
        return LAPACKE_zgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrfp$descriptor() {
        return LAPACKE_sgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrfp$handle() {
        return LAPACKE_sgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrfp$address() {
        return LAPACKE_sgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrfp$descriptor() {
        return LAPACKE_dgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrfp$handle() {
        return LAPACKE_dgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrfp$address() {
        return LAPACKE_dgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrfp$descriptor() {
        return LAPACKE_cgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrfp$handle() {
        return LAPACKE_cgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrfp$address() {
        return LAPACKE_cgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrfp$descriptor() {
        return LAPACKE_zgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrfp$handle() {
        return LAPACKE_zgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrfp$address() {
        return LAPACKE_zgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfs$descriptor() {
        return LAPACKE_sgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgerfs$handle() {
        return LAPACKE_sgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgerfs$address() {
        return LAPACKE_sgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfs$descriptor() {
        return LAPACKE_dgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgerfs$handle() {
        return LAPACKE_dgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgerfs$address() {
        return LAPACKE_dgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfs$descriptor() {
        return LAPACKE_cgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgerfs$handle() {
        return LAPACKE_cgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgerfs$address() {
        return LAPACKE_cgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfs$descriptor() {
        return LAPACKE_zgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgerfs$handle() {
        return LAPACKE_zgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgerfs$address() {
        return LAPACKE_zgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfsx$descriptor() {
        return LAPACKE_sgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgerfsx$handle() {
        return LAPACKE_sgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgerfsx$address() {
        return LAPACKE_sgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfsx$descriptor() {
        return LAPACKE_dgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgerfsx$handle() {
        return LAPACKE_dgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgerfsx$address() {
        return LAPACKE_dgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfsx$descriptor() {
        return LAPACKE_cgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgerfsx$handle() {
        return LAPACKE_cgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgerfsx$address() {
        return LAPACKE_cgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfsx$descriptor() {
        return LAPACKE_zgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgerfsx$handle() {
        return LAPACKE_zgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgerfsx$address() {
        return LAPACKE_zgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerqf$descriptor() {
        return LAPACKE_sgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgerqf$handle() {
        return LAPACKE_sgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgerqf$address() {
        return LAPACKE_sgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerqf$descriptor() {
        return LAPACKE_dgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgerqf$handle() {
        return LAPACKE_dgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgerqf$address() {
        return LAPACKE_dgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerqf$descriptor() {
        return LAPACKE_cgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgerqf$handle() {
        return LAPACKE_cgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgerqf$address() {
        return LAPACKE_cgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerqf$descriptor() {
        return LAPACKE_zgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgerqf$handle() {
        return LAPACKE_zgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgerqf$address() {
        return LAPACKE_zgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesdd$descriptor() {
        return LAPACKE_sgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_sgesdd$handle() {
        return LAPACKE_sgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_sgesdd$address() {
        return LAPACKE_sgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static int LAPACKE_sgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_sgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesdd$descriptor() {
        return LAPACKE_dgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_dgesdd$handle() {
        return LAPACKE_dgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_dgesdd$address() {
        return LAPACKE_dgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static int LAPACKE_dgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_dgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesdd$descriptor() {
        return LAPACKE_cgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_cgesdd$handle() {
        return LAPACKE_cgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_cgesdd$address() {
        return LAPACKE_cgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static int LAPACKE_cgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_cgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesdd$descriptor() {
        return LAPACKE_zgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_zgesdd$handle() {
        return LAPACKE_zgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_zgesdd$address() {
        return LAPACKE_zgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static int LAPACKE_zgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_zgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesv$descriptor() {
        return LAPACKE_sgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgesv$handle() {
        return LAPACKE_sgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgesv$address() {
        return LAPACKE_sgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesv$descriptor() {
        return LAPACKE_dgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgesv$handle() {
        return LAPACKE_dgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgesv$address() {
        return LAPACKE_dgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesv$descriptor() {
        return LAPACKE_cgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgesv$handle() {
        return LAPACKE_cgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgesv$address() {
        return LAPACKE_cgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesv$descriptor() {
        return LAPACKE_zgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgesv$handle() {
        return LAPACKE_zgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgesv$address() {
        return LAPACKE_zgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsgesv$descriptor() {
        return LAPACKE_dsgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsgesv$handle() {
        return LAPACKE_dsgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsgesv$address() {
        return LAPACKE_dsgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_dsgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zcgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcgesv$descriptor() {
        return LAPACKE_zcgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcgesv$handle() {
        return LAPACKE_zcgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcgesv$address() {
        return LAPACKE_zcgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_zcgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvd$descriptor() {
        return LAPACKE_sgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static MethodHandle LAPACKE_sgesvd$handle() {
        return LAPACKE_sgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static MemorySegment LAPACKE_sgesvd$address() {
        return LAPACKE_sgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static int LAPACKE_sgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_sgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvd$descriptor() {
        return LAPACKE_dgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static MethodHandle LAPACKE_dgesvd$handle() {
        return LAPACKE_dgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static MemorySegment LAPACKE_dgesvd$address() {
        return LAPACKE_dgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static int LAPACKE_dgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_dgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvd$descriptor() {
        return LAPACKE_cgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static MethodHandle LAPACKE_cgesvd$handle() {
        return LAPACKE_cgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static MemorySegment LAPACKE_cgesvd$address() {
        return LAPACKE_cgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static int LAPACKE_cgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_cgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvd$descriptor() {
        return LAPACKE_zgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static MethodHandle LAPACKE_zgesvd$handle() {
        return LAPACKE_zgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static MemorySegment LAPACKE_zgesvd$address() {
        return LAPACKE_zgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static int LAPACKE_zgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_zgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdx$descriptor() {
        return LAPACKE_sgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdx$handle() {
        return LAPACKE_sgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdx$address() {
        return LAPACKE_sgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_sgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_sgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdx$descriptor() {
        return LAPACKE_dgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdx$handle() {
        return LAPACKE_dgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdx$address() {
        return LAPACKE_dgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_dgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_dgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdx$descriptor() {
        return LAPACKE_cgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdx$handle() {
        return LAPACKE_cgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdx$address() {
        return LAPACKE_cgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_cgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_cgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdx$descriptor() {
        return LAPACKE_zgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdx$handle() {
        return LAPACKE_zgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdx$address() {
        return LAPACKE_zgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_zgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_zgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdq$descriptor() {
        return LAPACKE_sgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdq$handle() {
        return LAPACKE_sgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdq$address() {
        return LAPACKE_sgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_sgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_sgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdq$descriptor() {
        return LAPACKE_dgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdq$handle() {
        return LAPACKE_dgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdq$address() {
        return LAPACKE_dgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_dgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_dgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdq$descriptor() {
        return LAPACKE_cgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdq$handle() {
        return LAPACKE_cgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdq$address() {
        return LAPACKE_cgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_cgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_cgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdq$descriptor() {
        return LAPACKE_zgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdq$handle() {
        return LAPACKE_zgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdq$address() {
        return LAPACKE_zgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_zgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_zgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvj$descriptor() {
        return LAPACKE_sgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static MethodHandle LAPACKE_sgesvj$handle() {
        return LAPACKE_sgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static MemorySegment LAPACKE_sgesvj$address() {
        return LAPACKE_sgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static int LAPACKE_sgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_sgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvj$descriptor() {
        return LAPACKE_dgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static MethodHandle LAPACKE_dgesvj$handle() {
        return LAPACKE_dgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static MemorySegment LAPACKE_dgesvj$address() {
        return LAPACKE_dgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static int LAPACKE_dgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_dgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvj$descriptor() {
        return LAPACKE_cgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static MethodHandle LAPACKE_cgesvj$handle() {
        return LAPACKE_cgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static MemorySegment LAPACKE_cgesvj$address() {
        return LAPACKE_cgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static int LAPACKE_cgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_cgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvj$descriptor() {
        return LAPACKE_zgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static MethodHandle LAPACKE_zgesvj$handle() {
        return LAPACKE_zgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static MemorySegment LAPACKE_zgesvj$address() {
        return LAPACKE_zgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static int LAPACKE_zgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_zgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvx$descriptor() {
        return LAPACKE_sgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_sgesvx$handle() {
        return LAPACKE_sgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_sgesvx$address() {
        return LAPACKE_sgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_sgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_sgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvx$descriptor() {
        return LAPACKE_dgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_dgesvx$handle() {
        return LAPACKE_dgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_dgesvx$address() {
        return LAPACKE_dgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_dgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_dgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvx$descriptor() {
        return LAPACKE_cgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_cgesvx$handle() {
        return LAPACKE_cgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_cgesvx$address() {
        return LAPACKE_cgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_cgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_cgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvx$descriptor() {
        return LAPACKE_zgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_zgesvx$handle() {
        return LAPACKE_zgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_zgesvx$address() {
        return LAPACKE_zgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_zgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_zgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvxx$descriptor() {
        return LAPACKE_sgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgesvxx$handle() {
        return LAPACKE_sgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgesvxx$address() {
        return LAPACKE_sgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvxx$descriptor() {
        return LAPACKE_dgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgesvxx$handle() {
        return LAPACKE_dgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgesvxx$address() {
        return LAPACKE_dgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvxx$descriptor() {
        return LAPACKE_cgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgesvxx$handle() {
        return LAPACKE_cgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgesvxx$address() {
        return LAPACKE_cgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvxx$descriptor() {
        return LAPACKE_zgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgesvxx$handle() {
        return LAPACKE_zgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgesvxx$address() {
        return LAPACKE_zgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetf2$descriptor() {
        return LAPACKE_sgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetf2$handle() {
        return LAPACKE_sgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetf2$address() {
        return LAPACKE_sgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetf2$descriptor() {
        return LAPACKE_dgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetf2$handle() {
        return LAPACKE_dgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetf2$address() {
        return LAPACKE_dgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetf2$descriptor() {
        return LAPACKE_cgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetf2$handle() {
        return LAPACKE_cgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetf2$address() {
        return LAPACKE_cgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetf2$descriptor() {
        return LAPACKE_zgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetf2$handle() {
        return LAPACKE_zgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetf2$address() {
        return LAPACKE_zgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf$descriptor() {
        return LAPACKE_sgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf$handle() {
        return LAPACKE_sgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf$address() {
        return LAPACKE_sgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf$descriptor() {
        return LAPACKE_dgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf$handle() {
        return LAPACKE_dgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf$address() {
        return LAPACKE_dgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf$descriptor() {
        return LAPACKE_cgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf$handle() {
        return LAPACKE_cgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf$address() {
        return LAPACKE_cgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf$descriptor() {
        return LAPACKE_zgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf$handle() {
        return LAPACKE_zgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf$address() {
        return LAPACKE_zgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf2$descriptor() {
        return LAPACKE_sgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf2$handle() {
        return LAPACKE_sgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf2$address() {
        return LAPACKE_sgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf2$descriptor() {
        return LAPACKE_dgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf2$handle() {
        return LAPACKE_dgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf2$address() {
        return LAPACKE_dgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf2$descriptor() {
        return LAPACKE_cgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf2$handle() {
        return LAPACKE_cgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf2$address() {
        return LAPACKE_cgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf2$descriptor() {
        return LAPACKE_zgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf2$handle() {
        return LAPACKE_zgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf2$address() {
        return LAPACKE_zgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetri$descriptor() {
        return LAPACKE_sgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetri$handle() {
        return LAPACKE_sgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetri$address() {
        return LAPACKE_sgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_sgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetri$descriptor() {
        return LAPACKE_dgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetri$handle() {
        return LAPACKE_dgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetri$address() {
        return LAPACKE_dgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetri$descriptor() {
        return LAPACKE_cgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetri$handle() {
        return LAPACKE_cgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetri$address() {
        return LAPACKE_cgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_cgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetri$descriptor() {
        return LAPACKE_zgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetri$handle() {
        return LAPACKE_zgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetri$address() {
        return LAPACKE_zgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrs$descriptor() {
        return LAPACKE_sgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgetrs$handle() {
        return LAPACKE_sgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgetrs$address() {
        return LAPACKE_sgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrs$descriptor() {
        return LAPACKE_dgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgetrs$handle() {
        return LAPACKE_dgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgetrs$address() {
        return LAPACKE_dgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrs$descriptor() {
        return LAPACKE_cgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgetrs$handle() {
        return LAPACKE_cgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgetrs$address() {
        return LAPACKE_cgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrs$descriptor() {
        return LAPACKE_zgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgetrs$handle() {
        return LAPACKE_zgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgetrs$address() {
        return LAPACKE_zgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbak$descriptor() {
        return LAPACKE_sggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sggbak$handle() {
        return LAPACKE_sggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sggbak$address() {
        return LAPACKE_sggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbak$descriptor() {
        return LAPACKE_dggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dggbak$handle() {
        return LAPACKE_dggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dggbak$address() {
        return LAPACKE_dggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbak$descriptor() {
        return LAPACKE_cggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cggbak$handle() {
        return LAPACKE_cggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cggbak$address() {
        return LAPACKE_cggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbak$descriptor() {
        return LAPACKE_zggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zggbak$handle() {
        return LAPACKE_zggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zggbak$address() {
        return LAPACKE_zggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbal$descriptor() {
        return LAPACKE_sggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MethodHandle LAPACKE_sggbal$handle() {
        return LAPACKE_sggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MemorySegment LAPACKE_sggbal$address() {
        return LAPACKE_sggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static int LAPACKE_sggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_sggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbal$descriptor() {
        return LAPACKE_dggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MethodHandle LAPACKE_dggbal$handle() {
        return LAPACKE_dggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MemorySegment LAPACKE_dggbal$address() {
        return LAPACKE_dggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static int LAPACKE_dggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_dggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbal$descriptor() {
        return LAPACKE_cggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MethodHandle LAPACKE_cggbal$handle() {
        return LAPACKE_cggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MemorySegment LAPACKE_cggbal$address() {
        return LAPACKE_cggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static int LAPACKE_cggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_cggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbal$descriptor() {
        return LAPACKE_zggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MethodHandle LAPACKE_zggbal$handle() {
        return LAPACKE_zggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MemorySegment LAPACKE_zggbal$address() {
        return LAPACKE_zggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static int LAPACKE_zggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_zggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges$descriptor() {
        return LAPACKE_sgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_sgges$handle() {
        return LAPACKE_sgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_sgges$address() {
        return LAPACKE_sgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_sgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_sgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges$descriptor() {
        return LAPACKE_dgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_dgges$handle() {
        return LAPACKE_dgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_dgges$address() {
        return LAPACKE_dgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_dgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_dgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges$descriptor() {
        return LAPACKE_cgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_cgges$handle() {
        return LAPACKE_cgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_cgges$address() {
        return LAPACKE_cgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_cgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_cgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges$descriptor() {
        return LAPACKE_zgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_zgges$handle() {
        return LAPACKE_zgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_zgges$address() {
        return LAPACKE_zgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_zgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_zgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges3$descriptor() {
        return LAPACKE_sgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_sgges3$handle() {
        return LAPACKE_sgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_sgges3$address() {
        return LAPACKE_sgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_sgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_sgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges3$descriptor() {
        return LAPACKE_dgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_dgges3$handle() {
        return LAPACKE_dgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_dgges3$address() {
        return LAPACKE_dgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_dgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_dgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges3$descriptor() {
        return LAPACKE_cgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_cgges3$handle() {
        return LAPACKE_cgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_cgges3$address() {
        return LAPACKE_cgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_cgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_cgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges3$descriptor() {
        return LAPACKE_zgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_zgges3$handle() {
        return LAPACKE_zgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_zgges3$address() {
        return LAPACKE_zgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_zgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_zgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggesx$descriptor() {
        return LAPACKE_sggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sggesx$handle() {
        return LAPACKE_sggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sggesx$address() {
        return LAPACKE_sggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggesx$descriptor() {
        return LAPACKE_dggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dggesx$handle() {
        return LAPACKE_dggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dggesx$address() {
        return LAPACKE_dggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggesx$descriptor() {
        return LAPACKE_cggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cggesx$handle() {
        return LAPACKE_cggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cggesx$address() {
        return LAPACKE_cggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggesx$descriptor() {
        return LAPACKE_zggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zggesx$handle() {
        return LAPACKE_zggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zggesx$address() {
        return LAPACKE_zggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev$descriptor() {
        return LAPACKE_sggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sggev$handle() {
        return LAPACKE_sggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sggev$address() {
        return LAPACKE_sggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev$descriptor() {
        return LAPACKE_dggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dggev$handle() {
        return LAPACKE_dggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dggev$address() {
        return LAPACKE_dggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev$descriptor() {
        return LAPACKE_cggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cggev$handle() {
        return LAPACKE_cggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cggev$address() {
        return LAPACKE_cggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev$descriptor() {
        return LAPACKE_zggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zggev$handle() {
        return LAPACKE_zggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zggev$address() {
        return LAPACKE_zggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev3$descriptor() {
        return LAPACKE_sggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sggev3$handle() {
        return LAPACKE_sggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sggev3$address() {
        return LAPACKE_sggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev3$descriptor() {
        return LAPACKE_dggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dggev3$handle() {
        return LAPACKE_dggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dggev3$address() {
        return LAPACKE_dggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev3$descriptor() {
        return LAPACKE_cggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cggev3$handle() {
        return LAPACKE_cggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cggev3$address() {
        return LAPACKE_cggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev3$descriptor() {
        return LAPACKE_zggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zggev3$handle() {
        return LAPACKE_zggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zggev3$address() {
        return LAPACKE_zggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggevx$descriptor() {
        return LAPACKE_sggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sggevx$handle() {
        return LAPACKE_sggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sggevx$address() {
        return LAPACKE_sggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggevx$descriptor() {
        return LAPACKE_dggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dggevx$handle() {
        return LAPACKE_dggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dggevx$address() {
        return LAPACKE_dggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggevx$descriptor() {
        return LAPACKE_cggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cggevx$handle() {
        return LAPACKE_cggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cggevx$address() {
        return LAPACKE_cggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggevx$descriptor() {
        return LAPACKE_zggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zggevx$handle() {
        return LAPACKE_zggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zggevx$address() {
        return LAPACKE_zggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggglm$descriptor() {
        return LAPACKE_sggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static MethodHandle LAPACKE_sggglm$handle() {
        return LAPACKE_sggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static MemorySegment LAPACKE_sggglm$address() {
        return LAPACKE_sggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_sggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggglm$descriptor() {
        return LAPACKE_dggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static MethodHandle LAPACKE_dggglm$handle() {
        return LAPACKE_dggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static MemorySegment LAPACKE_dggglm$address() {
        return LAPACKE_dggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_dggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggglm$descriptor() {
        return LAPACKE_cggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static MethodHandle LAPACKE_cggglm$handle() {
        return LAPACKE_cggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static MemorySegment LAPACKE_cggglm$address() {
        return LAPACKE_cggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_cggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggglm$descriptor() {
        return LAPACKE_zggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static MethodHandle LAPACKE_zggglm$handle() {
        return LAPACKE_zggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static MemorySegment LAPACKE_zggglm$address() {
        return LAPACKE_zggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_zggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghrd$descriptor() {
        return LAPACKE_sgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghrd$handle() {
        return LAPACKE_sgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghrd$address() {
        return LAPACKE_sgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghrd$descriptor() {
        return LAPACKE_dgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghrd$handle() {
        return LAPACKE_dgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghrd$address() {
        return LAPACKE_dgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghrd$descriptor() {
        return LAPACKE_cgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghrd$handle() {
        return LAPACKE_cgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghrd$address() {
        return LAPACKE_cgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghrd$descriptor() {
        return LAPACKE_zgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghrd$handle() {
        return LAPACKE_zgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghrd$address() {
        return LAPACKE_zgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghd3$descriptor() {
        return LAPACKE_sgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghd3$handle() {
        return LAPACKE_sgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghd3$address() {
        return LAPACKE_sgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghd3$descriptor() {
        return LAPACKE_dgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghd3$handle() {
        return LAPACKE_dgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghd3$address() {
        return LAPACKE_dgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghd3$descriptor() {
        return LAPACKE_cgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghd3$handle() {
        return LAPACKE_cgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghd3$address() {
        return LAPACKE_cgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghd3$descriptor() {
        return LAPACKE_zgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghd3$handle() {
        return LAPACKE_zgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghd3$address() {
        return LAPACKE_zgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgglse$descriptor() {
        return LAPACKE_sgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static MethodHandle LAPACKE_sgglse$handle() {
        return LAPACKE_sgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static MemorySegment LAPACKE_sgglse$address() {
        return LAPACKE_sgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_sgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgglse$descriptor() {
        return LAPACKE_dgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dgglse$handle() {
        return LAPACKE_dgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dgglse$address() {
        return LAPACKE_dgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_dgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgglse$descriptor() {
        return LAPACKE_cgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_cgglse$handle() {
        return LAPACKE_cgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_cgglse$address() {
        return LAPACKE_cgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_cgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgglse$descriptor() {
        return LAPACKE_zgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zgglse$handle() {
        return LAPACKE_zgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zgglse$address() {
        return LAPACKE_zgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_zgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggqrf$descriptor() {
        return LAPACKE_sggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MethodHandle LAPACKE_sggqrf$handle() {
        return LAPACKE_sggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MemorySegment LAPACKE_sggqrf$address() {
        return LAPACKE_sggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_sggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggqrf$descriptor() {
        return LAPACKE_dggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MethodHandle LAPACKE_dggqrf$handle() {
        return LAPACKE_dggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MemorySegment LAPACKE_dggqrf$address() {
        return LAPACKE_dggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_dggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggqrf$descriptor() {
        return LAPACKE_cggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MethodHandle LAPACKE_cggqrf$handle() {
        return LAPACKE_cggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MemorySegment LAPACKE_cggqrf$address() {
        return LAPACKE_cggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_cggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggqrf$descriptor() {
        return LAPACKE_zggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MethodHandle LAPACKE_zggqrf$handle() {
        return LAPACKE_zggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MemorySegment LAPACKE_zggqrf$address() {
        return LAPACKE_zggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_zggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggrqf$descriptor() {
        return LAPACKE_sggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MethodHandle LAPACKE_sggrqf$handle() {
        return LAPACKE_sggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MemorySegment LAPACKE_sggrqf$address() {
        return LAPACKE_sggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_sggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggrqf$descriptor() {
        return LAPACKE_dggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MethodHandle LAPACKE_dggrqf$handle() {
        return LAPACKE_dggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MemorySegment LAPACKE_dggrqf$address() {
        return LAPACKE_dggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_dggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggrqf$descriptor() {
        return LAPACKE_cggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MethodHandle LAPACKE_cggrqf$handle() {
        return LAPACKE_cggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MemorySegment LAPACKE_cggrqf$address() {
        return LAPACKE_cggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_cggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggrqf$descriptor() {
        return LAPACKE_zggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MethodHandle LAPACKE_zggrqf$handle() {
        return LAPACKE_zggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MemorySegment LAPACKE_zggrqf$address() {
        return LAPACKE_zggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_zggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd$descriptor() {
        return LAPACKE_sggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd$handle() {
        return LAPACKE_sggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd$address() {
        return LAPACKE_sggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd$descriptor() {
        return LAPACKE_dggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd$handle() {
        return LAPACKE_dggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd$address() {
        return LAPACKE_dggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd$descriptor() {
        return LAPACKE_cggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd$handle() {
        return LAPACKE_cggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd$address() {
        return LAPACKE_cggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd$descriptor() {
        return LAPACKE_zggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd$handle() {
        return LAPACKE_zggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd$address() {
        return LAPACKE_zggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd3$descriptor() {
        return LAPACKE_sggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd3$handle() {
        return LAPACKE_sggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd3$address() {
        return LAPACKE_sggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd3$descriptor() {
        return LAPACKE_dggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd3$handle() {
        return LAPACKE_dggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd3$address() {
        return LAPACKE_dggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd3$descriptor() {
        return LAPACKE_cggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd3$handle() {
        return LAPACKE_cggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd3$address() {
        return LAPACKE_cggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd3$descriptor() {
        return LAPACKE_zggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd3$handle() {
        return LAPACKE_zggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd3$address() {
        return LAPACKE_zggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp$descriptor() {
        return LAPACKE_sggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp$handle() {
        return LAPACKE_sggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp$address() {
        return LAPACKE_sggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp$descriptor() {
        return LAPACKE_dggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp$handle() {
        return LAPACKE_dggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp$address() {
        return LAPACKE_dggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp$descriptor() {
        return LAPACKE_cggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp$handle() {
        return LAPACKE_cggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp$address() {
        return LAPACKE_cggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp$descriptor() {
        return LAPACKE_zggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp$handle() {
        return LAPACKE_zggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp$address() {
        return LAPACKE_zggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp3$descriptor() {
        return LAPACKE_sggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp3$handle() {
        return LAPACKE_sggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp3$address() {
        return LAPACKE_sggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp3$descriptor() {
        return LAPACKE_dggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp3$handle() {
        return LAPACKE_dggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp3$address() {
        return LAPACKE_dggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp3$descriptor() {
        return LAPACKE_cggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp3$handle() {
        return LAPACKE_cggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp3$address() {
        return LAPACKE_cggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp3$descriptor() {
        return LAPACKE_zggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp3$handle() {
        return LAPACKE_zggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp3$address() {
        return LAPACKE_zggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtcon$descriptor() {
        return LAPACKE_sgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgtcon$handle() {
        return LAPACKE_sgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgtcon$address() {
        return LAPACKE_sgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtcon$descriptor() {
        return LAPACKE_dgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgtcon$handle() {
        return LAPACKE_dgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgtcon$address() {
        return LAPACKE_dgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtcon$descriptor() {
        return LAPACKE_cgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgtcon$handle() {
        return LAPACKE_cgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgtcon$address() {
        return LAPACKE_cgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtcon$descriptor() {
        return LAPACKE_zgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgtcon$handle() {
        return LAPACKE_zgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgtcon$address() {
        return LAPACKE_zgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtrfs$descriptor() {
        return LAPACKE_sgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgtrfs$handle() {
        return LAPACKE_sgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgtrfs$address() {
        return LAPACKE_sgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtrfs$descriptor() {
        return LAPACKE_dgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgtrfs$handle() {
        return LAPACKE_dgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgtrfs$address() {
        return LAPACKE_dgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtrfs$descriptor() {
        return LAPACKE_cgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgtrfs$handle() {
        return LAPACKE_cgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgtrfs$address() {
        return LAPACKE_cgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtrfs$descriptor() {
        return LAPACKE_zgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgtrfs$handle() {
        return LAPACKE_zgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgtrfs$address() {
        return LAPACKE_zgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsv$descriptor() {
        return LAPACKE_sgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgtsv$handle() {
        return LAPACKE_sgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgtsv$address() {
        return LAPACKE_sgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsv$descriptor() {
        return LAPACKE_dgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgtsv$handle() {
        return LAPACKE_dgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgtsv$address() {
        return LAPACKE_dgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsv$descriptor() {
        return LAPACKE_cgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgtsv$handle() {
        return LAPACKE_cgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgtsv$address() {
        return LAPACKE_cgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsv$descriptor() {
        return LAPACKE_zgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgtsv$handle() {
        return LAPACKE_zgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgtsv$address() {
        return LAPACKE_zgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsvx$descriptor() {
        return LAPACKE_sgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgtsvx$handle() {
        return LAPACKE_sgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgtsvx$address() {
        return LAPACKE_sgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsvx$descriptor() {
        return LAPACKE_dgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgtsvx$handle() {
        return LAPACKE_dgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgtsvx$address() {
        return LAPACKE_dgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsvx$descriptor() {
        return LAPACKE_cgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgtsvx$handle() {
        return LAPACKE_cgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgtsvx$address() {
        return LAPACKE_cgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsvx$descriptor() {
        return LAPACKE_zgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgtsvx$handle() {
        return LAPACKE_zgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgtsvx$address() {
        return LAPACKE_zgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrf$descriptor() {
        return LAPACKE_sgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgttrf$handle() {
        return LAPACKE_sgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgttrf$address() {
        return LAPACKE_sgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_sgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrf$descriptor() {
        return LAPACKE_dgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgttrf$handle() {
        return LAPACKE_dgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgttrf$address() {
        return LAPACKE_dgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_dgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrf$descriptor() {
        return LAPACKE_cgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgttrf$handle() {
        return LAPACKE_cgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgttrf$address() {
        return LAPACKE_cgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_cgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrf$descriptor() {
        return LAPACKE_zgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgttrf$handle() {
        return LAPACKE_zgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgttrf$address() {
        return LAPACKE_zgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_zgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrs$descriptor() {
        return LAPACKE_sgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgttrs$handle() {
        return LAPACKE_sgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgttrs$address() {
        return LAPACKE_sgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrs$descriptor() {
        return LAPACKE_dgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgttrs$handle() {
        return LAPACKE_dgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgttrs$address() {
        return LAPACKE_dgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrs$descriptor() {
        return LAPACKE_cgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgttrs$handle() {
        return LAPACKE_cgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgttrs$address() {
        return LAPACKE_cgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrs$descriptor() {
        return LAPACKE_zgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgttrs$handle() {
        return LAPACKE_zgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgttrs$address() {
        return LAPACKE_zgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev$descriptor() {
        return LAPACKE_chbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbev$handle() {
        return LAPACKE_chbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbev$address() {
        return LAPACKE_chbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev$descriptor() {
        return LAPACKE_zhbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbev$handle() {
        return LAPACKE_zhbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbev$address() {
        return LAPACKE_zhbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd$descriptor() {
        return LAPACKE_chbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbevd$handle() {
        return LAPACKE_chbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbevd$address() {
        return LAPACKE_chbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd$descriptor() {
        return LAPACKE_zhbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd$handle() {
        return LAPACKE_zhbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd$address() {
        return LAPACKE_zhbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx$descriptor() {
        return LAPACKE_chbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx$handle() {
        return LAPACKE_chbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx$address() {
        return LAPACKE_chbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx$descriptor() {
        return LAPACKE_zhbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx$handle() {
        return LAPACKE_zhbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx$address() {
        return LAPACKE_zhbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgst$descriptor() {
        return LAPACKE_chbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_chbgst$handle() {
        return LAPACKE_chbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_chbgst$address() {
        return LAPACKE_chbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static int LAPACKE_chbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_chbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgst$descriptor() {
        return LAPACKE_zhbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_zhbgst$handle() {
        return LAPACKE_zhbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_zhbgst$address() {
        return LAPACKE_zhbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static int LAPACKE_zhbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_zhbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgv$descriptor() {
        return LAPACKE_chbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbgv$handle() {
        return LAPACKE_chbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbgv$address() {
        return LAPACKE_chbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgv$descriptor() {
        return LAPACKE_zhbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbgv$handle() {
        return LAPACKE_zhbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbgv$address() {
        return LAPACKE_zhbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvd$descriptor() {
        return LAPACKE_chbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbgvd$handle() {
        return LAPACKE_chbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbgvd$address() {
        return LAPACKE_chbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvd$descriptor() {
        return LAPACKE_zhbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvd$handle() {
        return LAPACKE_zhbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvd$address() {
        return LAPACKE_zhbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvx$descriptor() {
        return LAPACKE_chbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbgvx$handle() {
        return LAPACKE_chbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbgvx$address() {
        return LAPACKE_chbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvx$descriptor() {
        return LAPACKE_zhbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvx$handle() {
        return LAPACKE_zhbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvx$address() {
        return LAPACKE_zhbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbtrd$descriptor() {
        return LAPACKE_chbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_chbtrd$handle() {
        return LAPACKE_chbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_chbtrd$address() {
        return LAPACKE_chbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_chbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_chbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbtrd$descriptor() {
        return LAPACKE_zhbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zhbtrd$handle() {
        return LAPACKE_zhbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zhbtrd$address() {
        return LAPACKE_zhbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zhbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zhbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_checon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon$descriptor() {
        return LAPACKE_checon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_checon$handle() {
        return LAPACKE_checon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_checon$address() {
        return LAPACKE_checon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_checon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_checon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon$descriptor() {
        return LAPACKE_zhecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zhecon$handle() {
        return LAPACKE_zhecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zhecon$address() {
        return LAPACKE_zhecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zhecon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zhecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheequb$descriptor() {
        return LAPACKE_cheequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cheequb$handle() {
        return LAPACKE_cheequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cheequb$address() {
        return LAPACKE_cheequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cheequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cheequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheequb$descriptor() {
        return LAPACKE_zheequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zheequb$handle() {
        return LAPACKE_zheequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zheequb$address() {
        return LAPACKE_zheequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zheequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zheequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev$descriptor() {
        return LAPACKE_cheev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheev$handle() {
        return LAPACKE_cheev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheev$address() {
        return LAPACKE_cheev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev$descriptor() {
        return LAPACKE_zheev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheev$handle() {
        return LAPACKE_zheev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheev$address() {
        return LAPACKE_zheev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd$descriptor() {
        return LAPACKE_cheevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheevd$handle() {
        return LAPACKE_cheevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheevd$address() {
        return LAPACKE_cheevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd$descriptor() {
        return LAPACKE_zheevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheevd$handle() {
        return LAPACKE_zheevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheevd$address() {
        return LAPACKE_zheevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr$descriptor() {
        return LAPACKE_cheevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_cheevr$handle() {
        return LAPACKE_cheevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_cheevr$address() {
        return LAPACKE_cheevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_cheevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_cheevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr$descriptor() {
        return LAPACKE_zheevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_zheevr$handle() {
        return LAPACKE_zheevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_zheevr$address() {
        return LAPACKE_zheevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_zheevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_zheevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx$descriptor() {
        return LAPACKE_cheevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx$handle() {
        return LAPACKE_cheevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx$address() {
        return LAPACKE_cheevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx$descriptor() {
        return LAPACKE_zheevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx$handle() {
        return LAPACKE_zheevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx$address() {
        return LAPACKE_zheevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegst$descriptor() {
        return LAPACKE_chegst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chegst$handle() {
        return LAPACKE_chegst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chegst$address() {
        return LAPACKE_chegst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chegst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chegst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegst$descriptor() {
        return LAPACKE_zhegst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhegst$handle() {
        return LAPACKE_zhegst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhegst$address() {
        return LAPACKE_zhegst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhegst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhegst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv$descriptor() {
        return LAPACKE_chegv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_chegv$handle() {
        return LAPACKE_chegv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_chegv$address() {
        return LAPACKE_chegv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_chegv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_chegv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv$descriptor() {
        return LAPACKE_zhegv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zhegv$handle() {
        return LAPACKE_zhegv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zhegv$address() {
        return LAPACKE_zhegv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_zhegv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_zhegv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvd$descriptor() {
        return LAPACKE_chegvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_chegvd$handle() {
        return LAPACKE_chegvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_chegvd$address() {
        return LAPACKE_chegvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_chegvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_chegvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvd$descriptor() {
        return LAPACKE_zhegvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zhegvd$handle() {
        return LAPACKE_zhegvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zhegvd$address() {
        return LAPACKE_zhegvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_zhegvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_zhegvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvx$descriptor() {
        return LAPACKE_chegvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chegvx$handle() {
        return LAPACKE_chegvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chegvx$address() {
        return LAPACKE_chegvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chegvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chegvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvx$descriptor() {
        return LAPACKE_zhegvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhegvx$handle() {
        return LAPACKE_zhegvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhegvx$address() {
        return LAPACKE_zhegvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhegvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhegvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cherfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfs$descriptor() {
        return LAPACKE_cherfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cherfs$handle() {
        return LAPACKE_cherfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cherfs$address() {
        return LAPACKE_cherfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cherfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cherfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zherfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfs$descriptor() {
        return LAPACKE_zherfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zherfs$handle() {
        return LAPACKE_zherfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zherfs$address() {
        return LAPACKE_zherfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zherfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zherfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cherfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfsx$descriptor() {
        return LAPACKE_cherfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cherfsx$handle() {
        return LAPACKE_cherfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cherfsx$address() {
        return LAPACKE_cherfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cherfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cherfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zherfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfsx$descriptor() {
        return LAPACKE_zherfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zherfsx$handle() {
        return LAPACKE_zherfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zherfsx$address() {
        return LAPACKE_zherfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zherfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zherfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv$descriptor() {
        return LAPACKE_chesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv$handle() {
        return LAPACKE_chesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv$address() {
        return LAPACKE_chesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv$descriptor() {
        return LAPACKE_zhesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv$handle() {
        return LAPACKE_zhesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv$address() {
        return LAPACKE_zhesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvx$descriptor() {
        return LAPACKE_chesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chesvx$handle() {
        return LAPACKE_chesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chesvx$address() {
        return LAPACKE_chesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chesvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvx$descriptor() {
        return LAPACKE_zhesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhesvx$handle() {
        return LAPACKE_zhesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhesvx$address() {
        return LAPACKE_zhesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhesvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvxx$descriptor() {
        return LAPACKE_chesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_chesvxx$handle() {
        return LAPACKE_chesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_chesvxx$address() {
        return LAPACKE_chesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_chesvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_chesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvxx$descriptor() {
        return LAPACKE_zhesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zhesvxx$handle() {
        return LAPACKE_zhesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zhesvxx$address() {
        return LAPACKE_zhesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zhesvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zhesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrd$descriptor() {
        return LAPACKE_chetrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chetrd$handle() {
        return LAPACKE_chetrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chetrd$address() {
        return LAPACKE_chetrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chetrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chetrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrd$descriptor() {
        return LAPACKE_zhetrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhetrd$handle() {
        return LAPACKE_zhetrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhetrd$address() {
        return LAPACKE_zhetrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhetrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhetrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf$descriptor() {
        return LAPACKE_chetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf$handle() {
        return LAPACKE_chetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf$address() {
        return LAPACKE_chetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf$descriptor() {
        return LAPACKE_zhetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf$handle() {
        return LAPACKE_zhetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf$address() {
        return LAPACKE_zhetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri$descriptor() {
        return LAPACKE_chetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetri$handle() {
        return LAPACKE_chetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetri$address() {
        return LAPACKE_chetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_chetri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri$descriptor() {
        return LAPACKE_zhetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetri$handle() {
        return LAPACKE_zhetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetri$address() {
        return LAPACKE_zhetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhetri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs$descriptor() {
        return LAPACKE_chetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs$handle() {
        return LAPACKE_chetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs$address() {
        return LAPACKE_chetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs$descriptor() {
        return LAPACKE_zhetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs$handle() {
        return LAPACKE_zhetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs$address() {
        return LAPACKE_zhetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_chfrk$descriptor() {
        return LAPACKE_chfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MethodHandle LAPACKE_chfrk$handle() {
        return LAPACKE_chfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MemorySegment LAPACKE_chfrk$address() {
        return LAPACKE_chfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static int LAPACKE_chfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_chfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhfrk$descriptor() {
        return LAPACKE_zhfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MethodHandle LAPACKE_zhfrk$handle() {
        return LAPACKE_zhfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MemorySegment LAPACKE_zhfrk$address() {
        return LAPACKE_zhfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static int LAPACKE_zhfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_zhfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_shgeqz$descriptor() {
        return LAPACKE_shgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_shgeqz$handle() {
        return LAPACKE_shgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_shgeqz$address() {
        return LAPACKE_shgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_shgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_shgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhgeqz$descriptor() {
        return LAPACKE_dhgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dhgeqz$handle() {
        return LAPACKE_dhgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dhgeqz$address() {
        return LAPACKE_dhgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dhgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dhgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chgeqz$descriptor() {
        return LAPACKE_chgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chgeqz$handle() {
        return LAPACKE_chgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chgeqz$address() {
        return LAPACKE_chgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhgeqz$descriptor() {
        return LAPACKE_zhgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhgeqz$handle() {
        return LAPACKE_zhgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhgeqz$address() {
        return LAPACKE_zhgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpcon$descriptor() {
        return LAPACKE_chpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_chpcon$handle() {
        return LAPACKE_chpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_chpcon$address() {
        return LAPACKE_chpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_chpcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_chpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpcon$descriptor() {
        return LAPACKE_zhpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zhpcon$handle() {
        return LAPACKE_zhpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zhpcon$address() {
        return LAPACKE_zhpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zhpcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zhpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpev$descriptor() {
        return LAPACKE_chpev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpev$handle() {
        return LAPACKE_chpev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpev$address() {
        return LAPACKE_chpev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpev$descriptor() {
        return LAPACKE_zhpev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpev$handle() {
        return LAPACKE_zhpev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpev$address() {
        return LAPACKE_zhpev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevd$descriptor() {
        return LAPACKE_chpevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpevd$handle() {
        return LAPACKE_chpevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpevd$address() {
        return LAPACKE_chpevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevd$descriptor() {
        return LAPACKE_zhpevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpevd$handle() {
        return LAPACKE_zhpevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpevd$address() {
        return LAPACKE_zhpevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevx$descriptor() {
        return LAPACKE_chpevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpevx$handle() {
        return LAPACKE_chpevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpevx$address() {
        return LAPACKE_chpevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chpevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chpevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevx$descriptor() {
        return LAPACKE_zhpevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpevx$handle() {
        return LAPACKE_zhpevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpevx$address() {
        return LAPACKE_zhpevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhpevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgst$descriptor() {
        return LAPACKE_chpgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MethodHandle LAPACKE_chpgst$handle() {
        return LAPACKE_chpgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MemorySegment LAPACKE_chpgst$address() {
        return LAPACKE_chpgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static int LAPACKE_chpgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_chpgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgst$descriptor() {
        return LAPACKE_zhpgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MethodHandle LAPACKE_zhpgst$handle() {
        return LAPACKE_zhpgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MemorySegment LAPACKE_zhpgst$address() {
        return LAPACKE_zhpgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static int LAPACKE_zhpgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_zhpgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgv$descriptor() {
        return LAPACKE_chpgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpgv$handle() {
        return LAPACKE_chpgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpgv$address() {
        return LAPACKE_chpgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgv$descriptor() {
        return LAPACKE_zhpgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpgv$handle() {
        return LAPACKE_zhpgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpgv$address() {
        return LAPACKE_zhpgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvd$descriptor() {
        return LAPACKE_chpgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpgvd$handle() {
        return LAPACKE_chpgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpgvd$address() {
        return LAPACKE_chpgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvd$descriptor() {
        return LAPACKE_zhpgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvd$handle() {
        return LAPACKE_zhpgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvd$address() {
        return LAPACKE_zhpgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvx$descriptor() {
        return LAPACKE_chpgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpgvx$handle() {
        return LAPACKE_chpgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpgvx$address() {
        return LAPACKE_chpgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chpgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chpgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvx$descriptor() {
        return LAPACKE_zhpgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvx$handle() {
        return LAPACKE_zhpgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvx$address() {
        return LAPACKE_zhpgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhpgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chprfs$descriptor() {
        return LAPACKE_chprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chprfs$handle() {
        return LAPACKE_chprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chprfs$address() {
        return LAPACKE_chprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhprfs$descriptor() {
        return LAPACKE_zhprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhprfs$handle() {
        return LAPACKE_zhprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhprfs$address() {
        return LAPACKE_zhprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsv$descriptor() {
        return LAPACKE_chpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chpsv$handle() {
        return LAPACKE_chpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chpsv$address() {
        return LAPACKE_chpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chpsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsv$descriptor() {
        return LAPACKE_zhpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhpsv$handle() {
        return LAPACKE_zhpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhpsv$address() {
        return LAPACKE_zhpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhpsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsvx$descriptor() {
        return LAPACKE_chpsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chpsvx$handle() {
        return LAPACKE_chpsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chpsvx$address() {
        return LAPACKE_chpsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chpsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chpsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsvx$descriptor() {
        return LAPACKE_zhpsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhpsvx$handle() {
        return LAPACKE_zhpsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhpsvx$address() {
        return LAPACKE_zhpsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhpsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhpsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrd$descriptor() {
        return LAPACKE_chptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chptrd$handle() {
        return LAPACKE_chptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chptrd$address() {
        return LAPACKE_chptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrd$descriptor() {
        return LAPACKE_zhptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhptrd$handle() {
        return LAPACKE_zhptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhptrd$address() {
        return LAPACKE_zhptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrf$descriptor() {
        return LAPACKE_chptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptrf$handle() {
        return LAPACKE_chptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptrf$address() {
        return LAPACKE_chptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_chptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrf$descriptor() {
        return LAPACKE_zhptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptrf$handle() {
        return LAPACKE_zhptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptrf$address() {
        return LAPACKE_zhptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zhptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptri$descriptor() {
        return LAPACKE_chptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptri$handle() {
        return LAPACKE_chptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptri$address() {
        return LAPACKE_chptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_chptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptri$descriptor() {
        return LAPACKE_zhptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptri$handle() {
        return LAPACKE_zhptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptri$address() {
        return LAPACKE_zhptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrs$descriptor() {
        return LAPACKE_chptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chptrs$handle() {
        return LAPACKE_chptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chptrs$address() {
        return LAPACKE_chptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrs$descriptor() {
        return LAPACKE_zhptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhptrs$handle() {
        return LAPACKE_zhptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhptrs$address() {
        return LAPACKE_zhptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_shsein$descriptor() {
        return LAPACKE_shsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_shsein$handle() {
        return LAPACKE_shsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_shsein$address() {
        return LAPACKE_shsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_shsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_shsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhsein$descriptor() {
        return LAPACKE_dhsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_dhsein$handle() {
        return LAPACKE_dhsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_dhsein$address() {
        return LAPACKE_dhsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_dhsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_dhsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chsein$descriptor() {
        return LAPACKE_chsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_chsein$handle() {
        return LAPACKE_chsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_chsein$address() {
        return LAPACKE_chsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_chsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_chsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhsein$descriptor() {
        return LAPACKE_zhsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_zhsein$handle() {
        return LAPACKE_zhsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_zhsein$address() {
        return LAPACKE_zhsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_zhsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_zhsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_shseqr$descriptor() {
        return LAPACKE_shseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_shseqr$handle() {
        return LAPACKE_shseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_shseqr$address() {
        return LAPACKE_shseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static int LAPACKE_shseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_shseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhseqr$descriptor() {
        return LAPACKE_dhseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dhseqr$handle() {
        return LAPACKE_dhseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dhseqr$address() {
        return LAPACKE_dhseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dhseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dhseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chseqr$descriptor() {
        return LAPACKE_chseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chseqr$handle() {
        return LAPACKE_chseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chseqr$address() {
        return LAPACKE_chseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhseqr$descriptor() {
        return LAPACKE_zhseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhseqr$handle() {
        return LAPACKE_zhseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhseqr$address() {
        return LAPACKE_zhseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacgv$descriptor() {
        return LAPACKE_clacgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_clacgv$handle() {
        return LAPACKE_clacgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_clacgv$address() {
        return LAPACKE_clacgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static int LAPACKE_clacgv(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_clacgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacgv", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacgv$descriptor() {
        return LAPACKE_zlacgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlacgv$handle() {
        return LAPACKE_zlacgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlacgv$address() {
        return LAPACKE_zlacgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static int LAPACKE_zlacgv(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_zlacgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacgv", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacn2$descriptor() {
        return LAPACKE_slacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_slacn2$handle() {
        return LAPACKE_slacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_slacn2$address() {
        return LAPACKE_slacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_slacn2(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_slacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacn2", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacn2$descriptor() {
        return LAPACKE_dlacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_dlacn2$handle() {
        return LAPACKE_dlacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_dlacn2$address() {
        return LAPACKE_dlacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_dlacn2(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_dlacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacn2", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacn2$descriptor() {
        return LAPACKE_clacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_clacn2$handle() {
        return LAPACKE_clacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_clacn2$address() {
        return LAPACKE_clacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_clacn2(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_clacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacn2", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacn2$descriptor() {
        return LAPACKE_zlacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_zlacn2$handle() {
        return LAPACKE_zlacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_zlacn2$address() {
        return LAPACKE_zlacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_zlacn2(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_zlacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacn2", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacpy$descriptor() {
        return LAPACKE_slacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_slacpy$handle() {
        return LAPACKE_slacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_slacpy$address() {
        return LAPACKE_slacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_slacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_slacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacpy$descriptor() {
        return LAPACKE_dlacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dlacpy$handle() {
        return LAPACKE_dlacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dlacpy$address() {
        return LAPACKE_dlacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dlacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dlacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacpy$descriptor() {
        return LAPACKE_clacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacpy$handle() {
        return LAPACKE_clacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacpy$address() {
        return LAPACKE_clacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacpy$descriptor() {
        return LAPACKE_zlacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacpy$handle() {
        return LAPACKE_zlacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacpy$address() {
        return LAPACKE_zlacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacp2$descriptor() {
        return LAPACKE_clacp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacp2$handle() {
        return LAPACKE_clacp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacp2$address() {
        return LAPACKE_clacp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacp2(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacp2", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacp2$descriptor() {
        return LAPACKE_zlacp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacp2$handle() {
        return LAPACKE_zlacp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacp2$address() {
        return LAPACKE_zlacp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacp2(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacp2", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlag2c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlag2c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlag2c$descriptor() {
        return LAPACKE_zlag2c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_zlag2c$handle() {
        return LAPACKE_zlag2c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_zlag2c$address() {
        return LAPACKE_zlag2c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_zlag2c(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_zlag2c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlag2c", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slag2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slag2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slag2d$descriptor() {
        return LAPACKE_slag2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slag2d$handle() {
        return LAPACKE_slag2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slag2d$address() {
        return LAPACKE_slag2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static int LAPACKE_slag2d(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slag2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slag2d", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlag2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlag2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlag2s$descriptor() {
        return LAPACKE_dlag2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_dlag2s$handle() {
        return LAPACKE_dlag2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_dlag2s$address() {
        return LAPACKE_dlag2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_dlag2s(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_dlag2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlag2s", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clag2z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clag2z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clag2z$descriptor() {
        return LAPACKE_clag2z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clag2z$handle() {
        return LAPACKE_clag2z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clag2z$address() {
        return LAPACKE_clag2z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_clag2z(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clag2z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clag2z", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagge$descriptor() {
        return LAPACKE_slagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_slagge$handle() {
        return LAPACKE_slagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_slagge$address() {
        return LAPACKE_slagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_slagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagge$descriptor() {
        return LAPACKE_dlagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_dlagge$handle() {
        return LAPACKE_dlagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_dlagge$address() {
        return LAPACKE_dlagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_dlagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagge$descriptor() {
        return LAPACKE_clagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_clagge$handle() {
        return LAPACKE_clagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_clagge$address() {
        return LAPACKE_clagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_clagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagge$descriptor() {
        return LAPACKE_zlagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlagge$handle() {
        return LAPACKE_zlagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlagge$address() {
        return LAPACKE_zlagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slamch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_CHAR
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slamch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_slamch$descriptor() {
        return LAPACKE_slamch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_slamch$handle() {
        return LAPACKE_slamch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_slamch$address() {
        return LAPACKE_slamch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static float LAPACKE_slamch(byte cmach) {
        var mh$ = LAPACKE_slamch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slamch", cmach);
            }
            return (float)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlamch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_CHAR
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlamch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlamch$descriptor() {
        return LAPACKE_dlamch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_dlamch$handle() {
        return LAPACKE_dlamch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_dlamch$address() {
        return LAPACKE_dlamch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static double LAPACKE_dlamch(byte cmach) {
        var mh$ = LAPACKE_dlamch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlamch", cmach);
            }
            return (double)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slange$descriptor() {
        return LAPACKE_slange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slange$handle() {
        return LAPACKE_slange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slange$address() {
        return LAPACKE_slange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slange", matrix_layout, norm, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlange$descriptor() {
        return LAPACKE_dlange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlange$handle() {
        return LAPACKE_dlange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlange$address() {
        return LAPACKE_dlange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlange", matrix_layout, norm, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clange$descriptor() {
        return LAPACKE_clange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clange$handle() {
        return LAPACKE_clange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clange$address() {
        return LAPACKE_clange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clange", matrix_layout, norm, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlange$descriptor() {
        return LAPACKE_zlange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlange$handle() {
        return LAPACKE_zlange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlange$address() {
        return LAPACKE_zlange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlange", matrix_layout, norm, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clanhe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clanhe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clanhe$descriptor() {
        return LAPACKE_clanhe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clanhe$handle() {
        return LAPACKE_clanhe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clanhe$address() {
        return LAPACKE_clanhe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clanhe(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clanhe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clanhe", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlanhe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlanhe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlanhe$descriptor() {
        return LAPACKE_zlanhe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlanhe$handle() {
        return LAPACKE_zlanhe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlanhe$address() {
        return LAPACKE_zlanhe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlanhe(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlanhe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlanhe", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacrm$descriptor() {
        return LAPACKE_clacrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clacrm$handle() {
        return LAPACKE_clacrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clacrm$address() {
        return LAPACKE_clacrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clacrm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clacrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacrm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacrm$descriptor() {
        return LAPACKE_zlacrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlacrm$handle() {
        return LAPACKE_zlacrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlacrm$address() {
        return LAPACKE_zlacrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlacrm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlacrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacrm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarcm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarcm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarcm$descriptor() {
        return LAPACKE_clarcm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clarcm$handle() {
        return LAPACKE_clarcm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clarcm$address() {
        return LAPACKE_clarcm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clarcm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clarcm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarcm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarcm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarcm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarcm$descriptor() {
        return LAPACKE_zlarcm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlarcm$handle() {
        return LAPACKE_zlarcm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlarcm$address() {
        return LAPACKE_zlarcm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlarcm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlarcm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarcm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slansy$descriptor() {
        return LAPACKE_slansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slansy$handle() {
        return LAPACKE_slansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slansy$address() {
        return LAPACKE_slansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlansy$descriptor() {
        return LAPACKE_dlansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlansy$handle() {
        return LAPACKE_dlansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlansy$address() {
        return LAPACKE_dlansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clansy$descriptor() {
        return LAPACKE_clansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clansy$handle() {
        return LAPACKE_clansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clansy$address() {
        return LAPACKE_clansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlansy$descriptor() {
        return LAPACKE_zlansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlansy$handle() {
        return LAPACKE_zlansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlansy$address() {
        return LAPACKE_zlansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slantr$descriptor() {
        return LAPACKE_slantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slantr$handle() {
        return LAPACKE_slantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slantr$address() {
        return LAPACKE_slantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlantr$descriptor() {
        return LAPACKE_dlantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlantr$handle() {
        return LAPACKE_dlantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlantr$address() {
        return LAPACKE_dlantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clantr$descriptor() {
        return LAPACKE_clantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clantr$handle() {
        return LAPACKE_clantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clantr$address() {
        return LAPACKE_clantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlantr$descriptor() {
        return LAPACKE_zlantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlantr$handle() {
        return LAPACKE_zlantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlantr$address() {
        return LAPACKE_zlantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfb$descriptor() {
        return LAPACKE_slarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_slarfb$handle() {
        return LAPACKE_slarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_slarfb$address() {
        return LAPACKE_slarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_slarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_slarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfb$descriptor() {
        return LAPACKE_dlarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dlarfb$handle() {
        return LAPACKE_dlarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dlarfb$address() {
        return LAPACKE_dlarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dlarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dlarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfb$descriptor() {
        return LAPACKE_clarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clarfb$handle() {
        return LAPACKE_clarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clarfb$address() {
        return LAPACKE_clarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfb$descriptor() {
        return LAPACKE_zlarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlarfb$handle() {
        return LAPACKE_zlarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlarfb$address() {
        return LAPACKE_zlarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfg$descriptor() {
        return LAPACKE_slarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_slarfg$handle() {
        return LAPACKE_slarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_slarfg$address() {
        return LAPACKE_slarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static int LAPACKE_slarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_slarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfg$descriptor() {
        return LAPACKE_dlarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dlarfg$handle() {
        return LAPACKE_dlarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dlarfg$address() {
        return LAPACKE_dlarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static int LAPACKE_dlarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_dlarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfg$descriptor() {
        return LAPACKE_clarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_clarfg$handle() {
        return LAPACKE_clarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_clarfg$address() {
        return LAPACKE_clarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static int LAPACKE_clarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_clarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfg$descriptor() {
        return LAPACKE_zlarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zlarfg$handle() {
        return LAPACKE_zlarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zlarfg$address() {
        return LAPACKE_zlarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zlarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_zlarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarft$descriptor() {
        return LAPACKE_slarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_slarft$handle() {
        return LAPACKE_slarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_slarft$address() {
        return LAPACKE_slarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static int LAPACKE_slarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_slarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarft$descriptor() {
        return LAPACKE_dlarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dlarft$handle() {
        return LAPACKE_dlarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dlarft$address() {
        return LAPACKE_dlarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dlarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dlarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarft$descriptor() {
        return LAPACKE_clarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_clarft$handle() {
        return LAPACKE_clarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_clarft$address() {
        return LAPACKE_clarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_clarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_clarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarft$descriptor() {
        return LAPACKE_zlarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zlarft$handle() {
        return LAPACKE_zlarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zlarft$address() {
        return LAPACKE_zlarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zlarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zlarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfx$descriptor() {
        return LAPACKE_slarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slarfx$handle() {
        return LAPACKE_slarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slarfx$address() {
        return LAPACKE_slarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_slarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_slarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfx$descriptor() {
        return LAPACKE_dlarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlarfx$handle() {
        return LAPACKE_dlarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlarfx$address() {
        return LAPACKE_dlarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dlarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dlarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfx$descriptor() {
        return LAPACKE_clarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarfx$handle() {
        return LAPACKE_clarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarfx$address() {
        return LAPACKE_clarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_clarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfx$descriptor() {
        return LAPACKE_zlarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarfx$handle() {
        return LAPACKE_zlarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarfx$address() {
        return LAPACKE_zlarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarnv$descriptor() {
        return LAPACKE_slarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MethodHandle LAPACKE_slarnv$handle() {
        return LAPACKE_slarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MemorySegment LAPACKE_slarnv$address() {
        return LAPACKE_slarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static int LAPACKE_slarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_slarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarnv$descriptor() {
        return LAPACKE_dlarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dlarnv$handle() {
        return LAPACKE_dlarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dlarnv$address() {
        return LAPACKE_dlarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static int LAPACKE_dlarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_dlarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarnv$descriptor() {
        return LAPACKE_clarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_clarnv$handle() {
        return LAPACKE_clarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_clarnv$address() {
        return LAPACKE_clarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static int LAPACKE_clarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_clarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarnv$descriptor() {
        return LAPACKE_zlarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zlarnv$handle() {
        return LAPACKE_zlarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zlarnv$address() {
        return LAPACKE_zlarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static int LAPACKE_zlarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_zlarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slascl$descriptor() {
        return LAPACKE_slascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slascl$handle() {
        return LAPACKE_slascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slascl$address() {
        return LAPACKE_slascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slascl(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlascl$descriptor() {
        return LAPACKE_dlascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlascl$handle() {
        return LAPACKE_dlascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlascl$address() {
        return LAPACKE_dlascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlascl(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clascl$descriptor() {
        return LAPACKE_clascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clascl$handle() {
        return LAPACKE_clascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clascl$address() {
        return LAPACKE_clascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clascl(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlascl$descriptor() {
        return LAPACKE_zlascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlascl$handle() {
        return LAPACKE_zlascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlascl$address() {
        return LAPACKE_zlascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlascl(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaset$descriptor() {
        return LAPACKE_slaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slaset$handle() {
        return LAPACKE_slaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slaset$address() {
        return LAPACKE_slaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static int LAPACKE_slaset(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaset$descriptor() {
        return LAPACKE_dlaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlaset$handle() {
        return LAPACKE_dlaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlaset$address() {
        return LAPACKE_dlaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlaset(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_claset$descriptor() {
        return LAPACKE_claset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_claset$handle() {
        return LAPACKE_claset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_claset$address() {
        return LAPACKE_claset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_claset(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_claset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaset$descriptor() {
        return LAPACKE_zlaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlaset$handle() {
        return LAPACKE_zlaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlaset$address() {
        return LAPACKE_zlaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlaset(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slasrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slasrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_slasrt$descriptor() {
        return LAPACKE_slasrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static MethodHandle LAPACKE_slasrt$handle() {
        return LAPACKE_slasrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static MemorySegment LAPACKE_slasrt$address() {
        return LAPACKE_slasrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static int LAPACKE_slasrt(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_slasrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slasrt", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlasrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlasrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlasrt$descriptor() {
        return LAPACKE_dlasrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static MethodHandle LAPACKE_dlasrt$handle() {
        return LAPACKE_dlasrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static MemorySegment LAPACKE_dlasrt$address() {
        return LAPACKE_dlasrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static int LAPACKE_dlasrt(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_dlasrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlasrt", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_slassq$descriptor() {
        return LAPACKE_slassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_slassq$handle() {
        return LAPACKE_slassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_slassq$address() {
        return LAPACKE_slassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_slassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_slassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlassq$descriptor() {
        return LAPACKE_dlassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_dlassq$handle() {
        return LAPACKE_dlassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_dlassq$address() {
        return LAPACKE_dlassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_dlassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_dlassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_classq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_classq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_classq$descriptor() {
        return LAPACKE_classq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_classq$handle() {
        return LAPACKE_classq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_classq$address() {
        return LAPACKE_classq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_classq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_classq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_classq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlassq$descriptor() {
        return LAPACKE_zlassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_zlassq$handle() {
        return LAPACKE_zlassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_zlassq$address() {
        return LAPACKE_zlassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_zlassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_zlassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaswp$descriptor() {
        return LAPACKE_slaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_slaswp$handle() {
        return LAPACKE_slaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_slaswp$address() {
        return LAPACKE_slaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_slaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_slaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaswp$descriptor() {
        return LAPACKE_dlaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_dlaswp$handle() {
        return LAPACKE_dlaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_dlaswp$address() {
        return LAPACKE_dlaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_dlaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_dlaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_claswp$descriptor() {
        return LAPACKE_claswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_claswp$handle() {
        return LAPACKE_claswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_claswp$address() {
        return LAPACKE_claswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_claswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_claswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaswp$descriptor() {
        return LAPACKE_zlaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlaswp$handle() {
        return LAPACKE_zlaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlaswp$address() {
        return LAPACKE_zlaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_zlaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_zlaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slatms$descriptor() {
        return LAPACKE_slatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slatms$handle() {
        return LAPACKE_slatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slatms$address() {
        return LAPACKE_slatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static int LAPACKE_slatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlatms$descriptor() {
        return LAPACKE_dlatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlatms$handle() {
        return LAPACKE_dlatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlatms$address() {
        return LAPACKE_dlatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clatms$descriptor() {
        return LAPACKE_clatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clatms$handle() {
        return LAPACKE_clatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clatms$address() {
        return LAPACKE_clatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlatms$descriptor() {
        return LAPACKE_zlatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlatms$handle() {
        return LAPACKE_zlatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlatms$address() {
        return LAPACKE_zlatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slauum$descriptor() {
        return LAPACKE_slauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slauum$handle() {
        return LAPACKE_slauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slauum$address() {
        return LAPACKE_slauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlauum$descriptor() {
        return LAPACKE_dlauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlauum$handle() {
        return LAPACKE_dlauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlauum$address() {
        return LAPACKE_dlauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clauum$descriptor() {
        return LAPACKE_clauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clauum$handle() {
        return LAPACKE_clauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clauum$address() {
        return LAPACKE_clauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlauum$descriptor() {
        return LAPACKE_zlauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlauum$handle() {
        return LAPACKE_zlauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlauum$address() {
        return LAPACKE_zlauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sopgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopgtr$descriptor() {
        return LAPACKE_sopgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sopgtr$handle() {
        return LAPACKE_sopgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sopgtr$address() {
        return LAPACKE_sopgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sopgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sopgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dopgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopgtr$descriptor() {
        return LAPACKE_dopgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dopgtr$handle() {
        return LAPACKE_dopgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dopgtr$address() {
        return LAPACKE_dopgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dopgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dopgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sopmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopmtr$descriptor() {
        return LAPACKE_sopmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sopmtr$handle() {
        return LAPACKE_sopmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sopmtr$address() {
        return LAPACKE_sopmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sopmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sopmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dopmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopmtr$descriptor() {
        return LAPACKE_dopmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dopmtr$handle() {
        return LAPACKE_dopmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dopmtr$address() {
        return LAPACKE_dopmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dopmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dopmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgbr$descriptor() {
        return LAPACKE_sorgbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgbr$handle() {
        return LAPACKE_sorgbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgbr$address() {
        return LAPACKE_sorgbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgbr$descriptor() {
        return LAPACKE_dorgbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgbr$handle() {
        return LAPACKE_dorgbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgbr$address() {
        return LAPACKE_dorgbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorghr$descriptor() {
        return LAPACKE_sorghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorghr$handle() {
        return LAPACKE_sorghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorghr$address() {
        return LAPACKE_sorghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorghr$descriptor() {
        return LAPACKE_dorghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorghr$handle() {
        return LAPACKE_dorghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorghr$address() {
        return LAPACKE_dorghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorglq$descriptor() {
        return LAPACKE_sorglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorglq$handle() {
        return LAPACKE_sorglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorglq$address() {
        return LAPACKE_sorglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorglq$descriptor() {
        return LAPACKE_dorglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorglq$handle() {
        return LAPACKE_dorglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorglq$address() {
        return LAPACKE_dorglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgql$descriptor() {
        return LAPACKE_sorgql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgql$handle() {
        return LAPACKE_sorgql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgql$address() {
        return LAPACKE_sorgql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgql$descriptor() {
        return LAPACKE_dorgql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgql$handle() {
        return LAPACKE_dorgql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgql$address() {
        return LAPACKE_dorgql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgqr$descriptor() {
        return LAPACKE_sorgqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgqr$handle() {
        return LAPACKE_sorgqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgqr$address() {
        return LAPACKE_sorgqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgqr$descriptor() {
        return LAPACKE_dorgqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgqr$handle() {
        return LAPACKE_dorgqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgqr$address() {
        return LAPACKE_dorgqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgrq$descriptor() {
        return LAPACKE_sorgrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgrq$handle() {
        return LAPACKE_sorgrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgrq$address() {
        return LAPACKE_sorgrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgrq$descriptor() {
        return LAPACKE_dorgrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgrq$handle() {
        return LAPACKE_dorgrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgrq$address() {
        return LAPACKE_dorgrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtr$descriptor() {
        return LAPACKE_sorgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgtr$handle() {
        return LAPACKE_sorgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgtr$address() {
        return LAPACKE_sorgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtr$descriptor() {
        return LAPACKE_dorgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgtr$handle() {
        return LAPACKE_dorgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgtr$address() {
        return LAPACKE_dorgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtsqr_row$descriptor() {
        return LAPACKE_sorgtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sorgtsqr_row$handle() {
        return LAPACKE_sorgtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sorgtsqr_row$address() {
        return LAPACKE_sorgtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sorgtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtsqr_row$descriptor() {
        return LAPACKE_dorgtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dorgtsqr_row$handle() {
        return LAPACKE_dorgtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dorgtsqr_row$address() {
        return LAPACKE_dorgtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dorgtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormbr$descriptor() {
        return LAPACKE_sormbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormbr$handle() {
        return LAPACKE_sormbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormbr$address() {
        return LAPACKE_sormbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormbr$descriptor() {
        return LAPACKE_dormbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormbr$handle() {
        return LAPACKE_dormbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormbr$address() {
        return LAPACKE_dormbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormhr$descriptor() {
        return LAPACKE_sormhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormhr$handle() {
        return LAPACKE_sormhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormhr$address() {
        return LAPACKE_sormhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormhr$descriptor() {
        return LAPACKE_dormhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormhr$handle() {
        return LAPACKE_dormhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormhr$address() {
        return LAPACKE_dormhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormlq$descriptor() {
        return LAPACKE_sormlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormlq$handle() {
        return LAPACKE_sormlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormlq$address() {
        return LAPACKE_sormlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormlq$descriptor() {
        return LAPACKE_dormlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormlq$handle() {
        return LAPACKE_dormlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormlq$address() {
        return LAPACKE_dormlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormql$descriptor() {
        return LAPACKE_sormql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormql$handle() {
        return LAPACKE_sormql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormql$address() {
        return LAPACKE_sormql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormql$descriptor() {
        return LAPACKE_dormql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormql$handle() {
        return LAPACKE_dormql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormql$address() {
        return LAPACKE_dormql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormqr$descriptor() {
        return LAPACKE_sormqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormqr$handle() {
        return LAPACKE_sormqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormqr$address() {
        return LAPACKE_sormqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormqr$descriptor() {
        return LAPACKE_dormqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormqr$handle() {
        return LAPACKE_dormqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormqr$address() {
        return LAPACKE_dormqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrq$descriptor() {
        return LAPACKE_sormrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormrq$handle() {
        return LAPACKE_sormrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormrq$address() {
        return LAPACKE_sormrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrq$descriptor() {
        return LAPACKE_dormrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormrq$handle() {
        return LAPACKE_dormrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormrq$address() {
        return LAPACKE_dormrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrz$descriptor() {
        return LAPACKE_sormrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormrz$handle() {
        return LAPACKE_sormrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormrz$address() {
        return LAPACKE_sormrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrz$descriptor() {
        return LAPACKE_dormrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormrz$handle() {
        return LAPACKE_dormrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormrz$address() {
        return LAPACKE_dormrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormtr$descriptor() {
        return LAPACKE_sormtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormtr$handle() {
        return LAPACKE_sormtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormtr$address() {
        return LAPACKE_sormtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormtr$descriptor() {
        return LAPACKE_dormtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormtr$handle() {
        return LAPACKE_dormtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormtr$address() {
        return LAPACKE_dormtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbcon$descriptor() {
        return LAPACKE_spbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_spbcon$handle() {
        return LAPACKE_spbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_spbcon$address() {
        return LAPACKE_spbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_spbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_spbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbcon$descriptor() {
        return LAPACKE_dpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dpbcon$handle() {
        return LAPACKE_dpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dpbcon$address() {
        return LAPACKE_dpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbcon$descriptor() {
        return LAPACKE_cpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cpbcon$handle() {
        return LAPACKE_cpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cpbcon$address() {
        return LAPACKE_cpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbcon$descriptor() {
        return LAPACKE_zpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zpbcon$handle() {
        return LAPACKE_zpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zpbcon$address() {
        return LAPACKE_zpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbequ$descriptor() {
        return LAPACKE_spbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spbequ$handle() {
        return LAPACKE_spbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spbequ$address() {
        return LAPACKE_spbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbequ$descriptor() {
        return LAPACKE_dpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpbequ$handle() {
        return LAPACKE_dpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpbequ$address() {
        return LAPACKE_dpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbequ$descriptor() {
        return LAPACKE_cpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpbequ$handle() {
        return LAPACKE_cpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpbequ$address() {
        return LAPACKE_cpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbequ$descriptor() {
        return LAPACKE_zpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpbequ$handle() {
        return LAPACKE_zpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpbequ$address() {
        return LAPACKE_zpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbrfs$descriptor() {
        return LAPACKE_spbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spbrfs$handle() {
        return LAPACKE_spbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spbrfs$address() {
        return LAPACKE_spbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbrfs$descriptor() {
        return LAPACKE_dpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpbrfs$handle() {
        return LAPACKE_dpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpbrfs$address() {
        return LAPACKE_dpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbrfs$descriptor() {
        return LAPACKE_cpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpbrfs$handle() {
        return LAPACKE_cpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpbrfs$address() {
        return LAPACKE_cpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbrfs$descriptor() {
        return LAPACKE_zpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpbrfs$handle() {
        return LAPACKE_zpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpbrfs$address() {
        return LAPACKE_zpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbstf$descriptor() {
        return LAPACKE_spbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_spbstf$handle() {
        return LAPACKE_spbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_spbstf$address() {
        return LAPACKE_spbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_spbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_spbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbstf$descriptor() {
        return LAPACKE_dpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_dpbstf$handle() {
        return LAPACKE_dpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_dpbstf$address() {
        return LAPACKE_dpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_dpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_dpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbstf$descriptor() {
        return LAPACKE_cpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_cpbstf$handle() {
        return LAPACKE_cpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_cpbstf$address() {
        return LAPACKE_cpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_cpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_cpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbstf$descriptor() {
        return LAPACKE_zpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_zpbstf$handle() {
        return LAPACKE_zpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_zpbstf$address() {
        return LAPACKE_zpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_zpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_zpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsv$descriptor() {
        return LAPACKE_spbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbsv$handle() {
        return LAPACKE_spbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbsv$address() {
        return LAPACKE_spbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsv$descriptor() {
        return LAPACKE_dpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbsv$handle() {
        return LAPACKE_dpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbsv$address() {
        return LAPACKE_dpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsv$descriptor() {
        return LAPACKE_cpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbsv$handle() {
        return LAPACKE_cpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbsv$address() {
        return LAPACKE_cpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsv$descriptor() {
        return LAPACKE_zpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbsv$handle() {
        return LAPACKE_zpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbsv$address() {
        return LAPACKE_zpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsvx$descriptor() {
        return LAPACKE_spbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spbsvx$handle() {
        return LAPACKE_spbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spbsvx$address() {
        return LAPACKE_spbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsvx$descriptor() {
        return LAPACKE_dpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpbsvx$handle() {
        return LAPACKE_dpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpbsvx$address() {
        return LAPACKE_dpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsvx$descriptor() {
        return LAPACKE_cpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpbsvx$handle() {
        return LAPACKE_cpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpbsvx$address() {
        return LAPACKE_cpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsvx$descriptor() {
        return LAPACKE_zpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpbsvx$handle() {
        return LAPACKE_zpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpbsvx$address() {
        return LAPACKE_zpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrf$descriptor() {
        return LAPACKE_spbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_spbtrf$handle() {
        return LAPACKE_spbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_spbtrf$address() {
        return LAPACKE_spbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static int LAPACKE_spbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_spbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrf$descriptor() {
        return LAPACKE_dpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrf$handle() {
        return LAPACKE_dpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrf$address() {
        return LAPACKE_dpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static int LAPACKE_dpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_dpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrf$descriptor() {
        return LAPACKE_cpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrf$handle() {
        return LAPACKE_cpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrf$address() {
        return LAPACKE_cpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static int LAPACKE_cpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_cpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrf$descriptor() {
        return LAPACKE_zpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrf$handle() {
        return LAPACKE_zpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrf$address() {
        return LAPACKE_zpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static int LAPACKE_zpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_zpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrs$descriptor() {
        return LAPACKE_spbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbtrs$handle() {
        return LAPACKE_spbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbtrs$address() {
        return LAPACKE_spbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrs$descriptor() {
        return LAPACKE_dpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrs$handle() {
        return LAPACKE_dpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrs$address() {
        return LAPACKE_dpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrs$descriptor() {
        return LAPACKE_cpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrs$handle() {
        return LAPACKE_cpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrs$address() {
        return LAPACKE_cpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrs$descriptor() {
        return LAPACKE_zpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrs$handle() {
        return LAPACKE_zpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrs$address() {
        return LAPACKE_zpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrf$descriptor() {
        return LAPACKE_spftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftrf$handle() {
        return LAPACKE_spftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftrf$address() {
        return LAPACKE_spftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrf$descriptor() {
        return LAPACKE_dpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftrf$handle() {
        return LAPACKE_dpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftrf$address() {
        return LAPACKE_dpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrf$descriptor() {
        return LAPACKE_cpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftrf$handle() {
        return LAPACKE_cpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftrf$address() {
        return LAPACKE_cpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrf$descriptor() {
        return LAPACKE_zpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftrf$handle() {
        return LAPACKE_zpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftrf$address() {
        return LAPACKE_zpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftri$descriptor() {
        return LAPACKE_spftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftri$handle() {
        return LAPACKE_spftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftri$address() {
        return LAPACKE_spftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftri$descriptor() {
        return LAPACKE_dpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftri$handle() {
        return LAPACKE_dpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftri$address() {
        return LAPACKE_dpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftri$descriptor() {
        return LAPACKE_cpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftri$handle() {
        return LAPACKE_cpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftri$address() {
        return LAPACKE_cpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftri$descriptor() {
        return LAPACKE_zpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftri$handle() {
        return LAPACKE_zpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftri$address() {
        return LAPACKE_zpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrs$descriptor() {
        return LAPACKE_spftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spftrs$handle() {
        return LAPACKE_spftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spftrs$address() {
        return LAPACKE_spftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrs$descriptor() {
        return LAPACKE_dpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpftrs$handle() {
        return LAPACKE_dpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpftrs$address() {
        return LAPACKE_dpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrs$descriptor() {
        return LAPACKE_cpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpftrs$handle() {
        return LAPACKE_cpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpftrs$address() {
        return LAPACKE_cpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrs$descriptor() {
        return LAPACKE_zpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpftrs$handle() {
        return LAPACKE_zpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpftrs$address() {
        return LAPACKE_zpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_spocon$descriptor() {
        return LAPACKE_spocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_spocon$handle() {
        return LAPACKE_spocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_spocon$address() {
        return LAPACKE_spocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_spocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_spocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpocon$descriptor() {
        return LAPACKE_dpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dpocon$handle() {
        return LAPACKE_dpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dpocon$address() {
        return LAPACKE_dpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpocon$descriptor() {
        return LAPACKE_cpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cpocon$handle() {
        return LAPACKE_cpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cpocon$address() {
        return LAPACKE_cpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpocon$descriptor() {
        return LAPACKE_zpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zpocon$handle() {
        return LAPACKE_zpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zpocon$address() {
        return LAPACKE_zpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequ$descriptor() {
        return LAPACKE_spoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequ$handle() {
        return LAPACKE_spoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequ$address() {
        return LAPACKE_spoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequ$descriptor() {
        return LAPACKE_dpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequ$handle() {
        return LAPACKE_dpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequ$address() {
        return LAPACKE_dpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequ$descriptor() {
        return LAPACKE_cpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequ$handle() {
        return LAPACKE_cpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequ$address() {
        return LAPACKE_cpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequ$descriptor() {
        return LAPACKE_zpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequ$handle() {
        return LAPACKE_zpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequ$address() {
        return LAPACKE_zpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequb$descriptor() {
        return LAPACKE_spoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequb$handle() {
        return LAPACKE_spoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequb$address() {
        return LAPACKE_spoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequb$descriptor() {
        return LAPACKE_dpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequb$handle() {
        return LAPACKE_dpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequb$address() {
        return LAPACKE_dpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequb$descriptor() {
        return LAPACKE_cpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequb$handle() {
        return LAPACKE_cpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequb$address() {
        return LAPACKE_cpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequb$descriptor() {
        return LAPACKE_zpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequb$handle() {
        return LAPACKE_zpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequb$address() {
        return LAPACKE_zpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfs$descriptor() {
        return LAPACKE_sporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sporfs$handle() {
        return LAPACKE_sporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sporfs$address() {
        return LAPACKE_sporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfs$descriptor() {
        return LAPACKE_dporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dporfs$handle() {
        return LAPACKE_dporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dporfs$address() {
        return LAPACKE_dporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfs$descriptor() {
        return LAPACKE_cporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cporfs$handle() {
        return LAPACKE_cporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cporfs$address() {
        return LAPACKE_cporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfs$descriptor() {
        return LAPACKE_zporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zporfs$handle() {
        return LAPACKE_zporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zporfs$address() {
        return LAPACKE_zporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfsx$descriptor() {
        return LAPACKE_sporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sporfsx$handle() {
        return LAPACKE_sporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sporfsx$address() {
        return LAPACKE_sporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfsx$descriptor() {
        return LAPACKE_dporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dporfsx$handle() {
        return LAPACKE_dporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dporfsx$address() {
        return LAPACKE_dporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfsx$descriptor() {
        return LAPACKE_cporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cporfsx$handle() {
        return LAPACKE_cporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cporfsx$address() {
        return LAPACKE_cporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfsx$descriptor() {
        return LAPACKE_zporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zporfsx$handle() {
        return LAPACKE_zporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zporfsx$address() {
        return LAPACKE_zporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposv$descriptor() {
        return LAPACKE_sposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sposv$handle() {
        return LAPACKE_sposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sposv$address() {
        return LAPACKE_sposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposv$descriptor() {
        return LAPACKE_dposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dposv$handle() {
        return LAPACKE_dposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dposv$address() {
        return LAPACKE_dposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposv$descriptor() {
        return LAPACKE_cposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cposv$handle() {
        return LAPACKE_cposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cposv$address() {
        return LAPACKE_cposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposv$descriptor() {
        return LAPACKE_zposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zposv$handle() {
        return LAPACKE_zposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zposv$address() {
        return LAPACKE_zposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsposv$descriptor() {
        return LAPACKE_dsposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsposv$handle() {
        return LAPACKE_dsposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsposv$address() {
        return LAPACKE_dsposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_dsposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_dsposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zcposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcposv$descriptor() {
        return LAPACKE_zcposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcposv$handle() {
        return LAPACKE_zcposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcposv$address() {
        return LAPACKE_zcposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_zcposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_zcposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvx$descriptor() {
        return LAPACKE_sposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sposvx$handle() {
        return LAPACKE_sposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sposvx$address() {
        return LAPACKE_sposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvx$descriptor() {
        return LAPACKE_dposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dposvx$handle() {
        return LAPACKE_dposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dposvx$address() {
        return LAPACKE_dposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvx$descriptor() {
        return LAPACKE_cposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cposvx$handle() {
        return LAPACKE_cposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cposvx$address() {
        return LAPACKE_cposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvx$descriptor() {
        return LAPACKE_zposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zposvx$handle() {
        return LAPACKE_zposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zposvx$address() {
        return LAPACKE_zposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvxx$descriptor() {
        return LAPACKE_sposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sposvxx$handle() {
        return LAPACKE_sposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sposvxx$address() {
        return LAPACKE_sposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvxx$descriptor() {
        return LAPACKE_dposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dposvxx$handle() {
        return LAPACKE_dposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dposvxx$address() {
        return LAPACKE_dposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvxx$descriptor() {
        return LAPACKE_cposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cposvxx$handle() {
        return LAPACKE_cposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cposvxx$address() {
        return LAPACKE_cposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvxx$descriptor() {
        return LAPACKE_zposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zposvxx$handle() {
        return LAPACKE_zposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zposvxx$address() {
        return LAPACKE_zposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf2$descriptor() {
        return LAPACKE_spotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf2$handle() {
        return LAPACKE_spotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf2$address() {
        return LAPACKE_spotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf2$descriptor() {
        return LAPACKE_dpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf2$handle() {
        return LAPACKE_dpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf2$address() {
        return LAPACKE_dpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf2$descriptor() {
        return LAPACKE_cpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf2$handle() {
        return LAPACKE_cpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf2$address() {
        return LAPACKE_cpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf2$descriptor() {
        return LAPACKE_zpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf2$handle() {
        return LAPACKE_zpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf2$address() {
        return LAPACKE_zpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf$descriptor() {
        return LAPACKE_spotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf$handle() {
        return LAPACKE_spotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf$address() {
        return LAPACKE_spotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf$descriptor() {
        return LAPACKE_dpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf$handle() {
        return LAPACKE_dpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf$address() {
        return LAPACKE_dpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf$descriptor() {
        return LAPACKE_cpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf$handle() {
        return LAPACKE_cpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf$address() {
        return LAPACKE_cpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf$descriptor() {
        return LAPACKE_zpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf$handle() {
        return LAPACKE_zpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf$address() {
        return LAPACKE_zpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotri$descriptor() {
        return LAPACKE_spotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotri$handle() {
        return LAPACKE_spotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotri$address() {
        return LAPACKE_spotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotri$descriptor() {
        return LAPACKE_dpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotri$handle() {
        return LAPACKE_dpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotri$address() {
        return LAPACKE_dpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotri$descriptor() {
        return LAPACKE_cpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotri$handle() {
        return LAPACKE_cpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotri$address() {
        return LAPACKE_cpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotri$descriptor() {
        return LAPACKE_zpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotri$handle() {
        return LAPACKE_zpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotri$address() {
        return LAPACKE_zpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrs$descriptor() {
        return LAPACKE_spotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spotrs$handle() {
        return LAPACKE_spotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spotrs$address() {
        return LAPACKE_spotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrs$descriptor() {
        return LAPACKE_dpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpotrs$handle() {
        return LAPACKE_dpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpotrs$address() {
        return LAPACKE_dpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrs$descriptor() {
        return LAPACKE_cpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpotrs$handle() {
        return LAPACKE_cpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpotrs$address() {
        return LAPACKE_cpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrs$descriptor() {
        return LAPACKE_zpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpotrs$handle() {
        return LAPACKE_zpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpotrs$address() {
        return LAPACKE_zpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppcon$descriptor() {
        return LAPACKE_sppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sppcon$handle() {
        return LAPACKE_sppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sppcon$address() {
        return LAPACKE_sppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppcon$descriptor() {
        return LAPACKE_dppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dppcon$handle() {
        return LAPACKE_dppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dppcon$address() {
        return LAPACKE_dppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppcon$descriptor() {
        return LAPACKE_cppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cppcon$handle() {
        return LAPACKE_cppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cppcon$address() {
        return LAPACKE_cppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppcon$descriptor() {
        return LAPACKE_zppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zppcon$handle() {
        return LAPACKE_zppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zppcon$address() {
        return LAPACKE_zppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppequ$descriptor() {
        return LAPACKE_sppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sppequ$handle() {
        return LAPACKE_sppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sppequ$address() {
        return LAPACKE_sppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_sppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_sppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppequ$descriptor() {
        return LAPACKE_dppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dppequ$handle() {
        return LAPACKE_dppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dppequ$address() {
        return LAPACKE_dppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppequ$descriptor() {
        return LAPACKE_cppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cppequ$handle() {
        return LAPACKE_cppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cppequ$address() {
        return LAPACKE_cppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppequ$descriptor() {
        return LAPACKE_zppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zppequ$handle() {
        return LAPACKE_zppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zppequ$address() {
        return LAPACKE_zppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spprfs$descriptor() {
        return LAPACKE_spprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spprfs$handle() {
        return LAPACKE_spprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spprfs$address() {
        return LAPACKE_spprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpprfs$descriptor() {
        return LAPACKE_dpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpprfs$handle() {
        return LAPACKE_dpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpprfs$address() {
        return LAPACKE_dpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpprfs$descriptor() {
        return LAPACKE_cpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpprfs$handle() {
        return LAPACKE_cpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpprfs$address() {
        return LAPACKE_cpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpprfs$descriptor() {
        return LAPACKE_zpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpprfs$handle() {
        return LAPACKE_zpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpprfs$address() {
        return LAPACKE_zpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsv$descriptor() {
        return LAPACKE_sppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sppsv$handle() {
        return LAPACKE_sppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sppsv$address() {
        return LAPACKE_sppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsv$descriptor() {
        return LAPACKE_dppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dppsv$handle() {
        return LAPACKE_dppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dppsv$address() {
        return LAPACKE_dppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsv$descriptor() {
        return LAPACKE_cppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cppsv$handle() {
        return LAPACKE_cppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cppsv$address() {
        return LAPACKE_cppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsv$descriptor() {
        return LAPACKE_zppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zppsv$handle() {
        return LAPACKE_zppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zppsv$address() {
        return LAPACKE_zppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsvx$descriptor() {
        return LAPACKE_sppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sppsvx$handle() {
        return LAPACKE_sppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sppsvx$address() {
        return LAPACKE_sppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsvx$descriptor() {
        return LAPACKE_dppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dppsvx$handle() {
        return LAPACKE_dppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dppsvx$address() {
        return LAPACKE_dppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsvx$descriptor() {
        return LAPACKE_cppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cppsvx$handle() {
        return LAPACKE_cppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cppsvx$address() {
        return LAPACKE_cppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsvx$descriptor() {
        return LAPACKE_zppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zppsvx$handle() {
        return LAPACKE_zppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zppsvx$address() {
        return LAPACKE_zppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrf$descriptor() {
        return LAPACKE_spptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptrf$handle() {
        return LAPACKE_spptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptrf$address() {
        return LAPACKE_spptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrf$descriptor() {
        return LAPACKE_dpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptrf$handle() {
        return LAPACKE_dpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptrf$address() {
        return LAPACKE_dpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrf$descriptor() {
        return LAPACKE_cpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptrf$handle() {
        return LAPACKE_cpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptrf$address() {
        return LAPACKE_cpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrf$descriptor() {
        return LAPACKE_zpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptrf$handle() {
        return LAPACKE_zpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptrf$address() {
        return LAPACKE_zpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptri$descriptor() {
        return LAPACKE_spptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptri$handle() {
        return LAPACKE_spptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptri$address() {
        return LAPACKE_spptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptri$descriptor() {
        return LAPACKE_dpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptri$handle() {
        return LAPACKE_dpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptri$address() {
        return LAPACKE_dpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptri$descriptor() {
        return LAPACKE_cpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptri$handle() {
        return LAPACKE_cpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptri$address() {
        return LAPACKE_cpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptri$descriptor() {
        return LAPACKE_zpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptri$handle() {
        return LAPACKE_zpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptri$address() {
        return LAPACKE_zpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrs$descriptor() {
        return LAPACKE_spptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spptrs$handle() {
        return LAPACKE_spptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spptrs$address() {
        return LAPACKE_spptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrs$descriptor() {
        return LAPACKE_dpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpptrs$handle() {
        return LAPACKE_dpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpptrs$address() {
        return LAPACKE_dpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrs$descriptor() {
        return LAPACKE_cpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpptrs$handle() {
        return LAPACKE_cpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpptrs$address() {
        return LAPACKE_cpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrs$descriptor() {
        return LAPACKE_zpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpptrs$handle() {
        return LAPACKE_zpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpptrs$address() {
        return LAPACKE_zpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_spstrf$descriptor() {
        return LAPACKE_spstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MethodHandle LAPACKE_spstrf$handle() {
        return LAPACKE_spstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MemorySegment LAPACKE_spstrf$address() {
        return LAPACKE_spstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static int LAPACKE_spstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol) {
        var mh$ = LAPACKE_spstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpstrf$descriptor() {
        return LAPACKE_dpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MethodHandle LAPACKE_dpstrf$handle() {
        return LAPACKE_dpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MemorySegment LAPACKE_dpstrf$address() {
        return LAPACKE_dpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static int LAPACKE_dpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol) {
        var mh$ = LAPACKE_dpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpstrf$descriptor() {
        return LAPACKE_cpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MethodHandle LAPACKE_cpstrf$handle() {
        return LAPACKE_cpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MemorySegment LAPACKE_cpstrf$address() {
        return LAPACKE_cpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static int LAPACKE_cpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol) {
        var mh$ = LAPACKE_cpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpstrf$descriptor() {
        return LAPACKE_zpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MethodHandle LAPACKE_zpstrf$handle() {
        return LAPACKE_zpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MemorySegment LAPACKE_zpstrf$address() {
        return LAPACKE_zpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static int LAPACKE_zpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol) {
        var mh$ = LAPACKE_zpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptcon$descriptor() {
        return LAPACKE_sptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sptcon$handle() {
        return LAPACKE_sptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sptcon$address() {
        return LAPACKE_sptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sptcon(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptcon$descriptor() {
        return LAPACKE_dptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dptcon$handle() {
        return LAPACKE_dptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dptcon$address() {
        return LAPACKE_dptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dptcon(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptcon$descriptor() {
        return LAPACKE_cptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cptcon$handle() {
        return LAPACKE_cptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cptcon$address() {
        return LAPACKE_cptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cptcon(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptcon$descriptor() {
        return LAPACKE_zptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zptcon$handle() {
        return LAPACKE_zptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zptcon$address() {
        return LAPACKE_zptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zptcon(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_spteqr$descriptor() {
        return LAPACKE_spteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_spteqr$handle() {
        return LAPACKE_spteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_spteqr$address() {
        return LAPACKE_spteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_spteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_spteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpteqr$descriptor() {
        return LAPACKE_dpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dpteqr$handle() {
        return LAPACKE_dpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dpteqr$address() {
        return LAPACKE_dpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpteqr$descriptor() {
        return LAPACKE_cpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cpteqr$handle() {
        return LAPACKE_cpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cpteqr$address() {
        return LAPACKE_cpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpteqr$descriptor() {
        return LAPACKE_zpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zpteqr$handle() {
        return LAPACKE_zpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zpteqr$address() {
        return LAPACKE_zpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptrfs$descriptor() {
        return LAPACKE_sptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sptrfs$handle() {
        return LAPACKE_sptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sptrfs$address() {
        return LAPACKE_sptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptrfs", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptrfs$descriptor() {
        return LAPACKE_dptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dptrfs$handle() {
        return LAPACKE_dptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dptrfs$address() {
        return LAPACKE_dptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptrfs", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptrfs$descriptor() {
        return LAPACKE_cptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cptrfs$handle() {
        return LAPACKE_cptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cptrfs$address() {
        return LAPACKE_cptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cptrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptrfs", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptrfs$descriptor() {
        return LAPACKE_zptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zptrfs$handle() {
        return LAPACKE_zptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zptrfs$address() {
        return LAPACKE_zptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zptrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptrfs", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsv$descriptor() {
        return LAPACKE_sptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sptsv$handle() {
        return LAPACKE_sptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sptsv$address() {
        return LAPACKE_sptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsv$descriptor() {
        return LAPACKE_dptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dptsv$handle() {
        return LAPACKE_dptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dptsv$address() {
        return LAPACKE_dptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsv$descriptor() {
        return LAPACKE_cptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cptsv$handle() {
        return LAPACKE_cptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cptsv$address() {
        return LAPACKE_cptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsv$descriptor() {
        return LAPACKE_zptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zptsv$handle() {
        return LAPACKE_zptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zptsv$address() {
        return LAPACKE_zptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsvx$descriptor() {
        return LAPACKE_sptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sptsvx$handle() {
        return LAPACKE_sptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sptsvx$address() {
        return LAPACKE_sptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsvx$descriptor() {
        return LAPACKE_dptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dptsvx$handle() {
        return LAPACKE_dptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dptsvx$address() {
        return LAPACKE_dptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsvx$descriptor() {
        return LAPACKE_cptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cptsvx$handle() {
        return LAPACKE_cptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cptsvx$address() {
        return LAPACKE_cptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsvx$descriptor() {
        return LAPACKE_zptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zptsvx$handle() {
        return LAPACKE_zptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zptsvx$address() {
        return LAPACKE_zptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrf$descriptor() {
        return LAPACKE_spttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_spttrf$handle() {
        return LAPACKE_spttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_spttrf$address() {
        return LAPACKE_spttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_spttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_spttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrf$descriptor() {
        return LAPACKE_dpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dpttrf$handle() {
        return LAPACKE_dpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dpttrf$address() {
        return LAPACKE_dpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrf$descriptor() {
        return LAPACKE_cpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_cpttrf$handle() {
        return LAPACKE_cpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_cpttrf$address() {
        return LAPACKE_cpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static int LAPACKE_cpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_cpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrf$descriptor() {
        return LAPACKE_zpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zpttrf$handle() {
        return LAPACKE_zpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zpttrf$address() {
        return LAPACKE_zpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static int LAPACKE_zpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_zpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrs$descriptor() {
        return LAPACKE_spttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spttrs$handle() {
        return LAPACKE_spttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spttrs$address() {
        return LAPACKE_spttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrs", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrs$descriptor() {
        return LAPACKE_dpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpttrs$handle() {
        return LAPACKE_dpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpttrs$address() {
        return LAPACKE_dpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrs", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrs$descriptor() {
        return LAPACKE_cpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpttrs$handle() {
        return LAPACKE_cpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpttrs$address() {
        return LAPACKE_cpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpttrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrs", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrs$descriptor() {
        return LAPACKE_zpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpttrs$handle() {
        return LAPACKE_zpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpttrs$address() {
        return LAPACKE_zpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpttrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrs", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev$descriptor() {
        return LAPACKE_ssbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbev$handle() {
        return LAPACKE_ssbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbev$address() {
        return LAPACKE_ssbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev$descriptor() {
        return LAPACKE_dsbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbev$handle() {
        return LAPACKE_dsbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbev$address() {
        return LAPACKE_dsbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd$descriptor() {
        return LAPACKE_ssbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd$handle() {
        return LAPACKE_ssbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd$address() {
        return LAPACKE_ssbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd$descriptor() {
        return LAPACKE_dsbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd$handle() {
        return LAPACKE_dsbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd$address() {
        return LAPACKE_dsbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx$descriptor() {
        return LAPACKE_ssbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx$handle() {
        return LAPACKE_ssbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx$address() {
        return LAPACKE_ssbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx$descriptor() {
        return LAPACKE_dsbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx$handle() {
        return LAPACKE_dsbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx$address() {
        return LAPACKE_dsbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgst$descriptor() {
        return LAPACKE_ssbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_ssbgst$handle() {
        return LAPACKE_ssbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_ssbgst$address() {
        return LAPACKE_ssbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static int LAPACKE_ssbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_ssbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgst$descriptor() {
        return LAPACKE_dsbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_dsbgst$handle() {
        return LAPACKE_dsbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_dsbgst$address() {
        return LAPACKE_dsbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static int LAPACKE_dsbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_dsbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgv$descriptor() {
        return LAPACKE_ssbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbgv$handle() {
        return LAPACKE_ssbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbgv$address() {
        return LAPACKE_ssbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgv$descriptor() {
        return LAPACKE_dsbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbgv$handle() {
        return LAPACKE_dsbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbgv$address() {
        return LAPACKE_dsbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvd$descriptor() {
        return LAPACKE_ssbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvd$handle() {
        return LAPACKE_ssbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvd$address() {
        return LAPACKE_ssbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvd$descriptor() {
        return LAPACKE_dsbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvd$handle() {
        return LAPACKE_dsbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvd$address() {
        return LAPACKE_dsbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvx$descriptor() {
        return LAPACKE_ssbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvx$handle() {
        return LAPACKE_ssbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvx$address() {
        return LAPACKE_ssbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvx$descriptor() {
        return LAPACKE_dsbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvx$handle() {
        return LAPACKE_dsbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvx$address() {
        return LAPACKE_dsbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbtrd$descriptor() {
        return LAPACKE_ssbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_ssbtrd$handle() {
        return LAPACKE_ssbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_ssbtrd$address() {
        return LAPACKE_ssbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static int LAPACKE_ssbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_ssbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbtrd$descriptor() {
        return LAPACKE_dsbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dsbtrd$handle() {
        return LAPACKE_dsbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dsbtrd$address() {
        return LAPACKE_dsbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dsbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dsbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssfrk$descriptor() {
        return LAPACKE_ssfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MethodHandle LAPACKE_ssfrk$handle() {
        return LAPACKE_ssfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MemorySegment LAPACKE_ssfrk$address() {
        return LAPACKE_ssfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static int LAPACKE_ssfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_ssfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsfrk$descriptor() {
        return LAPACKE_dsfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MethodHandle LAPACKE_dsfrk$handle() {
        return LAPACKE_dsfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MemorySegment LAPACKE_dsfrk$address() {
        return LAPACKE_dsfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static int LAPACKE_dsfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_dsfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspcon$descriptor() {
        return LAPACKE_sspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sspcon$handle() {
        return LAPACKE_sspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sspcon$address() {
        return LAPACKE_sspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspcon$descriptor() {
        return LAPACKE_dspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dspcon$handle() {
        return LAPACKE_dspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dspcon$address() {
        return LAPACKE_dspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspcon$descriptor() {
        return LAPACKE_cspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cspcon$handle() {
        return LAPACKE_cspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cspcon$address() {
        return LAPACKE_cspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspcon$descriptor() {
        return LAPACKE_zspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zspcon$handle() {
        return LAPACKE_zspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zspcon$address() {
        return LAPACKE_zspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspev$descriptor() {
        return LAPACKE_sspev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspev$handle() {
        return LAPACKE_sspev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspev$address() {
        return LAPACKE_sspev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspev$descriptor() {
        return LAPACKE_dspev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspev$handle() {
        return LAPACKE_dspev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspev$address() {
        return LAPACKE_dspev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevd$descriptor() {
        return LAPACKE_sspevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspevd$handle() {
        return LAPACKE_sspevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspevd$address() {
        return LAPACKE_sspevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevd$descriptor() {
        return LAPACKE_dspevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspevd$handle() {
        return LAPACKE_dspevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspevd$address() {
        return LAPACKE_dspevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevx$descriptor() {
        return LAPACKE_sspevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspevx$handle() {
        return LAPACKE_sspevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspevx$address() {
        return LAPACKE_sspevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sspevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sspevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevx$descriptor() {
        return LAPACKE_dspevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspevx$handle() {
        return LAPACKE_dspevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspevx$address() {
        return LAPACKE_dspevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dspevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dspevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgst$descriptor() {
        return LAPACKE_sspgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MethodHandle LAPACKE_sspgst$handle() {
        return LAPACKE_sspgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MemorySegment LAPACKE_sspgst$address() {
        return LAPACKE_sspgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static int LAPACKE_sspgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_sspgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgst$descriptor() {
        return LAPACKE_dspgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MethodHandle LAPACKE_dspgst$handle() {
        return LAPACKE_dspgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MemorySegment LAPACKE_dspgst$address() {
        return LAPACKE_dspgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static int LAPACKE_dspgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_dspgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgv$descriptor() {
        return LAPACKE_sspgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspgv$handle() {
        return LAPACKE_sspgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspgv$address() {
        return LAPACKE_sspgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgv$descriptor() {
        return LAPACKE_dspgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspgv$handle() {
        return LAPACKE_dspgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspgv$address() {
        return LAPACKE_dspgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvd$descriptor() {
        return LAPACKE_sspgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspgvd$handle() {
        return LAPACKE_sspgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspgvd$address() {
        return LAPACKE_sspgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvd$descriptor() {
        return LAPACKE_dspgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspgvd$handle() {
        return LAPACKE_dspgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspgvd$address() {
        return LAPACKE_dspgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvx$descriptor() {
        return LAPACKE_sspgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspgvx$handle() {
        return LAPACKE_sspgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspgvx$address() {
        return LAPACKE_sspgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sspgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sspgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvx$descriptor() {
        return LAPACKE_dspgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspgvx$handle() {
        return LAPACKE_dspgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspgvx$address() {
        return LAPACKE_dspgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dspgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dspgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssprfs$descriptor() {
        return LAPACKE_ssprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssprfs$handle() {
        return LAPACKE_ssprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssprfs$address() {
        return LAPACKE_ssprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsprfs$descriptor() {
        return LAPACKE_dsprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsprfs$handle() {
        return LAPACKE_dsprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsprfs$address() {
        return LAPACKE_dsprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csprfs$descriptor() {
        return LAPACKE_csprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csprfs$handle() {
        return LAPACKE_csprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csprfs$address() {
        return LAPACKE_csprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsprfs$descriptor() {
        return LAPACKE_zsprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsprfs$handle() {
        return LAPACKE_zsprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsprfs$address() {
        return LAPACKE_zsprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsv$descriptor() {
        return LAPACKE_sspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sspsv$handle() {
        return LAPACKE_sspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sspsv$address() {
        return LAPACKE_sspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsv$descriptor() {
        return LAPACKE_dspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dspsv$handle() {
        return LAPACKE_dspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dspsv$address() {
        return LAPACKE_dspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsv$descriptor() {
        return LAPACKE_cspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cspsv$handle() {
        return LAPACKE_cspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cspsv$address() {
        return LAPACKE_cspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsv$descriptor() {
        return LAPACKE_zspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zspsv$handle() {
        return LAPACKE_zspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zspsv$address() {
        return LAPACKE_zspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsvx$descriptor() {
        return LAPACKE_sspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sspsvx$handle() {
        return LAPACKE_sspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sspsvx$address() {
        return LAPACKE_sspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsvx$descriptor() {
        return LAPACKE_dspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dspsvx$handle() {
        return LAPACKE_dspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dspsvx$address() {
        return LAPACKE_dspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsvx$descriptor() {
        return LAPACKE_cspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cspsvx$handle() {
        return LAPACKE_cspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cspsvx$address() {
        return LAPACKE_cspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsvx$descriptor() {
        return LAPACKE_zspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zspsvx$handle() {
        return LAPACKE_zspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zspsvx$address() {
        return LAPACKE_zspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrd$descriptor() {
        return LAPACKE_ssptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssptrd$handle() {
        return LAPACKE_ssptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssptrd$address() {
        return LAPACKE_ssptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrd$descriptor() {
        return LAPACKE_dsptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsptrd$handle() {
        return LAPACKE_dsptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsptrd$address() {
        return LAPACKE_dsptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrf$descriptor() {
        return LAPACKE_ssptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptrf$handle() {
        return LAPACKE_ssptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptrf$address() {
        return LAPACKE_ssptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_ssptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrf$descriptor() {
        return LAPACKE_dsptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptrf$handle() {
        return LAPACKE_dsptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptrf$address() {
        return LAPACKE_dsptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_dsptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrf$descriptor() {
        return LAPACKE_csptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptrf$handle() {
        return LAPACKE_csptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptrf$address() {
        return LAPACKE_csptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_csptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrf$descriptor() {
        return LAPACKE_zsptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptrf$handle() {
        return LAPACKE_zsptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptrf$address() {
        return LAPACKE_zsptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zsptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptri$descriptor() {
        return LAPACKE_ssptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptri$handle() {
        return LAPACKE_ssptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptri$address() {
        return LAPACKE_ssptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptri$descriptor() {
        return LAPACKE_dsptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptri$handle() {
        return LAPACKE_dsptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptri$address() {
        return LAPACKE_dsptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptri$descriptor() {
        return LAPACKE_csptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptri$handle() {
        return LAPACKE_csptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptri$address() {
        return LAPACKE_csptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_csptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptri$descriptor() {
        return LAPACKE_zsptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptri$handle() {
        return LAPACKE_zsptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptri$address() {
        return LAPACKE_zsptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrs$descriptor() {
        return LAPACKE_ssptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssptrs$handle() {
        return LAPACKE_ssptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssptrs$address() {
        return LAPACKE_ssptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrs$descriptor() {
        return LAPACKE_dsptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsptrs$handle() {
        return LAPACKE_dsptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsptrs$address() {
        return LAPACKE_dsptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrs$descriptor() {
        return LAPACKE_csptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csptrs$handle() {
        return LAPACKE_csptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csptrs$address() {
        return LAPACKE_csptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrs$descriptor() {
        return LAPACKE_zsptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsptrs$handle() {
        return LAPACKE_zsptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsptrs$address() {
        return LAPACKE_zsptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstebz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstebz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstebz$descriptor() {
        return LAPACKE_sstebz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static MethodHandle LAPACKE_sstebz$handle() {
        return LAPACKE_sstebz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static MemorySegment LAPACKE_sstebz$address() {
        return LAPACKE_sstebz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static int LAPACKE_sstebz(byte range, byte order, int n, float vl, float vu, int il, int iu, float abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit) {
        var mh$ = LAPACKE_sstebz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstebz", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstebz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstebz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstebz$descriptor() {
        return LAPACKE_dstebz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static MethodHandle LAPACKE_dstebz$handle() {
        return LAPACKE_dstebz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static MemorySegment LAPACKE_dstebz$address() {
        return LAPACKE_dstebz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static int LAPACKE_dstebz(byte range, byte order, int n, double vl, double vu, int il, int iu, double abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit) {
        var mh$ = LAPACKE_dstebz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstebz", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstedc$descriptor() {
        return LAPACKE_sstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstedc$handle() {
        return LAPACKE_sstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstedc$address() {
        return LAPACKE_sstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstedc$descriptor() {
        return LAPACKE_dstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstedc$handle() {
        return LAPACKE_dstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstedc$address() {
        return LAPACKE_dstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstedc$descriptor() {
        return LAPACKE_cstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cstedc$handle() {
        return LAPACKE_cstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cstedc$address() {
        return LAPACKE_cstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstedc$descriptor() {
        return LAPACKE_zstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zstedc$handle() {
        return LAPACKE_zstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zstedc$address() {
        return LAPACKE_zstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstegr$descriptor() {
        return LAPACKE_sstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_sstegr$handle() {
        return LAPACKE_sstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_sstegr$address() {
        return LAPACKE_sstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_sstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_sstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstegr$descriptor() {
        return LAPACKE_dstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dstegr$handle() {
        return LAPACKE_dstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dstegr$address() {
        return LAPACKE_dstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstegr$descriptor() {
        return LAPACKE_cstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_cstegr$handle() {
        return LAPACKE_cstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_cstegr$address() {
        return LAPACKE_cstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_cstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_cstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstegr$descriptor() {
        return LAPACKE_zstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_zstegr$handle() {
        return LAPACKE_zstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_zstegr$address() {
        return LAPACKE_zstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_zstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_zstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstein$descriptor() {
        return LAPACKE_sstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_sstein$handle() {
        return LAPACKE_sstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_sstein$address() {
        return LAPACKE_sstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_sstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_sstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstein$descriptor() {
        return LAPACKE_dstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_dstein$handle() {
        return LAPACKE_dstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_dstein$address() {
        return LAPACKE_dstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_dstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_dstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstein$descriptor() {
        return LAPACKE_cstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_cstein$handle() {
        return LAPACKE_cstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_cstein$address() {
        return LAPACKE_cstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_cstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_cstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstein$descriptor() {
        return LAPACKE_zstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_zstein$handle() {
        return LAPACKE_zstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_zstein$address() {
        return LAPACKE_zstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_zstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_zstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstemr$descriptor() {
        return LAPACKE_sstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_sstemr$handle() {
        return LAPACKE_sstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_sstemr$address() {
        return LAPACKE_sstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_sstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_sstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstemr$descriptor() {
        return LAPACKE_dstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_dstemr$handle() {
        return LAPACKE_dstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_dstemr$address() {
        return LAPACKE_dstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_dstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_dstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstemr$descriptor() {
        return LAPACKE_cstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_cstemr$handle() {
        return LAPACKE_cstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_cstemr$address() {
        return LAPACKE_cstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_cstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_cstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstemr$descriptor() {
        return LAPACKE_zstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_zstemr$handle() {
        return LAPACKE_zstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_zstemr$address() {
        return LAPACKE_zstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_zstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_zstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssteqr$descriptor() {
        return LAPACKE_ssteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssteqr$handle() {
        return LAPACKE_ssteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssteqr$address() {
        return LAPACKE_ssteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsteqr$descriptor() {
        return LAPACKE_dsteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsteqr$handle() {
        return LAPACKE_dsteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsteqr$address() {
        return LAPACKE_dsteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_csteqr$descriptor() {
        return LAPACKE_csteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_csteqr$handle() {
        return LAPACKE_csteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_csteqr$address() {
        return LAPACKE_csteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_csteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_csteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsteqr$descriptor() {
        return LAPACKE_zsteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zsteqr$handle() {
        return LAPACKE_zsteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zsteqr$address() {
        return LAPACKE_zsteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zsteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zsteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssterf$descriptor() {
        return LAPACKE_ssterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssterf$handle() {
        return LAPACKE_ssterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssterf$address() {
        return LAPACKE_ssterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_ssterf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_ssterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssterf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsterf$descriptor() {
        return LAPACKE_dsterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsterf$handle() {
        return LAPACKE_dsterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsterf$address() {
        return LAPACKE_dsterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dsterf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dsterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsterf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstev$descriptor() {
        return LAPACKE_sstev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstev$handle() {
        return LAPACKE_sstev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstev$address() {
        return LAPACKE_sstev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstev(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstev", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstev$descriptor() {
        return LAPACKE_dstev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstev$handle() {
        return LAPACKE_dstev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstev$address() {
        return LAPACKE_dstev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstev(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstev", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevd$descriptor() {
        return LAPACKE_sstevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstevd$handle() {
        return LAPACKE_sstevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstevd$address() {
        return LAPACKE_sstevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstevd(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevd", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevd$descriptor() {
        return LAPACKE_dstevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstevd$handle() {
        return LAPACKE_dstevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstevd$address() {
        return LAPACKE_dstevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstevd(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevd", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevr$descriptor() {
        return LAPACKE_sstevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_sstevr$handle() {
        return LAPACKE_sstevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_sstevr$address() {
        return LAPACKE_sstevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_sstevr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_sstevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevr$descriptor() {
        return LAPACKE_dstevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dstevr$handle() {
        return LAPACKE_dstevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dstevr$address() {
        return LAPACKE_dstevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dstevr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dstevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevx$descriptor() {
        return LAPACKE_sstevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sstevx$handle() {
        return LAPACKE_sstevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sstevx$address() {
        return LAPACKE_sstevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sstevx(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sstevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevx", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevx$descriptor() {
        return LAPACKE_dstevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dstevx$handle() {
        return LAPACKE_dstevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dstevx$address() {
        return LAPACKE_dstevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dstevx(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dstevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevx", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon$descriptor() {
        return LAPACKE_ssycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ssycon$handle() {
        return LAPACKE_ssycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ssycon$address() {
        return LAPACKE_ssycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_ssycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_ssycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon$descriptor() {
        return LAPACKE_dsycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dsycon$handle() {
        return LAPACKE_dsycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dsycon$address() {
        return LAPACKE_dsycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dsycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dsycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon$descriptor() {
        return LAPACKE_csycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_csycon$handle() {
        return LAPACKE_csycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_csycon$address() {
        return LAPACKE_csycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_csycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_csycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon$descriptor() {
        return LAPACKE_zsycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zsycon$handle() {
        return LAPACKE_zsycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zsycon$address() {
        return LAPACKE_zsycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zsycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zsycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyequb$descriptor() {
        return LAPACKE_ssyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_ssyequb$handle() {
        return LAPACKE_ssyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_ssyequb$address() {
        return LAPACKE_ssyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_ssyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_ssyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyequb$descriptor() {
        return LAPACKE_dsyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dsyequb$handle() {
        return LAPACKE_dsyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dsyequb$address() {
        return LAPACKE_dsyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dsyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dsyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyequb$descriptor() {
        return LAPACKE_csyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_csyequb$handle() {
        return LAPACKE_csyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_csyequb$address() {
        return LAPACKE_csyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_csyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_csyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyequb$descriptor() {
        return LAPACKE_zsyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zsyequb$handle() {
        return LAPACKE_zsyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zsyequb$address() {
        return LAPACKE_zsyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zsyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zsyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev$descriptor() {
        return LAPACKE_ssyev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyev$handle() {
        return LAPACKE_ssyev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyev$address() {
        return LAPACKE_ssyev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev$descriptor() {
        return LAPACKE_dsyev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyev$handle() {
        return LAPACKE_dsyev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyev$address() {
        return LAPACKE_dsyev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd$descriptor() {
        return LAPACKE_ssyevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd$handle() {
        return LAPACKE_ssyevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd$address() {
        return LAPACKE_ssyevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd$descriptor() {
        return LAPACKE_dsyevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd$handle() {
        return LAPACKE_dsyevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd$address() {
        return LAPACKE_dsyevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr$descriptor() {
        return LAPACKE_ssyevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr$handle() {
        return LAPACKE_ssyevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr$address() {
        return LAPACKE_ssyevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_ssyevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_ssyevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr$descriptor() {
        return LAPACKE_dsyevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr$handle() {
        return LAPACKE_dsyevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr$address() {
        return LAPACKE_dsyevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dsyevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dsyevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx$descriptor() {
        return LAPACKE_ssyevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx$handle() {
        return LAPACKE_ssyevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx$address() {
        return LAPACKE_ssyevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx$descriptor() {
        return LAPACKE_dsyevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx$handle() {
        return LAPACKE_dsyevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx$address() {
        return LAPACKE_dsyevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygst$descriptor() {
        return LAPACKE_ssygst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssygst$handle() {
        return LAPACKE_ssygst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssygst$address() {
        return LAPACKE_ssygst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssygst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssygst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygst$descriptor() {
        return LAPACKE_dsygst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsygst$handle() {
        return LAPACKE_dsygst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsygst$address() {
        return LAPACKE_dsygst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsygst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsygst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv$descriptor() {
        return LAPACKE_ssygv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssygv$handle() {
        return LAPACKE_ssygv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssygv$address() {
        return LAPACKE_ssygv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_ssygv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_ssygv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv$descriptor() {
        return LAPACKE_dsygv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsygv$handle() {
        return LAPACKE_dsygv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsygv$address() {
        return LAPACKE_dsygv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_dsygv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_dsygv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvd$descriptor() {
        return LAPACKE_ssygvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssygvd$handle() {
        return LAPACKE_ssygvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssygvd$address() {
        return LAPACKE_ssygvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_ssygvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_ssygvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvd$descriptor() {
        return LAPACKE_dsygvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsygvd$handle() {
        return LAPACKE_dsygvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsygvd$address() {
        return LAPACKE_dsygvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_dsygvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_dsygvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvx$descriptor() {
        return LAPACKE_ssygvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssygvx$handle() {
        return LAPACKE_ssygvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssygvx$address() {
        return LAPACKE_ssygvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssygvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssygvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvx$descriptor() {
        return LAPACKE_dsygvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsygvx$handle() {
        return LAPACKE_dsygvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsygvx$address() {
        return LAPACKE_dsygvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsygvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsygvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfs$descriptor() {
        return LAPACKE_ssyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfs$handle() {
        return LAPACKE_ssyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfs$address() {
        return LAPACKE_ssyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfs$descriptor() {
        return LAPACKE_dsyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfs$handle() {
        return LAPACKE_dsyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfs$address() {
        return LAPACKE_dsyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfs$descriptor() {
        return LAPACKE_csyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csyrfs$handle() {
        return LAPACKE_csyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csyrfs$address() {
        return LAPACKE_csyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfs$descriptor() {
        return LAPACKE_zsyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfs$handle() {
        return LAPACKE_zsyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfs$address() {
        return LAPACKE_zsyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfsx$descriptor() {
        return LAPACKE_ssyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfsx$handle() {
        return LAPACKE_ssyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfsx$address() {
        return LAPACKE_ssyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_ssyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_ssyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfsx$descriptor() {
        return LAPACKE_dsyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfsx$handle() {
        return LAPACKE_dsyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfsx$address() {
        return LAPACKE_dsyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dsyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dsyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfsx$descriptor() {
        return LAPACKE_csyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_csyrfsx$handle() {
        return LAPACKE_csyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_csyrfsx$address() {
        return LAPACKE_csyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_csyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_csyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfsx$descriptor() {
        return LAPACKE_zsyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfsx$handle() {
        return LAPACKE_zsyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfsx$address() {
        return LAPACKE_zsyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zsyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zsyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv$descriptor() {
        return LAPACKE_ssysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv$handle() {
        return LAPACKE_ssysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv$address() {
        return LAPACKE_ssysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv$descriptor() {
        return LAPACKE_dsysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv$handle() {
        return LAPACKE_dsysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv$address() {
        return LAPACKE_dsysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv$descriptor() {
        return LAPACKE_csysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv$handle() {
        return LAPACKE_csysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv$address() {
        return LAPACKE_csysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv$descriptor() {
        return LAPACKE_zsysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv$handle() {
        return LAPACKE_zsysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv$address() {
        return LAPACKE_zsysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvx$descriptor() {
        return LAPACKE_ssysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssysvx$handle() {
        return LAPACKE_ssysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssysvx$address() {
        return LAPACKE_ssysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvx$descriptor() {
        return LAPACKE_dsysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsysvx$handle() {
        return LAPACKE_dsysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsysvx$address() {
        return LAPACKE_dsysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvx$descriptor() {
        return LAPACKE_csysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csysvx$handle() {
        return LAPACKE_csysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csysvx$address() {
        return LAPACKE_csysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvx$descriptor() {
        return LAPACKE_zsysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsysvx$handle() {
        return LAPACKE_zsysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsysvx$address() {
        return LAPACKE_zsysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvxx$descriptor() {
        return LAPACKE_ssysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_ssysvxx$handle() {
        return LAPACKE_ssysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_ssysvxx$address() {
        return LAPACKE_ssysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_ssysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_ssysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvxx$descriptor() {
        return LAPACKE_dsysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dsysvxx$handle() {
        return LAPACKE_dsysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dsysvxx$address() {
        return LAPACKE_dsysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dsysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dsysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvxx$descriptor() {
        return LAPACKE_csysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_csysvxx$handle() {
        return LAPACKE_csysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_csysvxx$address() {
        return LAPACKE_csysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_csysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_csysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvxx$descriptor() {
        return LAPACKE_zsysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zsysvxx$handle() {
        return LAPACKE_zsysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zsysvxx$address() {
        return LAPACKE_zsysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zsysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zsysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrd$descriptor() {
        return LAPACKE_ssytrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssytrd$handle() {
        return LAPACKE_ssytrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssytrd$address() {
        return LAPACKE_ssytrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssytrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssytrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrd$descriptor() {
        return LAPACKE_dsytrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsytrd$handle() {
        return LAPACKE_dsytrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsytrd$address() {
        return LAPACKE_dsytrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsytrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsytrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf$descriptor() {
        return LAPACKE_ssytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf$handle() {
        return LAPACKE_ssytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf$address() {
        return LAPACKE_ssytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf$descriptor() {
        return LAPACKE_dsytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf$handle() {
        return LAPACKE_dsytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf$address() {
        return LAPACKE_dsytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf$descriptor() {
        return LAPACKE_csytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf$handle() {
        return LAPACKE_csytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf$address() {
        return LAPACKE_csytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf$descriptor() {
        return LAPACKE_zsytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf$handle() {
        return LAPACKE_zsytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf$address() {
        return LAPACKE_zsytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri$descriptor() {
        return LAPACKE_ssytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytri$handle() {
        return LAPACKE_ssytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytri$address() {
        return LAPACKE_ssytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri$descriptor() {
        return LAPACKE_dsytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytri$handle() {
        return LAPACKE_dsytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytri$address() {
        return LAPACKE_dsytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri$descriptor() {
        return LAPACKE_csytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytri$handle() {
        return LAPACKE_csytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytri$address() {
        return LAPACKE_csytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_csytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri$descriptor() {
        return LAPACKE_zsytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytri$handle() {
        return LAPACKE_zsytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytri$address() {
        return LAPACKE_zsytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs$descriptor() {
        return LAPACKE_ssytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs$handle() {
        return LAPACKE_ssytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs$address() {
        return LAPACKE_ssytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs$descriptor() {
        return LAPACKE_dsytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs$handle() {
        return LAPACKE_dsytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs$address() {
        return LAPACKE_dsytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs$descriptor() {
        return LAPACKE_csytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs$handle() {
        return LAPACKE_csytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs$address() {
        return LAPACKE_csytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs$descriptor() {
        return LAPACKE_zsytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs$handle() {
        return LAPACKE_zsytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs$address() {
        return LAPACKE_zsytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbcon$descriptor() {
        return LAPACKE_stbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_stbcon$handle() {
        return LAPACKE_stbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_stbcon$address() {
        return LAPACKE_stbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static int LAPACKE_stbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_stbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbcon$descriptor() {
        return LAPACKE_dtbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtbcon$handle() {
        return LAPACKE_dtbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtbcon$address() {
        return LAPACKE_dtbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static int LAPACKE_dtbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_dtbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbcon$descriptor() {
        return LAPACKE_ctbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctbcon$handle() {
        return LAPACKE_ctbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctbcon$address() {
        return LAPACKE_ctbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static int LAPACKE_ctbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_ctbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbcon$descriptor() {
        return LAPACKE_ztbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztbcon$handle() {
        return LAPACKE_ztbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztbcon$address() {
        return LAPACKE_ztbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static int LAPACKE_ztbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_ztbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbrfs$descriptor() {
        return LAPACKE_stbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_stbrfs$handle() {
        return LAPACKE_stbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_stbrfs$address() {
        return LAPACKE_stbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_stbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_stbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbrfs$descriptor() {
        return LAPACKE_dtbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtbrfs$handle() {
        return LAPACKE_dtbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtbrfs$address() {
        return LAPACKE_dtbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbrfs$descriptor() {
        return LAPACKE_ctbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctbrfs$handle() {
        return LAPACKE_ctbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctbrfs$address() {
        return LAPACKE_ctbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbrfs$descriptor() {
        return LAPACKE_ztbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztbrfs$handle() {
        return LAPACKE_ztbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztbrfs$address() {
        return LAPACKE_ztbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbtrs$descriptor() {
        return LAPACKE_stbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stbtrs$handle() {
        return LAPACKE_stbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stbtrs$address() {
        return LAPACKE_stbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbtrs$descriptor() {
        return LAPACKE_dtbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtbtrs$handle() {
        return LAPACKE_dtbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtbtrs$address() {
        return LAPACKE_dtbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbtrs$descriptor() {
        return LAPACKE_ctbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctbtrs$handle() {
        return LAPACKE_ctbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctbtrs$address() {
        return LAPACKE_ctbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbtrs$descriptor() {
        return LAPACKE_ztbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztbtrs$handle() {
        return LAPACKE_ztbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztbtrs$address() {
        return LAPACKE_ztbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfsm$descriptor() {
        return LAPACKE_stfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stfsm$handle() {
        return LAPACKE_stfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stfsm$address() {
        return LAPACKE_stfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfsm$descriptor() {
        return LAPACKE_dtfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtfsm$handle() {
        return LAPACKE_dtfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtfsm$address() {
        return LAPACKE_dtfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfsm$descriptor() {
        return LAPACKE_ctfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctfsm$handle() {
        return LAPACKE_ctfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctfsm$address() {
        return LAPACKE_ctfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfsm$descriptor() {
        return LAPACKE_ztfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztfsm$handle() {
        return LAPACKE_ztfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztfsm$address() {
        return LAPACKE_ztfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_stftri$descriptor() {
        return LAPACKE_stftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_stftri$handle() {
        return LAPACKE_stftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_stftri$address() {
        return LAPACKE_stftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static int LAPACKE_stftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_stftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtftri$descriptor() {
        return LAPACKE_dtftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dtftri$handle() {
        return LAPACKE_dtftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dtftri$address() {
        return LAPACKE_dtftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static int LAPACKE_dtftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_dtftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctftri$descriptor() {
        return LAPACKE_ctftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_ctftri$handle() {
        return LAPACKE_ctftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_ctftri$address() {
        return LAPACKE_ctftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_ctftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ctftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztftri$descriptor() {
        return LAPACKE_ztftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_ztftri$handle() {
        return LAPACKE_ztftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_ztftri$address() {
        return LAPACKE_ztftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_ztftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ztftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttp$descriptor() {
        return LAPACKE_stfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stfttp$handle() {
        return LAPACKE_stfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stfttp$address() {
        return LAPACKE_stfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static int LAPACKE_stfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_stfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttp$descriptor() {
        return LAPACKE_dtfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtfttp$handle() {
        return LAPACKE_dtfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtfttp$address() {
        return LAPACKE_dtfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static int LAPACKE_dtfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_dtfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttp$descriptor() {
        return LAPACKE_ctfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctfttp$handle() {
        return LAPACKE_ctfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctfttp$address() {
        return LAPACKE_ctfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ctfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttp$descriptor() {
        return LAPACKE_ztfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztfttp$handle() {
        return LAPACKE_ztfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztfttp$address() {
        return LAPACKE_ztfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ztfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttr$descriptor() {
        return LAPACKE_stfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stfttr$handle() {
        return LAPACKE_stfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stfttr$address() {
        return LAPACKE_stfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static int LAPACKE_stfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttr$descriptor() {
        return LAPACKE_dtfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtfttr$handle() {
        return LAPACKE_dtfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtfttr$address() {
        return LAPACKE_dtfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttr$descriptor() {
        return LAPACKE_ctfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctfttr$handle() {
        return LAPACKE_ctfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctfttr$address() {
        return LAPACKE_ctfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttr$descriptor() {
        return LAPACKE_ztfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztfttr$handle() {
        return LAPACKE_ztfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztfttr$address() {
        return LAPACKE_ztfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

