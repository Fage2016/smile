// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h_1 extends cblas_openblas_h_2 {

    cblas_openblas_h_1() {
        // Should not be called directly
    }

    private static class LAPACKE_stgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgevc$descriptor() {
        return LAPACKE_stgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_stgevc$handle() {
        return LAPACKE_stgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_stgevc$address() {
        return LAPACKE_stgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_stgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_stgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgevc$descriptor() {
        return LAPACKE_dtgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtgevc$handle() {
        return LAPACKE_dtgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtgevc$address() {
        return LAPACKE_dtgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgevc$descriptor() {
        return LAPACKE_ctgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctgevc$handle() {
        return LAPACKE_ctgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctgevc$address() {
        return LAPACKE_ctgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgevc$descriptor() {
        return LAPACKE_ztgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztgevc$handle() {
        return LAPACKE_ztgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztgevc$address() {
        return LAPACKE_ztgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgexc$descriptor() {
        return LAPACKE_stgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_stgexc$handle() {
        return LAPACKE_stgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_stgexc$address() {
        return LAPACKE_stgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_stgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgexc$descriptor() {
        return LAPACKE_dtgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_dtgexc$handle() {
        return LAPACKE_dtgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_dtgexc$address() {
        return LAPACKE_dtgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_dtgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgexc$descriptor() {
        return LAPACKE_ctgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctgexc$handle() {
        return LAPACKE_ctgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctgexc$address() {
        return LAPACKE_ctgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ctgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgexc$descriptor() {
        return LAPACKE_ztgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztgexc$handle() {
        return LAPACKE_ztgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztgexc$address() {
        return LAPACKE_ztgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ztgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsen$descriptor() {
        return LAPACKE_stgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_stgsen$handle() {
        return LAPACKE_stgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_stgsen$address() {
        return LAPACKE_stgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_stgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsen$descriptor() {
        return LAPACKE_dtgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_dtgsen$handle() {
        return LAPACKE_dtgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_dtgsen$address() {
        return LAPACKE_dtgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_dtgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsen$descriptor() {
        return LAPACKE_ctgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_ctgsen$handle() {
        return LAPACKE_ctgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_ctgsen$address() {
        return LAPACKE_ctgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_ctgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsen$descriptor() {
        return LAPACKE_ztgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_ztgsen$handle() {
        return LAPACKE_ztgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_ztgsen$address() {
        return LAPACKE_ztgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_ztgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsja$descriptor() {
        return LAPACKE_stgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_stgsja$handle() {
        return LAPACKE_stgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_stgsja$address() {
        return LAPACKE_stgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_stgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_stgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsja$descriptor() {
        return LAPACKE_dtgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_dtgsja$handle() {
        return LAPACKE_dtgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_dtgsja$address() {
        return LAPACKE_dtgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_dtgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_dtgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsja$descriptor() {
        return LAPACKE_ctgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ctgsja$handle() {
        return LAPACKE_ctgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ctgsja$address() {
        return LAPACKE_ctgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_ctgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_ctgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsja$descriptor() {
        return LAPACKE_ztgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ztgsja$handle() {
        return LAPACKE_ztgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ztgsja$address() {
        return LAPACKE_ztgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_ztgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_ztgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsna$descriptor() {
        return LAPACKE_stgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_stgsna$handle() {
        return LAPACKE_stgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_stgsna$address() {
        return LAPACKE_stgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_stgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_stgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsna$descriptor() {
        return LAPACKE_dtgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtgsna$handle() {
        return LAPACKE_dtgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtgsna$address() {
        return LAPACKE_dtgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsna$descriptor() {
        return LAPACKE_ctgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctgsna$handle() {
        return LAPACKE_ctgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctgsna$address() {
        return LAPACKE_ctgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsna$descriptor() {
        return LAPACKE_ztgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztgsna$handle() {
        return LAPACKE_ztgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztgsna$address() {
        return LAPACKE_ztgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsyl$descriptor() {
        return LAPACKE_stgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_stgsyl$handle() {
        return LAPACKE_stgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_stgsyl$address() {
        return LAPACKE_stgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static int LAPACKE_stgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_stgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsyl$descriptor() {
        return LAPACKE_dtgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_dtgsyl$handle() {
        return LAPACKE_dtgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_dtgsyl$address() {
        return LAPACKE_dtgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static int LAPACKE_dtgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_dtgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsyl$descriptor() {
        return LAPACKE_ctgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_ctgsyl$handle() {
        return LAPACKE_ctgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_ctgsyl$address() {
        return LAPACKE_ctgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static int LAPACKE_ctgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_ctgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsyl$descriptor() {
        return LAPACKE_ztgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_ztgsyl$handle() {
        return LAPACKE_ztgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_ztgsyl$address() {
        return LAPACKE_ztgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static int LAPACKE_ztgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_ztgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpcon$descriptor() {
        return LAPACKE_stpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_stpcon$handle() {
        return LAPACKE_stpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_stpcon$address() {
        return LAPACKE_stpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static int LAPACKE_stpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_stpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpcon$descriptor() {
        return LAPACKE_dtpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtpcon$handle() {
        return LAPACKE_dtpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtpcon$address() {
        return LAPACKE_dtpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static int LAPACKE_dtpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_dtpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpcon$descriptor() {
        return LAPACKE_ctpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctpcon$handle() {
        return LAPACKE_ctpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctpcon$address() {
        return LAPACKE_ctpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static int LAPACKE_ctpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_ctpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpcon$descriptor() {
        return LAPACKE_ztpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztpcon$handle() {
        return LAPACKE_ztpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztpcon$address() {
        return LAPACKE_ztpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static int LAPACKE_ztpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_ztpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfs$descriptor() {
        return LAPACKE_stprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_stprfs$handle() {
        return LAPACKE_stprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_stprfs$address() {
        return LAPACKE_stprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_stprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_stprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfs$descriptor() {
        return LAPACKE_dtprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtprfs$handle() {
        return LAPACKE_dtprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtprfs$address() {
        return LAPACKE_dtprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfs$descriptor() {
        return LAPACKE_ctprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctprfs$handle() {
        return LAPACKE_ctprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctprfs$address() {
        return LAPACKE_ctprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfs$descriptor() {
        return LAPACKE_ztprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztprfs$handle() {
        return LAPACKE_ztprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztprfs$address() {
        return LAPACKE_ztprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptri$descriptor() {
        return LAPACKE_stptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stptri$handle() {
        return LAPACKE_stptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stptri$address() {
        return LAPACKE_stptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static int LAPACKE_stptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_stptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptri$descriptor() {
        return LAPACKE_dtptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtptri$handle() {
        return LAPACKE_dtptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtptri$address() {
        return LAPACKE_dtptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static int LAPACKE_dtptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dtptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptri$descriptor() {
        return LAPACKE_ctptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctptri$handle() {
        return LAPACKE_ctptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctptri$address() {
        return LAPACKE_ctptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ctptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptri$descriptor() {
        return LAPACKE_ztptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztptri$handle() {
        return LAPACKE_ztptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztptri$address() {
        return LAPACKE_ztptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ztptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptrs$descriptor() {
        return LAPACKE_stptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stptrs$handle() {
        return LAPACKE_stptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stptrs$address() {
        return LAPACKE_stptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptrs$descriptor() {
        return LAPACKE_dtptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtptrs$handle() {
        return LAPACKE_dtptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtptrs$address() {
        return LAPACKE_dtptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptrs$descriptor() {
        return LAPACKE_ctptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctptrs$handle() {
        return LAPACKE_ctptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctptrs$address() {
        return LAPACKE_ctptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptrs$descriptor() {
        return LAPACKE_ztptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztptrs$handle() {
        return LAPACKE_ztptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztptrs$address() {
        return LAPACKE_ztptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttf$descriptor() {
        return LAPACKE_stpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_stpttf$handle() {
        return LAPACKE_stpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_stpttf$address() {
        return LAPACKE_stpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static int LAPACKE_stpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_stpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttf$descriptor() {
        return LAPACKE_dtpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtpttf$handle() {
        return LAPACKE_dtpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtpttf$address() {
        return LAPACKE_dtpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static int LAPACKE_dtpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_dtpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttf$descriptor() {
        return LAPACKE_ctpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctpttf$handle() {
        return LAPACKE_ctpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctpttf$address() {
        return LAPACKE_ctpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ctpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttf$descriptor() {
        return LAPACKE_ztpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztpttf$handle() {
        return LAPACKE_ztpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztpttf$address() {
        return LAPACKE_ztpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ztpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttr$descriptor() {
        return LAPACKE_stpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stpttr$handle() {
        return LAPACKE_stpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stpttr$address() {
        return LAPACKE_stpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static int LAPACKE_stpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttr$descriptor() {
        return LAPACKE_dtpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtpttr$handle() {
        return LAPACKE_dtpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtpttr$address() {
        return LAPACKE_dtpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttr$descriptor() {
        return LAPACKE_ctpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctpttr$handle() {
        return LAPACKE_ctpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctpttr$address() {
        return LAPACKE_ctpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttr$descriptor() {
        return LAPACKE_ztpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztpttr$handle() {
        return LAPACKE_ztpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztpttr$address() {
        return LAPACKE_ztpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_strcon$descriptor() {
        return LAPACKE_strcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_strcon$handle() {
        return LAPACKE_strcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_strcon$address() {
        return LAPACKE_strcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static int LAPACKE_strcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_strcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrcon$descriptor() {
        return LAPACKE_dtrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtrcon$handle() {
        return LAPACKE_dtrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtrcon$address() {
        return LAPACKE_dtrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static int LAPACKE_dtrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_dtrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrcon$descriptor() {
        return LAPACKE_ctrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctrcon$handle() {
        return LAPACKE_ctrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctrcon$address() {
        return LAPACKE_ctrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static int LAPACKE_ctrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_ctrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrcon$descriptor() {
        return LAPACKE_ztrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztrcon$handle() {
        return LAPACKE_ztrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztrcon$address() {
        return LAPACKE_ztrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static int LAPACKE_ztrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_ztrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_strevc$descriptor() {
        return LAPACKE_strevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_strevc$handle() {
        return LAPACKE_strevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_strevc$address() {
        return LAPACKE_strevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_strevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_strevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrevc$descriptor() {
        return LAPACKE_dtrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtrevc$handle() {
        return LAPACKE_dtrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtrevc$address() {
        return LAPACKE_dtrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrevc$descriptor() {
        return LAPACKE_ctrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctrevc$handle() {
        return LAPACKE_ctrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctrevc$address() {
        return LAPACKE_ctrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrevc$descriptor() {
        return LAPACKE_ztrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztrevc$handle() {
        return LAPACKE_ztrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztrevc$address() {
        return LAPACKE_ztrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_strexc$descriptor() {
        return LAPACKE_strexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_strexc$handle() {
        return LAPACKE_strexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_strexc$address() {
        return LAPACKE_strexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_strexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_strexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrexc$descriptor() {
        return LAPACKE_dtrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_dtrexc$handle() {
        return LAPACKE_dtrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_dtrexc$address() {
        return LAPACKE_dtrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_dtrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_dtrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrexc$descriptor() {
        return LAPACKE_ctrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctrexc$handle() {
        return LAPACKE_ctrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctrexc$address() {
        return LAPACKE_ctrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ctrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrexc$descriptor() {
        return LAPACKE_ztrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztrexc$handle() {
        return LAPACKE_ztrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztrexc$address() {
        return LAPACKE_ztrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ztrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_strrfs$descriptor() {
        return LAPACKE_strrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_strrfs$handle() {
        return LAPACKE_strrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_strrfs$address() {
        return LAPACKE_strrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_strrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_strrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrrfs$descriptor() {
        return LAPACKE_dtrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtrrfs$handle() {
        return LAPACKE_dtrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtrrfs$address() {
        return LAPACKE_dtrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrrfs$descriptor() {
        return LAPACKE_ctrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctrrfs$handle() {
        return LAPACKE_ctrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctrrfs$address() {
        return LAPACKE_ctrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrrfs$descriptor() {
        return LAPACKE_ztrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztrrfs$handle() {
        return LAPACKE_ztrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztrrfs$address() {
        return LAPACKE_ztrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsen$descriptor() {
        return LAPACKE_strsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_strsen$handle() {
        return LAPACKE_strsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_strsen$address() {
        return LAPACKE_strsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static int LAPACKE_strsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_strsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsen$descriptor() {
        return LAPACKE_dtrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_dtrsen$handle() {
        return LAPACKE_dtrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_dtrsen$address() {
        return LAPACKE_dtrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static int LAPACKE_dtrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_dtrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsen$descriptor() {
        return LAPACKE_ctrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_ctrsen$handle() {
        return LAPACKE_ctrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_ctrsen$address() {
        return LAPACKE_ctrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static int LAPACKE_ctrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_ctrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsen$descriptor() {
        return LAPACKE_ztrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ztrsen$handle() {
        return LAPACKE_ztrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ztrsen$address() {
        return LAPACKE_ztrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static int LAPACKE_ztrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_ztrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsna$descriptor() {
        return LAPACKE_strsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_strsna$handle() {
        return LAPACKE_strsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_strsna$address() {
        return LAPACKE_strsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_strsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_strsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsna$descriptor() {
        return LAPACKE_dtrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtrsna$handle() {
        return LAPACKE_dtrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtrsna$address() {
        return LAPACKE_dtrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsna$descriptor() {
        return LAPACKE_ctrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctrsna$handle() {
        return LAPACKE_ctrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctrsna$address() {
        return LAPACKE_ctrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsna$descriptor() {
        return LAPACKE_ztrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztrsna$handle() {
        return LAPACKE_ztrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztrsna$address() {
        return LAPACKE_ztrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsyl$descriptor() {
        return LAPACKE_strsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_strsyl$handle() {
        return LAPACKE_strsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_strsyl$address() {
        return LAPACKE_strsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_strsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_strsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsyl$descriptor() {
        return LAPACKE_dtrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dtrsyl$handle() {
        return LAPACKE_dtrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dtrsyl$address() {
        return LAPACKE_dtrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_dtrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_dtrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsyl$descriptor() {
        return LAPACKE_ctrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_ctrsyl$handle() {
        return LAPACKE_ctrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_ctrsyl$address() {
        return LAPACKE_ctrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_ctrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ctrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsyl$descriptor() {
        return LAPACKE_ztrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_ztrsyl$handle() {
        return LAPACKE_ztrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_ztrsyl$address() {
        return LAPACKE_ztrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_ztrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ztrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtri$descriptor() {
        return LAPACKE_strtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_strtri$handle() {
        return LAPACKE_strtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_strtri$address() {
        return LAPACKE_strtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_strtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_strtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtri$descriptor() {
        return LAPACKE_dtrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtrtri$handle() {
        return LAPACKE_dtrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtrtri$address() {
        return LAPACKE_dtrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtri$descriptor() {
        return LAPACKE_ctrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctrtri$handle() {
        return LAPACKE_ctrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctrtri$address() {
        return LAPACKE_ctrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtri$descriptor() {
        return LAPACKE_ztrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztrtri$handle() {
        return LAPACKE_ztrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztrtri$address() {
        return LAPACKE_ztrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtrs$descriptor() {
        return LAPACKE_strtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_strtrs$handle() {
        return LAPACKE_strtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_strtrs$address() {
        return LAPACKE_strtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_strtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_strtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtrs$descriptor() {
        return LAPACKE_dtrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtrtrs$handle() {
        return LAPACKE_dtrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtrtrs$address() {
        return LAPACKE_dtrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtrs$descriptor() {
        return LAPACKE_ctrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctrtrs$handle() {
        return LAPACKE_ctrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctrtrs$address() {
        return LAPACKE_ctrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtrs$descriptor() {
        return LAPACKE_ztrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztrtrs$handle() {
        return LAPACKE_ztrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztrtrs$address() {
        return LAPACKE_ztrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttf$descriptor() {
        return LAPACKE_strttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_strttf$handle() {
        return LAPACKE_strttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_strttf$address() {
        return LAPACKE_strttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static int LAPACKE_strttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_strttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttf$descriptor() {
        return LAPACKE_dtrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtrttf$handle() {
        return LAPACKE_dtrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtrttf$address() {
        return LAPACKE_dtrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static int LAPACKE_dtrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_dtrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttf$descriptor() {
        return LAPACKE_ctrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctrttf$handle() {
        return LAPACKE_ctrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctrttf$address() {
        return LAPACKE_ctrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ctrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttf$descriptor() {
        return LAPACKE_ztrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztrttf$handle() {
        return LAPACKE_ztrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztrttf$address() {
        return LAPACKE_ztrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ztrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttp$descriptor() {
        return LAPACKE_strttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_strttp$handle() {
        return LAPACKE_strttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_strttp$address() {
        return LAPACKE_strttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static int LAPACKE_strttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_strttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttp$descriptor() {
        return LAPACKE_dtrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtrttp$handle() {
        return LAPACKE_dtrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtrttp$address() {
        return LAPACKE_dtrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static int LAPACKE_dtrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_dtrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttp$descriptor() {
        return LAPACKE_ctrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctrttp$handle() {
        return LAPACKE_ctrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctrttp$address() {
        return LAPACKE_ctrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ctrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttp$descriptor() {
        return LAPACKE_ztrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztrttp$handle() {
        return LAPACKE_ztrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztrttp$address() {
        return LAPACKE_ztrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ztrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_stzrzf$descriptor() {
        return LAPACKE_stzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_stzrzf$handle() {
        return LAPACKE_stzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_stzrzf$address() {
        return LAPACKE_stzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_stzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_stzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtzrzf$descriptor() {
        return LAPACKE_dtzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dtzrzf$handle() {
        return LAPACKE_dtzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dtzrzf$address() {
        return LAPACKE_dtzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dtzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dtzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctzrzf$descriptor() {
        return LAPACKE_ctzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ctzrzf$handle() {
        return LAPACKE_ctzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ctzrzf$address() {
        return LAPACKE_ctzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_ctzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_ctzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztzrzf$descriptor() {
        return LAPACKE_ztzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_ztzrzf$handle() {
        return LAPACKE_ztzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_ztzrzf$address() {
        return LAPACKE_ztzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_ztzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_ztzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungbr$descriptor() {
        return LAPACKE_cungbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungbr$handle() {
        return LAPACKE_cungbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungbr$address() {
        return LAPACKE_cungbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungbr$descriptor() {
        return LAPACKE_zungbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungbr$handle() {
        return LAPACKE_zungbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungbr$address() {
        return LAPACKE_zungbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunghr$descriptor() {
        return LAPACKE_cunghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cunghr$handle() {
        return LAPACKE_cunghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cunghr$address() {
        return LAPACKE_cunghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cunghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunghr$descriptor() {
        return LAPACKE_zunghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zunghr$handle() {
        return LAPACKE_zunghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zunghr$address() {
        return LAPACKE_zunghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zunghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunglq$descriptor() {
        return LAPACKE_cunglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cunglq$handle() {
        return LAPACKE_cunglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cunglq$address() {
        return LAPACKE_cunglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cunglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunglq$descriptor() {
        return LAPACKE_zunglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zunglq$handle() {
        return LAPACKE_zunglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zunglq$address() {
        return LAPACKE_zunglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zunglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungql$descriptor() {
        return LAPACKE_cungql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungql$handle() {
        return LAPACKE_cungql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungql$address() {
        return LAPACKE_cungql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungql$descriptor() {
        return LAPACKE_zungql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungql$handle() {
        return LAPACKE_zungql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungql$address() {
        return LAPACKE_zungql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungqr$descriptor() {
        return LAPACKE_cungqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungqr$handle() {
        return LAPACKE_cungqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungqr$address() {
        return LAPACKE_cungqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungqr$descriptor() {
        return LAPACKE_zungqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungqr$handle() {
        return LAPACKE_zungqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungqr$address() {
        return LAPACKE_zungqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungrq$descriptor() {
        return LAPACKE_cungrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungrq$handle() {
        return LAPACKE_cungrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungrq$address() {
        return LAPACKE_cungrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungrq$descriptor() {
        return LAPACKE_zungrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungrq$handle() {
        return LAPACKE_zungrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungrq$address() {
        return LAPACKE_zungrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtr$descriptor() {
        return LAPACKE_cungtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungtr$handle() {
        return LAPACKE_cungtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungtr$address() {
        return LAPACKE_cungtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtr$descriptor() {
        return LAPACKE_zungtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungtr$handle() {
        return LAPACKE_zungtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungtr$address() {
        return LAPACKE_zungtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtsqr_row$descriptor() {
        return LAPACKE_cungtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cungtsqr_row$handle() {
        return LAPACKE_cungtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cungtsqr_row$address() {
        return LAPACKE_cungtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cungtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtsqr_row$descriptor() {
        return LAPACKE_zungtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zungtsqr_row$handle() {
        return LAPACKE_zungtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zungtsqr_row$address() {
        return LAPACKE_zungtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zungtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmbr$descriptor() {
        return LAPACKE_cunmbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmbr$handle() {
        return LAPACKE_cunmbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmbr$address() {
        return LAPACKE_cunmbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmbr$descriptor() {
        return LAPACKE_zunmbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmbr$handle() {
        return LAPACKE_zunmbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmbr$address() {
        return LAPACKE_zunmbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmhr$descriptor() {
        return LAPACKE_cunmhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmhr$handle() {
        return LAPACKE_cunmhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmhr$address() {
        return LAPACKE_cunmhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmhr$descriptor() {
        return LAPACKE_zunmhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmhr$handle() {
        return LAPACKE_zunmhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmhr$address() {
        return LAPACKE_zunmhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmlq$descriptor() {
        return LAPACKE_cunmlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmlq$handle() {
        return LAPACKE_cunmlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmlq$address() {
        return LAPACKE_cunmlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmlq$descriptor() {
        return LAPACKE_zunmlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmlq$handle() {
        return LAPACKE_zunmlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmlq$address() {
        return LAPACKE_zunmlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmql$descriptor() {
        return LAPACKE_cunmql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmql$handle() {
        return LAPACKE_cunmql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmql$address() {
        return LAPACKE_cunmql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmql$descriptor() {
        return LAPACKE_zunmql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmql$handle() {
        return LAPACKE_zunmql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmql$address() {
        return LAPACKE_zunmql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmqr$descriptor() {
        return LAPACKE_cunmqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmqr$handle() {
        return LAPACKE_cunmqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmqr$address() {
        return LAPACKE_cunmqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmqr$descriptor() {
        return LAPACKE_zunmqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmqr$handle() {
        return LAPACKE_zunmqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmqr$address() {
        return LAPACKE_zunmqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrq$descriptor() {
        return LAPACKE_cunmrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmrq$handle() {
        return LAPACKE_cunmrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmrq$address() {
        return LAPACKE_cunmrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrq$descriptor() {
        return LAPACKE_zunmrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmrq$handle() {
        return LAPACKE_zunmrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmrq$address() {
        return LAPACKE_zunmrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrz$descriptor() {
        return LAPACKE_cunmrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmrz$handle() {
        return LAPACKE_cunmrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmrz$address() {
        return LAPACKE_cunmrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrz$descriptor() {
        return LAPACKE_zunmrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmrz$handle() {
        return LAPACKE_zunmrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmrz$address() {
        return LAPACKE_zunmrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmtr$descriptor() {
        return LAPACKE_cunmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmtr$handle() {
        return LAPACKE_cunmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmtr$address() {
        return LAPACKE_cunmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmtr$descriptor() {
        return LAPACKE_zunmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmtr$handle() {
        return LAPACKE_zunmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmtr$address() {
        return LAPACKE_zunmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cupgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupgtr$descriptor() {
        return LAPACKE_cupgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cupgtr$handle() {
        return LAPACKE_cupgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cupgtr$address() {
        return LAPACKE_cupgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cupgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cupgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zupgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupgtr$descriptor() {
        return LAPACKE_zupgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zupgtr$handle() {
        return LAPACKE_zupgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zupgtr$address() {
        return LAPACKE_zupgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zupgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zupgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cupmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupmtr$descriptor() {
        return LAPACKE_cupmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cupmtr$handle() {
        return LAPACKE_cupmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cupmtr$address() {
        return LAPACKE_cupmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cupmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cupmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zupmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupmtr$descriptor() {
        return LAPACKE_zupmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zupmtr$handle() {
        return LAPACKE_zupmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zupmtr$address() {
        return LAPACKE_zupmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zupmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zupmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsdc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsdc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsdc_work$descriptor() {
        return LAPACKE_sbdsdc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sbdsdc_work$handle() {
        return LAPACKE_sbdsdc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sbdsdc_work$address() {
        return LAPACKE_sbdsdc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sbdsdc_work(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sbdsdc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsdc_work", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsdc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsdc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsdc_work$descriptor() {
        return LAPACKE_dbdsdc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dbdsdc_work$handle() {
        return LAPACKE_dbdsdc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dbdsdc_work$address() {
        return LAPACKE_dbdsdc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dbdsdc_work(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dbdsdc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsdc_work", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsvdx_work$descriptor() {
        return LAPACKE_sbdsvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sbdsvdx_work$handle() {
        return LAPACKE_sbdsvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sbdsvdx_work$address() {
        return LAPACKE_sbdsvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sbdsvdx_work(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sbdsvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsvdx_work", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsvdx_work$descriptor() {
        return LAPACKE_dbdsvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dbdsvdx_work$handle() {
        return LAPACKE_dbdsvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dbdsvdx_work$address() {
        return LAPACKE_dbdsvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dbdsvdx_work(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dbdsvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsvdx_work", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsqr_work$descriptor() {
        return LAPACKE_sbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sbdsqr_work$handle() {
        return LAPACKE_sbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sbdsqr_work$address() {
        return LAPACKE_sbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsqr_work$descriptor() {
        return LAPACKE_dbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dbdsqr_work$handle() {
        return LAPACKE_dbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dbdsqr_work$address() {
        return LAPACKE_dbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbdsqr_work$descriptor() {
        return LAPACKE_cbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cbdsqr_work$handle() {
        return LAPACKE_cbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cbdsqr_work$address() {
        return LAPACKE_cbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_cbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbdsqr_work$descriptor() {
        return LAPACKE_zbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zbdsqr_work$handle() {
        return LAPACKE_zbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zbdsqr_work$address() {
        return LAPACKE_zbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sdisna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sdisna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_sdisna_work$descriptor() {
        return LAPACKE_sdisna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_sdisna_work$handle() {
        return LAPACKE_sdisna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_sdisna_work$address() {
        return LAPACKE_sdisna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static int LAPACKE_sdisna_work(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_sdisna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sdisna_work", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ddisna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ddisna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ddisna_work$descriptor() {
        return LAPACKE_ddisna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ddisna_work$handle() {
        return LAPACKE_ddisna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ddisna_work$address() {
        return LAPACKE_ddisna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static int LAPACKE_ddisna_work(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_ddisna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ddisna_work", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbbrd_work$descriptor() {
        return LAPACKE_sgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgbbrd_work$handle() {
        return LAPACKE_sgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgbbrd_work$address() {
        return LAPACKE_sgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbbrd_work$descriptor() {
        return LAPACKE_dgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgbbrd_work$handle() {
        return LAPACKE_dgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgbbrd_work$address() {
        return LAPACKE_dgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbbrd_work$descriptor() {
        return LAPACKE_cgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbbrd_work$handle() {
        return LAPACKE_cgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbbrd_work$address() {
        return LAPACKE_cgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbbrd_work$descriptor() {
        return LAPACKE_zgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbbrd_work$handle() {
        return LAPACKE_zgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbbrd_work$address() {
        return LAPACKE_zgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbcon_work$descriptor() {
        return LAPACKE_sgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbcon_work$handle() {
        return LAPACKE_sgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbcon_work$address() {
        return LAPACKE_sgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbcon_work$descriptor() {
        return LAPACKE_dgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbcon_work$handle() {
        return LAPACKE_dgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbcon_work$address() {
        return LAPACKE_dgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbcon_work$descriptor() {
        return LAPACKE_cgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbcon_work$handle() {
        return LAPACKE_cgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbcon_work$address() {
        return LAPACKE_cgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbcon_work$descriptor() {
        return LAPACKE_zgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbcon_work$handle() {
        return LAPACKE_zgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbcon_work$address() {
        return LAPACKE_zgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequ_work$descriptor() {
        return LAPACKE_sgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequ_work$handle() {
        return LAPACKE_sgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequ_work$address() {
        return LAPACKE_sgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequ_work$descriptor() {
        return LAPACKE_dgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequ_work$handle() {
        return LAPACKE_dgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequ_work$address() {
        return LAPACKE_dgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequ_work$descriptor() {
        return LAPACKE_cgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequ_work$handle() {
        return LAPACKE_cgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequ_work$address() {
        return LAPACKE_cgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequ_work$descriptor() {
        return LAPACKE_zgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequ_work$handle() {
        return LAPACKE_zgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequ_work$address() {
        return LAPACKE_zgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequb_work$descriptor() {
        return LAPACKE_sgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequb_work$handle() {
        return LAPACKE_sgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequb_work$address() {
        return LAPACKE_sgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequb_work$descriptor() {
        return LAPACKE_dgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequb_work$handle() {
        return LAPACKE_dgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequb_work$address() {
        return LAPACKE_dgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequb_work$descriptor() {
        return LAPACKE_cgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequb_work$handle() {
        return LAPACKE_cgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequb_work$address() {
        return LAPACKE_cgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequb_work$descriptor() {
        return LAPACKE_zgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequb_work$handle() {
        return LAPACKE_zgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequb_work$address() {
        return LAPACKE_zgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfs_work$descriptor() {
        return LAPACKE_sgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfs_work$handle() {
        return LAPACKE_sgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfs_work$address() {
        return LAPACKE_sgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfs_work$descriptor() {
        return LAPACKE_dgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfs_work$handle() {
        return LAPACKE_dgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfs_work$address() {
        return LAPACKE_dgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfs_work$descriptor() {
        return LAPACKE_cgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfs_work$handle() {
        return LAPACKE_cgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfs_work$address() {
        return LAPACKE_cgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfs_work$descriptor() {
        return LAPACKE_zgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfs_work$handle() {
        return LAPACKE_zgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfs_work$address() {
        return LAPACKE_zgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfsx_work$descriptor() {
        return LAPACKE_sgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfsx_work$handle() {
        return LAPACKE_sgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfsx_work$address() {
        return LAPACKE_sgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfsx_work$descriptor() {
        return LAPACKE_dgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfsx_work$handle() {
        return LAPACKE_dgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfsx_work$address() {
        return LAPACKE_dgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfsx_work$descriptor() {
        return LAPACKE_cgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfsx_work$handle() {
        return LAPACKE_cgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfsx_work$address() {
        return LAPACKE_cgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfsx_work$descriptor() {
        return LAPACKE_zgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfsx_work$handle() {
        return LAPACKE_zgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfsx_work$address() {
        return LAPACKE_zgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsv_work$descriptor() {
        return LAPACKE_sgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbsv_work$handle() {
        return LAPACKE_sgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbsv_work$address() {
        return LAPACKE_sgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsv_work$descriptor() {
        return LAPACKE_dgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbsv_work$handle() {
        return LAPACKE_dgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbsv_work$address() {
        return LAPACKE_dgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsv_work$descriptor() {
        return LAPACKE_cgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbsv_work$handle() {
        return LAPACKE_cgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbsv_work$address() {
        return LAPACKE_cgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsv_work$descriptor() {
        return LAPACKE_zgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbsv_work$handle() {
        return LAPACKE_zgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbsv_work$address() {
        return LAPACKE_zgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvx_work$descriptor() {
        return LAPACKE_sgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvx_work$handle() {
        return LAPACKE_sgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvx_work$address() {
        return LAPACKE_sgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvx_work$descriptor() {
        return LAPACKE_dgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvx_work$handle() {
        return LAPACKE_dgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvx_work$address() {
        return LAPACKE_dgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvx_work$descriptor() {
        return LAPACKE_cgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvx_work$handle() {
        return LAPACKE_cgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvx_work$address() {
        return LAPACKE_cgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvx_work$descriptor() {
        return LAPACKE_zgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvx_work$handle() {
        return LAPACKE_zgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvx_work$address() {
        return LAPACKE_zgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvxx_work$descriptor() {
        return LAPACKE_sgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvxx_work$handle() {
        return LAPACKE_sgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvxx_work$address() {
        return LAPACKE_sgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvxx_work$descriptor() {
        return LAPACKE_dgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvxx_work$handle() {
        return LAPACKE_dgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvxx_work$address() {
        return LAPACKE_dgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvxx_work$descriptor() {
        return LAPACKE_cgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvxx_work$handle() {
        return LAPACKE_cgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvxx_work$address() {
        return LAPACKE_cgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvxx_work$descriptor() {
        return LAPACKE_zgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvxx_work$handle() {
        return LAPACKE_zgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvxx_work$address() {
        return LAPACKE_zgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrf_work$descriptor() {
        return LAPACKE_sgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrf_work$handle() {
        return LAPACKE_sgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrf_work$address() {
        return LAPACKE_sgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrf_work$descriptor() {
        return LAPACKE_dgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrf_work$handle() {
        return LAPACKE_dgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrf_work$address() {
        return LAPACKE_dgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrf_work$descriptor() {
        return LAPACKE_cgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrf_work$handle() {
        return LAPACKE_cgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrf_work$address() {
        return LAPACKE_cgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrf_work$descriptor() {
        return LAPACKE_zgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrf_work$handle() {
        return LAPACKE_zgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrf_work$address() {
        return LAPACKE_zgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrs_work$descriptor() {
        return LAPACKE_sgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrs_work$handle() {
        return LAPACKE_sgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrs_work$address() {
        return LAPACKE_sgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrs_work$descriptor() {
        return LAPACKE_dgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrs_work$handle() {
        return LAPACKE_dgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrs_work$address() {
        return LAPACKE_dgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrs_work$descriptor() {
        return LAPACKE_cgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrs_work$handle() {
        return LAPACKE_cgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrs_work$address() {
        return LAPACKE_cgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrs_work$descriptor() {
        return LAPACKE_zgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrs_work$handle() {
        return LAPACKE_zgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrs_work$address() {
        return LAPACKE_zgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebak_work$descriptor() {
        return LAPACKE_sgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sgebak_work$handle() {
        return LAPACKE_sgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sgebak_work$address() {
        return LAPACKE_sgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebak_work$descriptor() {
        return LAPACKE_dgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dgebak_work$handle() {
        return LAPACKE_dgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dgebak_work$address() {
        return LAPACKE_dgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebak_work$descriptor() {
        return LAPACKE_cgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cgebak_work$handle() {
        return LAPACKE_cgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cgebak_work$address() {
        return LAPACKE_cgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebak_work$descriptor() {
        return LAPACKE_zgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zgebak_work$handle() {
        return LAPACKE_zgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zgebak_work$address() {
        return LAPACKE_zgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebal_work$descriptor() {
        return LAPACKE_sgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_sgebal_work$handle() {
        return LAPACKE_sgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_sgebal_work$address() {
        return LAPACKE_sgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_sgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_sgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebal_work$descriptor() {
        return LAPACKE_dgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dgebal_work$handle() {
        return LAPACKE_dgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dgebal_work$address() {
        return LAPACKE_dgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_dgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_dgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebal_work$descriptor() {
        return LAPACKE_cgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_cgebal_work$handle() {
        return LAPACKE_cgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_cgebal_work$address() {
        return LAPACKE_cgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_cgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_cgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebal_work$descriptor() {
        return LAPACKE_zgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_zgebal_work$handle() {
        return LAPACKE_zgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_zgebal_work$address() {
        return LAPACKE_zgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_zgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_zgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebrd_work$descriptor() {
        return LAPACKE_sgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgebrd_work$handle() {
        return LAPACKE_sgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgebrd_work$address() {
        return LAPACKE_sgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebrd_work$descriptor() {
        return LAPACKE_dgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgebrd_work$handle() {
        return LAPACKE_dgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgebrd_work$address() {
        return LAPACKE_dgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebrd_work$descriptor() {
        return LAPACKE_cgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgebrd_work$handle() {
        return LAPACKE_cgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgebrd_work$address() {
        return LAPACKE_cgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebrd_work$descriptor() {
        return LAPACKE_zgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgebrd_work$handle() {
        return LAPACKE_zgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgebrd_work$address() {
        return LAPACKE_zgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgecon_work$descriptor() {
        return LAPACKE_sgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgecon_work$handle() {
        return LAPACKE_sgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgecon_work$address() {
        return LAPACKE_sgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgecon_work$descriptor() {
        return LAPACKE_dgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgecon_work$handle() {
        return LAPACKE_dgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgecon_work$address() {
        return LAPACKE_dgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgecon_work$descriptor() {
        return LAPACKE_cgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgecon_work$handle() {
        return LAPACKE_cgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgecon_work$address() {
        return LAPACKE_cgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgecon_work$descriptor() {
        return LAPACKE_zgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgecon_work$handle() {
        return LAPACKE_zgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgecon_work$address() {
        return LAPACKE_zgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequ_work$descriptor() {
        return LAPACKE_sgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequ_work$handle() {
        return LAPACKE_sgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequ_work$address() {
        return LAPACKE_sgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequ_work$descriptor() {
        return LAPACKE_dgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequ_work$handle() {
        return LAPACKE_dgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequ_work$address() {
        return LAPACKE_dgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequ_work$descriptor() {
        return LAPACKE_cgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequ_work$handle() {
        return LAPACKE_cgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequ_work$address() {
        return LAPACKE_cgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequ_work$descriptor() {
        return LAPACKE_zgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequ_work$handle() {
        return LAPACKE_zgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequ_work$address() {
        return LAPACKE_zgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequb_work$descriptor() {
        return LAPACKE_sgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequb_work$handle() {
        return LAPACKE_sgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequb_work$address() {
        return LAPACKE_sgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequb_work$descriptor() {
        return LAPACKE_dgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequb_work$handle() {
        return LAPACKE_dgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequb_work$address() {
        return LAPACKE_dgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequb_work$descriptor() {
        return LAPACKE_cgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequb_work$handle() {
        return LAPACKE_cgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequb_work$address() {
        return LAPACKE_cgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequb_work$descriptor() {
        return LAPACKE_zgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequb_work$handle() {
        return LAPACKE_zgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequb_work$address() {
        return LAPACKE_zgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgees_work$descriptor() {
        return LAPACKE_sgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgees_work$handle() {
        return LAPACKE_sgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgees_work$address() {
        return LAPACKE_sgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgees_work$descriptor() {
        return LAPACKE_dgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgees_work$handle() {
        return LAPACKE_dgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgees_work$address() {
        return LAPACKE_dgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgees_work$descriptor() {
        return LAPACKE_cgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgees_work$handle() {
        return LAPACKE_cgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgees_work$address() {
        return LAPACKE_cgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgees_work$descriptor() {
        return LAPACKE_zgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgees_work$handle() {
        return LAPACKE_zgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgees_work$address() {
        return LAPACKE_zgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeesx_work$descriptor() {
        return LAPACKE_sgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeesx_work$handle() {
        return LAPACKE_sgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeesx_work$address() {
        return LAPACKE_sgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeesx_work$descriptor() {
        return LAPACKE_dgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeesx_work$handle() {
        return LAPACKE_dgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeesx_work$address() {
        return LAPACKE_dgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeesx_work$descriptor() {
        return LAPACKE_cgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeesx_work$handle() {
        return LAPACKE_cgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeesx_work$address() {
        return LAPACKE_cgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeesx_work$descriptor() {
        return LAPACKE_zgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeesx_work$handle() {
        return LAPACKE_zgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeesx_work$address() {
        return LAPACKE_zgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeev_work$descriptor() {
        return LAPACKE_sgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeev_work$handle() {
        return LAPACKE_sgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeev_work$address() {
        return LAPACKE_sgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeev_work$descriptor() {
        return LAPACKE_dgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeev_work$handle() {
        return LAPACKE_dgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeev_work$address() {
        return LAPACKE_dgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeev_work$descriptor() {
        return LAPACKE_cgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeev_work$handle() {
        return LAPACKE_cgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeev_work$address() {
        return LAPACKE_cgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeev_work$descriptor() {
        return LAPACKE_zgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeev_work$handle() {
        return LAPACKE_zgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeev_work$address() {
        return LAPACKE_zgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeevx_work$descriptor() {
        return LAPACKE_sgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeevx_work$handle() {
        return LAPACKE_sgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeevx_work$address() {
        return LAPACKE_sgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeevx_work$descriptor() {
        return LAPACKE_dgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeevx_work$handle() {
        return LAPACKE_dgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeevx_work$address() {
        return LAPACKE_dgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeevx_work$descriptor() {
        return LAPACKE_cgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeevx_work$handle() {
        return LAPACKE_cgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeevx_work$address() {
        return LAPACKE_cgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeevx_work$descriptor() {
        return LAPACKE_zgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeevx_work$handle() {
        return LAPACKE_zgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeevx_work$address() {
        return LAPACKE_zgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgehrd_work$descriptor() {
        return LAPACKE_sgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgehrd_work$handle() {
        return LAPACKE_sgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgehrd_work$address() {
        return LAPACKE_sgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgehrd_work$descriptor() {
        return LAPACKE_dgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgehrd_work$handle() {
        return LAPACKE_dgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgehrd_work$address() {
        return LAPACKE_dgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgehrd_work$descriptor() {
        return LAPACKE_cgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgehrd_work$handle() {
        return LAPACKE_cgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgehrd_work$address() {
        return LAPACKE_cgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgehrd_work$descriptor() {
        return LAPACKE_zgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgehrd_work$handle() {
        return LAPACKE_zgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgehrd_work$address() {
        return LAPACKE_zgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgejsv_work$descriptor() {
        return LAPACKE_sgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgejsv_work$handle() {
        return LAPACKE_sgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgejsv_work$address() {
        return LAPACKE_sgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgejsv_work$descriptor() {
        return LAPACKE_dgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgejsv_work$handle() {
        return LAPACKE_dgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgejsv_work$address() {
        return LAPACKE_dgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgejsv_work$descriptor() {
        return LAPACKE_cgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgejsv_work$handle() {
        return LAPACKE_cgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgejsv_work$address() {
        return LAPACKE_cgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment work, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgejsv_work$descriptor() {
        return LAPACKE_zgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgejsv_work$handle() {
        return LAPACKE_zgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgejsv_work$address() {
        return LAPACKE_zgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment work, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq2_work$descriptor() {
        return LAPACKE_sgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgelq2_work$handle() {
        return LAPACKE_sgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgelq2_work$address() {
        return LAPACKE_sgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq2_work$descriptor() {
        return LAPACKE_dgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgelq2_work$handle() {
        return LAPACKE_dgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgelq2_work$address() {
        return LAPACKE_dgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq2_work$descriptor() {
        return LAPACKE_cgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgelq2_work$handle() {
        return LAPACKE_cgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgelq2_work$address() {
        return LAPACKE_cgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq2_work$descriptor() {
        return LAPACKE_zgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgelq2_work$handle() {
        return LAPACKE_zgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgelq2_work$address() {
        return LAPACKE_zgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelqf_work$descriptor() {
        return LAPACKE_sgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelqf_work$handle() {
        return LAPACKE_sgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelqf_work$address() {
        return LAPACKE_sgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelqf_work$descriptor() {
        return LAPACKE_dgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelqf_work$handle() {
        return LAPACKE_dgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelqf_work$address() {
        return LAPACKE_dgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelqf_work$descriptor() {
        return LAPACKE_cgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelqf_work$handle() {
        return LAPACKE_cgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelqf_work$address() {
        return LAPACKE_cgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelqf_work$descriptor() {
        return LAPACKE_zgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelqf_work$handle() {
        return LAPACKE_zgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelqf_work$address() {
        return LAPACKE_zgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgels_work$descriptor() {
        return LAPACKE_sgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgels_work$handle() {
        return LAPACKE_sgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgels_work$address() {
        return LAPACKE_sgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgels_work$descriptor() {
        return LAPACKE_dgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgels_work$handle() {
        return LAPACKE_dgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgels_work$address() {
        return LAPACKE_dgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgels_work$descriptor() {
        return LAPACKE_cgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgels_work$handle() {
        return LAPACKE_cgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgels_work$address() {
        return LAPACKE_cgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgels_work$descriptor() {
        return LAPACKE_zgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgels_work$handle() {
        return LAPACKE_zgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgels_work$address() {
        return LAPACKE_zgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsd_work$descriptor() {
        return LAPACKE_sgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelsd_work$handle() {
        return LAPACKE_sgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelsd_work$address() {
        return LAPACKE_sgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsd_work$descriptor() {
        return LAPACKE_dgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelsd_work$handle() {
        return LAPACKE_dgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelsd_work$address() {
        return LAPACKE_dgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsd_work$descriptor() {
        return LAPACKE_cgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelsd_work$handle() {
        return LAPACKE_cgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelsd_work$address() {
        return LAPACKE_cgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsd_work$descriptor() {
        return LAPACKE_zgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelsd_work$handle() {
        return LAPACKE_zgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelsd_work$address() {
        return LAPACKE_zgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelss_work$descriptor() {
        return LAPACKE_sgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelss_work$handle() {
        return LAPACKE_sgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelss_work$address() {
        return LAPACKE_sgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelss_work$descriptor() {
        return LAPACKE_dgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelss_work$handle() {
        return LAPACKE_dgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelss_work$address() {
        return LAPACKE_dgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelss_work$descriptor() {
        return LAPACKE_cgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelss_work$handle() {
        return LAPACKE_cgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelss_work$address() {
        return LAPACKE_cgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelss_work$descriptor() {
        return LAPACKE_zgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelss_work$handle() {
        return LAPACKE_zgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelss_work$address() {
        return LAPACKE_zgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsy_work$descriptor() {
        return LAPACKE_sgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelsy_work$handle() {
        return LAPACKE_sgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelsy_work$address() {
        return LAPACKE_sgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsy_work$descriptor() {
        return LAPACKE_dgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelsy_work$handle() {
        return LAPACKE_dgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelsy_work$address() {
        return LAPACKE_dgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsy_work$descriptor() {
        return LAPACKE_cgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelsy_work$handle() {
        return LAPACKE_cgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelsy_work$address() {
        return LAPACKE_cgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsy_work$descriptor() {
        return LAPACKE_zgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelsy_work$handle() {
        return LAPACKE_zgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelsy_work$address() {
        return LAPACKE_zgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqlf_work$descriptor() {
        return LAPACKE_sgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqlf_work$handle() {
        return LAPACKE_sgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqlf_work$address() {
        return LAPACKE_sgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqlf_work$descriptor() {
        return LAPACKE_dgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqlf_work$handle() {
        return LAPACKE_dgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqlf_work$address() {
        return LAPACKE_dgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqlf_work$descriptor() {
        return LAPACKE_cgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqlf_work$handle() {
        return LAPACKE_cgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqlf_work$address() {
        return LAPACKE_cgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqlf_work$descriptor() {
        return LAPACKE_zgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqlf_work$handle() {
        return LAPACKE_zgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqlf_work$address() {
        return LAPACKE_zgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqp3_work$descriptor() {
        return LAPACKE_sgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqp3_work$handle() {
        return LAPACKE_sgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqp3_work$address() {
        return LAPACKE_sgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqp3_work$descriptor() {
        return LAPACKE_dgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqp3_work$handle() {
        return LAPACKE_dgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqp3_work$address() {
        return LAPACKE_dgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqp3_work$descriptor() {
        return LAPACKE_cgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqp3_work$handle() {
        return LAPACKE_cgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqp3_work$address() {
        return LAPACKE_cgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqp3_work$descriptor() {
        return LAPACKE_zgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqp3_work$handle() {
        return LAPACKE_zgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqp3_work$address() {
        return LAPACKE_zgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqpf_work$descriptor() {
        return LAPACKE_sgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqpf_work$handle() {
        return LAPACKE_sgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqpf_work$address() {
        return LAPACKE_sgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqpf_work$descriptor() {
        return LAPACKE_dgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqpf_work$handle() {
        return LAPACKE_dgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqpf_work$address() {
        return LAPACKE_dgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqpf_work$descriptor() {
        return LAPACKE_cgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqpf_work$handle() {
        return LAPACKE_cgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqpf_work$address() {
        return LAPACKE_cgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqpf_work$descriptor() {
        return LAPACKE_zgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqpf_work$handle() {
        return LAPACKE_zgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqpf_work$address() {
        return LAPACKE_zgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr2_work$descriptor() {
        return LAPACKE_sgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr2_work$handle() {
        return LAPACKE_sgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr2_work$address() {
        return LAPACKE_sgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr2_work$descriptor() {
        return LAPACKE_dgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr2_work$handle() {
        return LAPACKE_dgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr2_work$address() {
        return LAPACKE_dgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr2_work$descriptor() {
        return LAPACKE_cgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr2_work$handle() {
        return LAPACKE_cgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr2_work$address() {
        return LAPACKE_cgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr2_work$descriptor() {
        return LAPACKE_zgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr2_work$handle() {
        return LAPACKE_zgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr2_work$address() {
        return LAPACKE_zgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrf_work$descriptor() {
        return LAPACKE_sgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrf_work$handle() {
        return LAPACKE_sgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrf_work$address() {
        return LAPACKE_sgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrf_work$descriptor() {
        return LAPACKE_dgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrf_work$handle() {
        return LAPACKE_dgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrf_work$address() {
        return LAPACKE_dgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrf_work$descriptor() {
        return LAPACKE_cgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrf_work$handle() {
        return LAPACKE_cgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrf_work$address() {
        return LAPACKE_cgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrf_work$descriptor() {
        return LAPACKE_zgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrf_work$handle() {
        return LAPACKE_zgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrf_work$address() {
        return LAPACKE_zgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrfp_work$descriptor() {
        return LAPACKE_sgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrfp_work$handle() {
        return LAPACKE_sgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrfp_work$address() {
        return LAPACKE_sgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrfp_work$descriptor() {
        return LAPACKE_dgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrfp_work$handle() {
        return LAPACKE_dgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrfp_work$address() {
        return LAPACKE_dgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrfp_work$descriptor() {
        return LAPACKE_cgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrfp_work$handle() {
        return LAPACKE_cgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrfp_work$address() {
        return LAPACKE_cgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrfp_work$descriptor() {
        return LAPACKE_zgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrfp_work$handle() {
        return LAPACKE_zgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrfp_work$address() {
        return LAPACKE_zgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfs_work$descriptor() {
        return LAPACKE_sgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerfs_work$handle() {
        return LAPACKE_sgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerfs_work$address() {
        return LAPACKE_sgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfs_work$descriptor() {
        return LAPACKE_dgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerfs_work$handle() {
        return LAPACKE_dgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerfs_work$address() {
        return LAPACKE_dgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfs_work$descriptor() {
        return LAPACKE_cgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerfs_work$handle() {
        return LAPACKE_cgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerfs_work$address() {
        return LAPACKE_cgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfs_work$descriptor() {
        return LAPACKE_zgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerfs_work$handle() {
        return LAPACKE_zgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerfs_work$address() {
        return LAPACKE_zgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfsx_work$descriptor() {
        return LAPACKE_sgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerfsx_work$handle() {
        return LAPACKE_sgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerfsx_work$address() {
        return LAPACKE_sgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfsx_work$descriptor() {
        return LAPACKE_dgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerfsx_work$handle() {
        return LAPACKE_dgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerfsx_work$address() {
        return LAPACKE_dgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfsx_work$descriptor() {
        return LAPACKE_cgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerfsx_work$handle() {
        return LAPACKE_cgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerfsx_work$address() {
        return LAPACKE_cgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfsx_work$descriptor() {
        return LAPACKE_zgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerfsx_work$handle() {
        return LAPACKE_zgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerfsx_work$address() {
        return LAPACKE_zgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerqf_work$descriptor() {
        return LAPACKE_sgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerqf_work$handle() {
        return LAPACKE_sgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerqf_work$address() {
        return LAPACKE_sgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerqf_work$descriptor() {
        return LAPACKE_dgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerqf_work$handle() {
        return LAPACKE_dgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerqf_work$address() {
        return LAPACKE_dgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerqf_work$descriptor() {
        return LAPACKE_cgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerqf_work$handle() {
        return LAPACKE_cgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerqf_work$address() {
        return LAPACKE_cgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerqf_work$descriptor() {
        return LAPACKE_zgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerqf_work$handle() {
        return LAPACKE_zgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerqf_work$address() {
        return LAPACKE_zgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesdd_work$descriptor() {
        return LAPACKE_sgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesdd_work$handle() {
        return LAPACKE_sgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesdd_work$address() {
        return LAPACKE_sgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesdd_work$descriptor() {
        return LAPACKE_dgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesdd_work$handle() {
        return LAPACKE_dgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesdd_work$address() {
        return LAPACKE_dgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesdd_work$descriptor() {
        return LAPACKE_cgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesdd_work$handle() {
        return LAPACKE_cgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesdd_work$address() {
        return LAPACKE_cgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesdd_work$descriptor() {
        return LAPACKE_zgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesdd_work$handle() {
        return LAPACKE_zgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesdd_work$address() {
        return LAPACKE_zgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesv_work$descriptor() {
        return LAPACKE_sgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgesv_work$handle() {
        return LAPACKE_sgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgesv_work$address() {
        return LAPACKE_sgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesv_work$descriptor() {
        return LAPACKE_dgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgesv_work$handle() {
        return LAPACKE_dgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgesv_work$address() {
        return LAPACKE_dgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesv_work$descriptor() {
        return LAPACKE_cgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgesv_work$handle() {
        return LAPACKE_cgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgesv_work$address() {
        return LAPACKE_cgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesv_work$descriptor() {
        return LAPACKE_zgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgesv_work$handle() {
        return LAPACKE_zgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgesv_work$address() {
        return LAPACKE_zgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsgesv_work$descriptor() {
        return LAPACKE_dsgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsgesv_work$handle() {
        return LAPACKE_dsgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsgesv_work$address() {
        return LAPACKE_dsgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment iter) {
        var mh$ = LAPACKE_dsgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zcgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcgesv_work$descriptor() {
        return LAPACKE_zcgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcgesv_work$handle() {
        return LAPACKE_zcgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcgesv_work$address() {
        return LAPACKE_zcgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter) {
        var mh$ = LAPACKE_zcgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, rwork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, rwork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvd_work$descriptor() {
        return LAPACKE_sgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvd_work$handle() {
        return LAPACKE_sgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvd_work$address() {
        return LAPACKE_sgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvd_work$descriptor() {
        return LAPACKE_dgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvd_work$handle() {
        return LAPACKE_dgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvd_work$address() {
        return LAPACKE_dgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvd_work$descriptor() {
        return LAPACKE_cgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvd_work$handle() {
        return LAPACKE_cgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvd_work$address() {
        return LAPACKE_cgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvd_work$descriptor() {
        return LAPACKE_zgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvd_work$handle() {
        return LAPACKE_zgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvd_work$address() {
        return LAPACKE_zgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdx_work$descriptor() {
        return LAPACKE_sgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdx_work$handle() {
        return LAPACKE_sgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdx_work$address() {
        return LAPACKE_sgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdx_work$descriptor() {
        return LAPACKE_dgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdx_work$handle() {
        return LAPACKE_dgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdx_work$address() {
        return LAPACKE_dgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdx_work$descriptor() {
        return LAPACKE_cgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdx_work$handle() {
        return LAPACKE_cgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdx_work$address() {
        return LAPACKE_cgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdx_work$descriptor() {
        return LAPACKE_zgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdx_work$handle() {
        return LAPACKE_zgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdx_work$address() {
        return LAPACKE_zgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdq_work$descriptor() {
        return LAPACKE_sgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdq_work$handle() {
        return LAPACKE_sgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdq_work$address() {
        return LAPACKE_sgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_sgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment work, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_sgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdq_work$descriptor() {
        return LAPACKE_dgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdq_work$handle() {
        return LAPACKE_dgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdq_work$address() {
        return LAPACKE_dgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_dgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment work, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_dgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdq_work$descriptor() {
        return LAPACKE_cgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdq_work$handle() {
        return LAPACKE_cgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdq_work$address() {
        return LAPACKE_cgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment cwork, int lcwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdq_work$descriptor() {
        return LAPACKE_zgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdq_work$handle() {
        return LAPACKE_zgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdq_work$address() {
        return LAPACKE_zgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment cwork, int lcwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvj_work$descriptor() {
        return LAPACKE_sgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvj_work$handle() {
        return LAPACKE_sgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvj_work$address() {
        return LAPACKE_sgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvj_work$descriptor() {
        return LAPACKE_dgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvj_work$handle() {
        return LAPACKE_dgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvj_work$address() {
        return LAPACKE_dgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvj_work$descriptor() {
        return LAPACKE_cgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvj_work$handle() {
        return LAPACKE_cgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvj_work$address() {
        return LAPACKE_cgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvj_work$descriptor() {
        return LAPACKE_zgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvj_work$handle() {
        return LAPACKE_zgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvj_work$address() {
        return LAPACKE_zgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvx_work$descriptor() {
        return LAPACKE_sgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvx_work$handle() {
        return LAPACKE_sgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvx_work$address() {
        return LAPACKE_sgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvx_work$descriptor() {
        return LAPACKE_dgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvx_work$handle() {
        return LAPACKE_dgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvx_work$address() {
        return LAPACKE_dgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvx_work$descriptor() {
        return LAPACKE_cgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvx_work$handle() {
        return LAPACKE_cgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvx_work$address() {
        return LAPACKE_cgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvx_work$descriptor() {
        return LAPACKE_zgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvx_work$handle() {
        return LAPACKE_zgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvx_work$address() {
        return LAPACKE_zgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvxx_work$descriptor() {
        return LAPACKE_sgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvxx_work$handle() {
        return LAPACKE_sgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvxx_work$address() {
        return LAPACKE_sgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvxx_work$descriptor() {
        return LAPACKE_dgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvxx_work$handle() {
        return LAPACKE_dgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvxx_work$address() {
        return LAPACKE_dgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvxx_work$descriptor() {
        return LAPACKE_cgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvxx_work$handle() {
        return LAPACKE_cgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvxx_work$address() {
        return LAPACKE_cgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvxx_work$descriptor() {
        return LAPACKE_zgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvxx_work$handle() {
        return LAPACKE_zgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvxx_work$address() {
        return LAPACKE_zgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetf2_work$descriptor() {
        return LAPACKE_sgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetf2_work$handle() {
        return LAPACKE_sgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetf2_work$address() {
        return LAPACKE_sgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetf2_work$descriptor() {
        return LAPACKE_dgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetf2_work$handle() {
        return LAPACKE_dgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetf2_work$address() {
        return LAPACKE_dgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetf2_work$descriptor() {
        return LAPACKE_cgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetf2_work$handle() {
        return LAPACKE_cgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetf2_work$address() {
        return LAPACKE_cgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetf2_work$descriptor() {
        return LAPACKE_zgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetf2_work$handle() {
        return LAPACKE_zgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetf2_work$address() {
        return LAPACKE_zgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf_work$descriptor() {
        return LAPACKE_sgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf_work$handle() {
        return LAPACKE_sgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf_work$address() {
        return LAPACKE_sgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf_work$descriptor() {
        return LAPACKE_dgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf_work$handle() {
        return LAPACKE_dgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf_work$address() {
        return LAPACKE_dgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf_work$descriptor() {
        return LAPACKE_cgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf_work$handle() {
        return LAPACKE_cgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf_work$address() {
        return LAPACKE_cgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf_work$descriptor() {
        return LAPACKE_zgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf_work$handle() {
        return LAPACKE_zgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf_work$address() {
        return LAPACKE_zgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf2_work$descriptor() {
        return LAPACKE_sgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf2_work$handle() {
        return LAPACKE_sgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf2_work$address() {
        return LAPACKE_sgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf2_work$descriptor() {
        return LAPACKE_dgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf2_work$handle() {
        return LAPACKE_dgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf2_work$address() {
        return LAPACKE_dgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf2_work$descriptor() {
        return LAPACKE_cgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf2_work$handle() {
        return LAPACKE_cgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf2_work$address() {
        return LAPACKE_cgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf2_work$descriptor() {
        return LAPACKE_zgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf2_work$handle() {
        return LAPACKE_zgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf2_work$address() {
        return LAPACKE_zgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetri_work$descriptor() {
        return LAPACKE_sgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgetri_work$handle() {
        return LAPACKE_sgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgetri_work$address() {
        return LAPACKE_sgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetri_work$descriptor() {
        return LAPACKE_dgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgetri_work$handle() {
        return LAPACKE_dgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgetri_work$address() {
        return LAPACKE_dgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetri_work$descriptor() {
        return LAPACKE_cgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgetri_work$handle() {
        return LAPACKE_cgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgetri_work$address() {
        return LAPACKE_cgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetri_work$descriptor() {
        return LAPACKE_zgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgetri_work$handle() {
        return LAPACKE_zgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgetri_work$address() {
        return LAPACKE_zgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrs_work$descriptor() {
        return LAPACKE_sgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgetrs_work$handle() {
        return LAPACKE_sgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgetrs_work$address() {
        return LAPACKE_sgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrs_work$descriptor() {
        return LAPACKE_dgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgetrs_work$handle() {
        return LAPACKE_dgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgetrs_work$address() {
        return LAPACKE_dgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrs_work$descriptor() {
        return LAPACKE_cgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgetrs_work$handle() {
        return LAPACKE_cgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgetrs_work$address() {
        return LAPACKE_cgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrs_work$descriptor() {
        return LAPACKE_zgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgetrs_work$handle() {
        return LAPACKE_zgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgetrs_work$address() {
        return LAPACKE_zgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbak_work$descriptor() {
        return LAPACKE_sggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sggbak_work$handle() {
        return LAPACKE_sggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sggbak_work$address() {
        return LAPACKE_sggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbak_work$descriptor() {
        return LAPACKE_dggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dggbak_work$handle() {
        return LAPACKE_dggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dggbak_work$address() {
        return LAPACKE_dggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbak_work$descriptor() {
        return LAPACKE_cggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cggbak_work$handle() {
        return LAPACKE_cggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cggbak_work$address() {
        return LAPACKE_cggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbak_work$descriptor() {
        return LAPACKE_zggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zggbak_work$handle() {
        return LAPACKE_zggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zggbak_work$address() {
        return LAPACKE_zggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbal_work$descriptor() {
        return LAPACKE_sggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sggbal_work$handle() {
        return LAPACKE_sggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sggbal_work$address() {
        return LAPACKE_sggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static int LAPACKE_sggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_sggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbal_work$descriptor() {
        return LAPACKE_dggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dggbal_work$handle() {
        return LAPACKE_dggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dggbal_work$address() {
        return LAPACKE_dggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static int LAPACKE_dggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_dggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbal_work$descriptor() {
        return LAPACKE_cggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cggbal_work$handle() {
        return LAPACKE_cggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cggbal_work$address() {
        return LAPACKE_cggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static int LAPACKE_cggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_cggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbal_work$descriptor() {
        return LAPACKE_zggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zggbal_work$handle() {
        return LAPACKE_zggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zggbal_work$address() {
        return LAPACKE_zggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static int LAPACKE_zggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_zggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges_work$descriptor() {
        return LAPACKE_sgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgges_work$handle() {
        return LAPACKE_sgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgges_work$address() {
        return LAPACKE_sgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges_work$descriptor() {
        return LAPACKE_dgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgges_work$handle() {
        return LAPACKE_dgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgges_work$address() {
        return LAPACKE_dgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges_work$descriptor() {
        return LAPACKE_cgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgges_work$handle() {
        return LAPACKE_cgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgges_work$address() {
        return LAPACKE_cgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges_work$descriptor() {
        return LAPACKE_zgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgges_work$handle() {
        return LAPACKE_zgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgges_work$address() {
        return LAPACKE_zgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges3_work$descriptor() {
        return LAPACKE_sgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgges3_work$handle() {
        return LAPACKE_sgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgges3_work$address() {
        return LAPACKE_sgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges3_work$descriptor() {
        return LAPACKE_dgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgges3_work$handle() {
        return LAPACKE_dgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgges3_work$address() {
        return LAPACKE_dgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges3_work$descriptor() {
        return LAPACKE_cgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgges3_work$handle() {
        return LAPACKE_cgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgges3_work$address() {
        return LAPACKE_cgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges3_work$descriptor() {
        return LAPACKE_zgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgges3_work$handle() {
        return LAPACKE_zgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgges3_work$address() {
        return LAPACKE_zgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggesx_work$descriptor() {
        return LAPACKE_sggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sggesx_work$handle() {
        return LAPACKE_sggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sggesx_work$address() {
        return LAPACKE_sggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_sggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggesx_work$descriptor() {
        return LAPACKE_dggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dggesx_work$handle() {
        return LAPACKE_dggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dggesx_work$address() {
        return LAPACKE_dggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_dggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggesx_work$descriptor() {
        return LAPACKE_cggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cggesx_work$handle() {
        return LAPACKE_cggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cggesx_work$address() {
        return LAPACKE_cggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_cggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggesx_work$descriptor() {
        return LAPACKE_zggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zggesx_work$handle() {
        return LAPACKE_zggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zggesx_work$address() {
        return LAPACKE_zggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_zggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev_work$descriptor() {
        return LAPACKE_sggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggev_work$handle() {
        return LAPACKE_sggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggev_work$address() {
        return LAPACKE_sggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev_work$descriptor() {
        return LAPACKE_dggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggev_work$handle() {
        return LAPACKE_dggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggev_work$address() {
        return LAPACKE_dggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev_work$descriptor() {
        return LAPACKE_cggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cggev_work$handle() {
        return LAPACKE_cggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cggev_work$address() {
        return LAPACKE_cggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev_work$descriptor() {
        return LAPACKE_zggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zggev_work$handle() {
        return LAPACKE_zggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zggev_work$address() {
        return LAPACKE_zggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev3_work$descriptor() {
        return LAPACKE_sggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggev3_work$handle() {
        return LAPACKE_sggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggev3_work$address() {
        return LAPACKE_sggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev3_work$descriptor() {
        return LAPACKE_dggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggev3_work$handle() {
        return LAPACKE_dggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggev3_work$address() {
        return LAPACKE_dggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev3_work$descriptor() {
        return LAPACKE_cggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cggev3_work$handle() {
        return LAPACKE_cggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cggev3_work$address() {
        return LAPACKE_cggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev3_work$descriptor() {
        return LAPACKE_zggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zggev3_work$handle() {
        return LAPACKE_zggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zggev3_work$address() {
        return LAPACKE_zggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggevx_work$descriptor() {
        return LAPACKE_sggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sggevx_work$handle() {
        return LAPACKE_sggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sggevx_work$address() {
        return LAPACKE_sggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_sggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggevx_work$descriptor() {
        return LAPACKE_dggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dggevx_work$handle() {
        return LAPACKE_dggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dggevx_work$address() {
        return LAPACKE_dggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_dggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggevx_work$descriptor() {
        return LAPACKE_cggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cggevx_work$handle() {
        return LAPACKE_cggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cggevx_work$address() {
        return LAPACKE_cggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_cggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggevx_work$descriptor() {
        return LAPACKE_zggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zggevx_work$handle() {
        return LAPACKE_zggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zggevx_work$address() {
        return LAPACKE_zggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_zggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggglm_work$descriptor() {
        return LAPACKE_sggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggglm_work$handle() {
        return LAPACKE_sggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggglm_work$address() {
        return LAPACKE_sggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggglm_work$descriptor() {
        return LAPACKE_dggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggglm_work$handle() {
        return LAPACKE_dggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggglm_work$address() {
        return LAPACKE_dggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggglm_work$descriptor() {
        return LAPACKE_cggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggglm_work$handle() {
        return LAPACKE_cggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggglm_work$address() {
        return LAPACKE_cggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggglm_work$descriptor() {
        return LAPACKE_zggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggglm_work$handle() {
        return LAPACKE_zggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggglm_work$address() {
        return LAPACKE_zggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghrd_work$descriptor() {
        return LAPACKE_sgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghrd_work$handle() {
        return LAPACKE_sgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghrd_work$address() {
        return LAPACKE_sgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghrd_work$descriptor() {
        return LAPACKE_dgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghrd_work$handle() {
        return LAPACKE_dgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghrd_work$address() {
        return LAPACKE_dgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghrd_work$descriptor() {
        return LAPACKE_cgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghrd_work$handle() {
        return LAPACKE_cgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghrd_work$address() {
        return LAPACKE_cgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghrd_work$descriptor() {
        return LAPACKE_zgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghrd_work$handle() {
        return LAPACKE_zgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghrd_work$address() {
        return LAPACKE_zgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghd3_work$descriptor() {
        return LAPACKE_sgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgghd3_work$handle() {
        return LAPACKE_sgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgghd3_work$address() {
        return LAPACKE_sgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghd3_work$descriptor() {
        return LAPACKE_dgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgghd3_work$handle() {
        return LAPACKE_dgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgghd3_work$address() {
        return LAPACKE_dgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghd3_work$descriptor() {
        return LAPACKE_cgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgghd3_work$handle() {
        return LAPACKE_cgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgghd3_work$address() {
        return LAPACKE_cgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghd3_work$descriptor() {
        return LAPACKE_zgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgghd3_work$handle() {
        return LAPACKE_zgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgghd3_work$address() {
        return LAPACKE_zgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgglse_work$descriptor() {
        return LAPACKE_sgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgglse_work$handle() {
        return LAPACKE_sgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgglse_work$address() {
        return LAPACKE_sgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgglse_work$descriptor() {
        return LAPACKE_dgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgglse_work$handle() {
        return LAPACKE_dgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgglse_work$address() {
        return LAPACKE_dgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgglse_work$descriptor() {
        return LAPACKE_cgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgglse_work$handle() {
        return LAPACKE_cgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgglse_work$address() {
        return LAPACKE_cgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgglse_work$descriptor() {
        return LAPACKE_zgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgglse_work$handle() {
        return LAPACKE_zgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgglse_work$address() {
        return LAPACKE_zgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggqrf_work$descriptor() {
        return LAPACKE_sggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggqrf_work$handle() {
        return LAPACKE_sggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggqrf_work$address() {
        return LAPACKE_sggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggqrf_work$descriptor() {
        return LAPACKE_dggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggqrf_work$handle() {
        return LAPACKE_dggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggqrf_work$address() {
        return LAPACKE_dggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggqrf_work$descriptor() {
        return LAPACKE_cggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggqrf_work$handle() {
        return LAPACKE_cggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggqrf_work$address() {
        return LAPACKE_cggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggqrf_work$descriptor() {
        return LAPACKE_zggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggqrf_work$handle() {
        return LAPACKE_zggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggqrf_work$address() {
        return LAPACKE_zggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggrqf_work$descriptor() {
        return LAPACKE_sggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggrqf_work$handle() {
        return LAPACKE_sggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggrqf_work$address() {
        return LAPACKE_sggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggrqf_work$descriptor() {
        return LAPACKE_dggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggrqf_work$handle() {
        return LAPACKE_dggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggrqf_work$address() {
        return LAPACKE_dggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggrqf_work$descriptor() {
        return LAPACKE_cggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggrqf_work$handle() {
        return LAPACKE_cggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggrqf_work$address() {
        return LAPACKE_cggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggrqf_work$descriptor() {
        return LAPACKE_zggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggrqf_work$handle() {
        return LAPACKE_zggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggrqf_work$address() {
        return LAPACKE_zggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd_work$descriptor() {
        return LAPACKE_sggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd_work$handle() {
        return LAPACKE_sggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd_work$address() {
        return LAPACKE_sggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd_work$descriptor() {
        return LAPACKE_dggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd_work$handle() {
        return LAPACKE_dggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd_work$address() {
        return LAPACKE_dggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd_work$descriptor() {
        return LAPACKE_cggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd_work$handle() {
        return LAPACKE_cggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd_work$address() {
        return LAPACKE_cggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd_work$descriptor() {
        return LAPACKE_zggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd_work$handle() {
        return LAPACKE_zggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd_work$address() {
        return LAPACKE_zggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd3_work$descriptor() {
        return LAPACKE_sggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd3_work$handle() {
        return LAPACKE_sggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd3_work$address() {
        return LAPACKE_sggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd3_work$descriptor() {
        return LAPACKE_dggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd3_work$handle() {
        return LAPACKE_dggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd3_work$address() {
        return LAPACKE_dggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd3_work$descriptor() {
        return LAPACKE_cggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd3_work$handle() {
        return LAPACKE_cggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd3_work$address() {
        return LAPACKE_cggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd3_work$descriptor() {
        return LAPACKE_zggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd3_work$handle() {
        return LAPACKE_zggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd3_work$address() {
        return LAPACKE_zggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp_work$descriptor() {
        return LAPACKE_sggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp_work$handle() {
        return LAPACKE_sggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp_work$address() {
        return LAPACKE_sggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp_work$descriptor() {
        return LAPACKE_dggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp_work$handle() {
        return LAPACKE_dggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp_work$address() {
        return LAPACKE_dggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp_work$descriptor() {
        return LAPACKE_cggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp_work$handle() {
        return LAPACKE_cggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp_work$address() {
        return LAPACKE_cggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp_work$descriptor() {
        return LAPACKE_zggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp_work$handle() {
        return LAPACKE_zggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp_work$address() {
        return LAPACKE_zggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp3_work$descriptor() {
        return LAPACKE_sggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp3_work$handle() {
        return LAPACKE_sggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp3_work$address() {
        return LAPACKE_sggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp3_work$descriptor() {
        return LAPACKE_dggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp3_work$handle() {
        return LAPACKE_dggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp3_work$address() {
        return LAPACKE_dggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp3_work$descriptor() {
        return LAPACKE_cggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp3_work$handle() {
        return LAPACKE_cggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp3_work$address() {
        return LAPACKE_cggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp3_work$descriptor() {
        return LAPACKE_zggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp3_work$handle() {
        return LAPACKE_zggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp3_work$address() {
        return LAPACKE_zggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtcon_work$descriptor() {
        return LAPACKE_sgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtcon_work$handle() {
        return LAPACKE_sgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtcon_work$address() {
        return LAPACKE_sgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtcon_work$descriptor() {
        return LAPACKE_dgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtcon_work$handle() {
        return LAPACKE_dgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtcon_work$address() {
        return LAPACKE_dgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtcon_work$descriptor() {
        return LAPACKE_cgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgtcon_work$handle() {
        return LAPACKE_cgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgtcon_work$address() {
        return LAPACKE_cgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtcon_work$descriptor() {
        return LAPACKE_zgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgtcon_work$handle() {
        return LAPACKE_zgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgtcon_work$address() {
        return LAPACKE_zgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtrfs_work$descriptor() {
        return LAPACKE_sgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtrfs_work$handle() {
        return LAPACKE_sgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtrfs_work$address() {
        return LAPACKE_sgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtrfs_work$descriptor() {
        return LAPACKE_dgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtrfs_work$handle() {
        return LAPACKE_dgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtrfs_work$address() {
        return LAPACKE_dgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtrfs_work$descriptor() {
        return LAPACKE_cgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgtrfs_work$handle() {
        return LAPACKE_cgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgtrfs_work$address() {
        return LAPACKE_cgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtrfs_work$descriptor() {
        return LAPACKE_zgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgtrfs_work$handle() {
        return LAPACKE_zgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgtrfs_work$address() {
        return LAPACKE_zgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsv_work$descriptor() {
        return LAPACKE_sgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgtsv_work$handle() {
        return LAPACKE_sgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgtsv_work$address() {
        return LAPACKE_sgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsv_work$descriptor() {
        return LAPACKE_dgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgtsv_work$handle() {
        return LAPACKE_dgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgtsv_work$address() {
        return LAPACKE_dgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsv_work$descriptor() {
        return LAPACKE_cgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgtsv_work$handle() {
        return LAPACKE_cgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgtsv_work$address() {
        return LAPACKE_cgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsv_work$descriptor() {
        return LAPACKE_zgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgtsv_work$handle() {
        return LAPACKE_zgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgtsv_work$address() {
        return LAPACKE_zgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsvx_work$descriptor() {
        return LAPACKE_sgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtsvx_work$handle() {
        return LAPACKE_sgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtsvx_work$address() {
        return LAPACKE_sgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsvx_work$descriptor() {
        return LAPACKE_dgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtsvx_work$handle() {
        return LAPACKE_dgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtsvx_work$address() {
        return LAPACKE_dgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsvx_work$descriptor() {
        return LAPACKE_cgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgtsvx_work$handle() {
        return LAPACKE_cgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgtsvx_work$address() {
        return LAPACKE_cgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsvx_work$descriptor() {
        return LAPACKE_zgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgtsvx_work$handle() {
        return LAPACKE_zgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgtsvx_work$address() {
        return LAPACKE_zgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrf_work$descriptor() {
        return LAPACKE_sgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgttrf_work$handle() {
        return LAPACKE_sgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgttrf_work$address() {
        return LAPACKE_sgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_sgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrf_work$descriptor() {
        return LAPACKE_dgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgttrf_work$handle() {
        return LAPACKE_dgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgttrf_work$address() {
        return LAPACKE_dgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_dgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrf_work$descriptor() {
        return LAPACKE_cgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgttrf_work$handle() {
        return LAPACKE_cgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgttrf_work$address() {
        return LAPACKE_cgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_cgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrf_work$descriptor() {
        return LAPACKE_zgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgttrf_work$handle() {
        return LAPACKE_zgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgttrf_work$address() {
        return LAPACKE_zgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_zgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrs_work$descriptor() {
        return LAPACKE_sgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgttrs_work$handle() {
        return LAPACKE_sgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgttrs_work$address() {
        return LAPACKE_sgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrs_work$descriptor() {
        return LAPACKE_dgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgttrs_work$handle() {
        return LAPACKE_dgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgttrs_work$address() {
        return LAPACKE_dgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrs_work$descriptor() {
        return LAPACKE_cgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgttrs_work$handle() {
        return LAPACKE_cgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgttrs_work$address() {
        return LAPACKE_cgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrs_work$descriptor() {
        return LAPACKE_zgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgttrs_work$handle() {
        return LAPACKE_zgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgttrs_work$address() {
        return LAPACKE_zgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev_work$descriptor() {
        return LAPACKE_chbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbev_work$handle() {
        return LAPACKE_chbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbev_work$address() {
        return LAPACKE_chbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev_work$descriptor() {
        return LAPACKE_zhbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbev_work$handle() {
        return LAPACKE_zhbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbev_work$address() {
        return LAPACKE_zhbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd_work$descriptor() {
        return LAPACKE_chbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chbevd_work$handle() {
        return LAPACKE_chbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chbevd_work$address() {
        return LAPACKE_chbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd_work$descriptor() {
        return LAPACKE_zhbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd_work$handle() {
        return LAPACKE_zhbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd_work$address() {
        return LAPACKE_zhbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx_work$descriptor() {
        return LAPACKE_chbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx_work$handle() {
        return LAPACKE_chbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx_work$address() {
        return LAPACKE_chbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx_work$descriptor() {
        return LAPACKE_zhbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx_work$handle() {
        return LAPACKE_zhbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx_work$address() {
        return LAPACKE_zhbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgst_work$descriptor() {
        return LAPACKE_chbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgst_work$handle() {
        return LAPACKE_chbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgst_work$address() {
        return LAPACKE_chbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgst_work$descriptor() {
        return LAPACKE_zhbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgst_work$handle() {
        return LAPACKE_zhbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgst_work$address() {
        return LAPACKE_zhbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgv_work$descriptor() {
        return LAPACKE_chbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgv_work$handle() {
        return LAPACKE_chbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgv_work$address() {
        return LAPACKE_chbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgv_work$descriptor() {
        return LAPACKE_zhbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgv_work$handle() {
        return LAPACKE_zhbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgv_work$address() {
        return LAPACKE_zhbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvd_work$descriptor() {
        return LAPACKE_chbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgvd_work$handle() {
        return LAPACKE_chbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgvd_work$address() {
        return LAPACKE_chbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvd_work$descriptor() {
        return LAPACKE_zhbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvd_work$handle() {
        return LAPACKE_zhbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvd_work$address() {
        return LAPACKE_zhbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvx_work$descriptor() {
        return LAPACKE_chbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbgvx_work$handle() {
        return LAPACKE_chbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbgvx_work$address() {
        return LAPACKE_chbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvx_work$descriptor() {
        return LAPACKE_zhbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvx_work$handle() {
        return LAPACKE_zhbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvx_work$address() {
        return LAPACKE_zhbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbtrd_work$descriptor() {
        return LAPACKE_chbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chbtrd_work$handle() {
        return LAPACKE_chbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chbtrd_work$address() {
        return LAPACKE_chbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static int LAPACKE_chbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_chbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbtrd_work$descriptor() {
        return LAPACKE_zhbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhbtrd_work$handle() {
        return LAPACKE_zhbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhbtrd_work$address() {
        return LAPACKE_zhbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_zhbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_checon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon_work$descriptor() {
        return LAPACKE_checon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_checon_work$handle() {
        return LAPACKE_checon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_checon_work$address() {
        return LAPACKE_checon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_checon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_checon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon_work$descriptor() {
        return LAPACKE_zhecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhecon_work$handle() {
        return LAPACKE_zhecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhecon_work$address() {
        return LAPACKE_zhecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhecon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zhecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheequb_work$descriptor() {
        return LAPACKE_cheequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cheequb_work$handle() {
        return LAPACKE_cheequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cheequb_work$address() {
        return LAPACKE_cheequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static int LAPACKE_cheequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_cheequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheequb_work$descriptor() {
        return LAPACKE_zheequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zheequb_work$handle() {
        return LAPACKE_zheequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zheequb_work$address() {
        return LAPACKE_zheequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static int LAPACKE_zheequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_zheequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev_work$descriptor() {
        return LAPACKE_cheev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cheev_work$handle() {
        return LAPACKE_cheev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cheev_work$address() {
        return LAPACKE_cheev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cheev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cheev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev_work$descriptor() {
        return LAPACKE_zheev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zheev_work$handle() {
        return LAPACKE_zheev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zheev_work$address() {
        return LAPACKE_zheev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zheev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zheev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd_work$descriptor() {
        return LAPACKE_cheevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevd_work$handle() {
        return LAPACKE_cheevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevd_work$address() {
        return LAPACKE_cheevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd_work$descriptor() {
        return LAPACKE_zheevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevd_work$handle() {
        return LAPACKE_zheevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevd_work$address() {
        return LAPACKE_zheevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr_work$descriptor() {
        return LAPACKE_cheevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevr_work$handle() {
        return LAPACKE_cheevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevr_work$address() {
        return LAPACKE_cheevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr_work$descriptor() {
        return LAPACKE_zheevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevr_work$handle() {
        return LAPACKE_zheevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevr_work$address() {
        return LAPACKE_zheevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx_work$descriptor() {
        return LAPACKE_cheevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx_work$handle() {
        return LAPACKE_cheevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx_work$address() {
        return LAPACKE_cheevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx_work$descriptor() {
        return LAPACKE_zheevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx_work$handle() {
        return LAPACKE_zheevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx_work$address() {
        return LAPACKE_zheevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegst_work$descriptor() {
        return LAPACKE_chegst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chegst_work$handle() {
        return LAPACKE_chegst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chegst_work$address() {
        return LAPACKE_chegst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chegst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chegst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegst_work$descriptor() {
        return LAPACKE_zhegst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhegst_work$handle() {
        return LAPACKE_zhegst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhegst_work$address() {
        return LAPACKE_zhegst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhegst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhegst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv_work$descriptor() {
        return LAPACKE_chegv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chegv_work$handle() {
        return LAPACKE_chegv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chegv_work$address() {
        return LAPACKE_chegv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chegv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chegv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv_work$descriptor() {
        return LAPACKE_zhegv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhegv_work$handle() {
        return LAPACKE_zhegv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhegv_work$address() {
        return LAPACKE_zhegv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhegv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhegv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvd_work$descriptor() {
        return LAPACKE_chegvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chegvd_work$handle() {
        return LAPACKE_chegvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chegvd_work$address() {
        return LAPACKE_chegvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chegvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chegvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvd_work$descriptor() {
        return LAPACKE_zhegvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhegvd_work$handle() {
        return LAPACKE_zhegvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhegvd_work$address() {
        return LAPACKE_zhegvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhegvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhegvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvx_work$descriptor() {
        return LAPACKE_chegvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chegvx_work$handle() {
        return LAPACKE_chegvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chegvx_work$address() {
        return LAPACKE_chegvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chegvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chegvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvx_work$descriptor() {
        return LAPACKE_zhegvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhegvx_work$handle() {
        return LAPACKE_zhegvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhegvx_work$address() {
        return LAPACKE_zhegvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhegvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhegvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cherfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfs_work$descriptor() {
        return LAPACKE_cherfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cherfs_work$handle() {
        return LAPACKE_cherfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cherfs_work$address() {
        return LAPACKE_cherfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cherfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cherfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zherfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfs_work$descriptor() {
        return LAPACKE_zherfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zherfs_work$handle() {
        return LAPACKE_zherfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zherfs_work$address() {
        return LAPACKE_zherfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zherfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zherfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cherfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfsx_work$descriptor() {
        return LAPACKE_cherfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cherfsx_work$handle() {
        return LAPACKE_cherfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cherfsx_work$address() {
        return LAPACKE_cherfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cherfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cherfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zherfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfsx_work$descriptor() {
        return LAPACKE_zherfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zherfsx_work$handle() {
        return LAPACKE_zherfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zherfsx_work$address() {
        return LAPACKE_zherfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zherfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zherfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_work$descriptor() {
        return LAPACKE_chesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_work$handle() {
        return LAPACKE_chesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_work$address() {
        return LAPACKE_chesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_work$descriptor() {
        return LAPACKE_zhesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_work$handle() {
        return LAPACKE_zhesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_work$address() {
        return LAPACKE_zhesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvx_work$descriptor() {
        return LAPACKE_chesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chesvx_work$handle() {
        return LAPACKE_chesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chesvx_work$address() {
        return LAPACKE_chesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chesvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvx_work$descriptor() {
        return LAPACKE_zhesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesvx_work$handle() {
        return LAPACKE_zhesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesvx_work$address() {
        return LAPACKE_zhesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhesvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvxx_work$descriptor() {
        return LAPACKE_chesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chesvxx_work$handle() {
        return LAPACKE_chesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chesvxx_work$address() {
        return LAPACKE_chesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chesvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvxx_work$descriptor() {
        return LAPACKE_zhesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesvxx_work$handle() {
        return LAPACKE_zhesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesvxx_work$address() {
        return LAPACKE_zhesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhesvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrd_work$descriptor() {
        return LAPACKE_chetrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrd_work$handle() {
        return LAPACKE_chetrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrd_work$address() {
        return LAPACKE_chetrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrd_work$descriptor() {
        return LAPACKE_zhetrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrd_work$handle() {
        return LAPACKE_zhetrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrd_work$address() {
        return LAPACKE_zhetrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_work$descriptor() {
        return LAPACKE_chetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_work$handle() {
        return LAPACKE_chetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_work$address() {
        return LAPACKE_chetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_work$descriptor() {
        return LAPACKE_zhetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_work$handle() {
        return LAPACKE_zhetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_work$address() {
        return LAPACKE_zhetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri_work$descriptor() {
        return LAPACKE_chetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chetri_work$handle() {
        return LAPACKE_chetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chetri_work$address() {
        return LAPACKE_chetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_chetri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_chetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri_work$descriptor() {
        return LAPACKE_zhetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhetri_work$handle() {
        return LAPACKE_zhetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhetri_work$address() {
        return LAPACKE_zhetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhetri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zhetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_work$descriptor() {
        return LAPACKE_chetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_work$handle() {
        return LAPACKE_chetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_work$address() {
        return LAPACKE_chetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_work$descriptor() {
        return LAPACKE_zhetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_work$handle() {
        return LAPACKE_zhetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_work$address() {
        return LAPACKE_zhetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_chfrk_work$descriptor() {
        return LAPACKE_chfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MethodHandle LAPACKE_chfrk_work$handle() {
        return LAPACKE_chfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MemorySegment LAPACKE_chfrk_work$address() {
        return LAPACKE_chfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static int LAPACKE_chfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_chfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhfrk_work$descriptor() {
        return LAPACKE_zhfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MethodHandle LAPACKE_zhfrk_work$handle() {
        return LAPACKE_zhfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MemorySegment LAPACKE_zhfrk_work$address() {
        return LAPACKE_zhfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static int LAPACKE_zhfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_zhfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_shgeqz_work$descriptor() {
        return LAPACKE_shgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_shgeqz_work$handle() {
        return LAPACKE_shgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_shgeqz_work$address() {
        return LAPACKE_shgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_shgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_shgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhgeqz_work$descriptor() {
        return LAPACKE_dhgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dhgeqz_work$handle() {
        return LAPACKE_dhgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dhgeqz_work$address() {
        return LAPACKE_dhgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dhgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dhgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chgeqz_work$descriptor() {
        return LAPACKE_chgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chgeqz_work$handle() {
        return LAPACKE_chgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chgeqz_work$address() {
        return LAPACKE_chgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhgeqz_work$descriptor() {
        return LAPACKE_zhgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhgeqz_work$handle() {
        return LAPACKE_zhgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhgeqz_work$address() {
        return LAPACKE_zhgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpcon_work$descriptor() {
        return LAPACKE_chpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chpcon_work$handle() {
        return LAPACKE_chpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chpcon_work$address() {
        return LAPACKE_chpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_chpcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_chpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpcon_work$descriptor() {
        return LAPACKE_zhpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhpcon_work$handle() {
        return LAPACKE_zhpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhpcon_work$address() {
        return LAPACKE_zhpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhpcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zhpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpev_work$descriptor() {
        return LAPACKE_chpev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpev_work$handle() {
        return LAPACKE_chpev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpev_work$address() {
        return LAPACKE_chpev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpev_work$descriptor() {
        return LAPACKE_zhpev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpev_work$handle() {
        return LAPACKE_zhpev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpev_work$address() {
        return LAPACKE_zhpev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevd_work$descriptor() {
        return LAPACKE_chpevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chpevd_work$handle() {
        return LAPACKE_chpevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chpevd_work$address() {
        return LAPACKE_chpevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chpevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chpevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevd_work$descriptor() {
        return LAPACKE_zhpevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpevd_work$handle() {
        return LAPACKE_zhpevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpevd_work$address() {
        return LAPACKE_zhpevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhpevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhpevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevx_work$descriptor() {
        return LAPACKE_chpevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpevx_work$handle() {
        return LAPACKE_chpevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpevx_work$address() {
        return LAPACKE_chpevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chpevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chpevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevx_work$descriptor() {
        return LAPACKE_zhpevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpevx_work$handle() {
        return LAPACKE_zhpevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpevx_work$address() {
        return LAPACKE_zhpevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhpevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgst_work$descriptor() {
        return LAPACKE_chpgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MethodHandle LAPACKE_chpgst_work$handle() {
        return LAPACKE_chpgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MemorySegment LAPACKE_chpgst_work$address() {
        return LAPACKE_chpgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static int LAPACKE_chpgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_chpgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgst_work$descriptor() {
        return LAPACKE_zhpgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MethodHandle LAPACKE_zhpgst_work$handle() {
        return LAPACKE_zhpgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MemorySegment LAPACKE_zhpgst_work$address() {
        return LAPACKE_zhpgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static int LAPACKE_zhpgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_zhpgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgv_work$descriptor() {
        return LAPACKE_chpgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpgv_work$handle() {
        return LAPACKE_chpgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpgv_work$address() {
        return LAPACKE_chpgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgv_work$descriptor() {
        return LAPACKE_zhpgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpgv_work$handle() {
        return LAPACKE_zhpgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpgv_work$address() {
        return LAPACKE_zhpgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvd_work$descriptor() {
        return LAPACKE_chpgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chpgvd_work$handle() {
        return LAPACKE_chpgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chpgvd_work$address() {
        return LAPACKE_chpgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chpgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chpgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvd_work$descriptor() {
        return LAPACKE_zhpgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvd_work$handle() {
        return LAPACKE_zhpgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvd_work$address() {
        return LAPACKE_zhpgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhpgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhpgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvx_work$descriptor() {
        return LAPACKE_chpgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpgvx_work$handle() {
        return LAPACKE_chpgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpgvx_work$address() {
        return LAPACKE_chpgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chpgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chpgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvx_work$descriptor() {
        return LAPACKE_zhpgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvx_work$handle() {
        return LAPACKE_zhpgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvx_work$address() {
        return LAPACKE_zhpgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhpgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chprfs_work$descriptor() {
        return LAPACKE_chprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chprfs_work$handle() {
        return LAPACKE_chprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chprfs_work$address() {
        return LAPACKE_chprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhprfs_work$descriptor() {
        return LAPACKE_zhprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhprfs_work$handle() {
        return LAPACKE_zhprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhprfs_work$address() {
        return LAPACKE_zhprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsv_work$descriptor() {
        return LAPACKE_chpsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chpsv_work$handle() {
        return LAPACKE_chpsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chpsv_work$address() {
        return LAPACKE_chpsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chpsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chpsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsv_work$descriptor() {
        return LAPACKE_zhpsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhpsv_work$handle() {
        return LAPACKE_zhpsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhpsv_work$address() {
        return LAPACKE_zhpsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhpsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhpsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chpsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsvx_work$descriptor() {
        return LAPACKE_chpsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpsvx_work$handle() {
        return LAPACKE_chpsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpsvx_work$address() {
        return LAPACKE_chpsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhpsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsvx_work$descriptor() {
        return LAPACKE_zhpsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpsvx_work$handle() {
        return LAPACKE_zhpsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpsvx_work$address() {
        return LAPACKE_zhpsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrd_work$descriptor() {
        return LAPACKE_chptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chptrd_work$handle() {
        return LAPACKE_chptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chptrd_work$address() {
        return LAPACKE_chptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrd_work$descriptor() {
        return LAPACKE_zhptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhptrd_work$handle() {
        return LAPACKE_zhptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhptrd_work$address() {
        return LAPACKE_zhptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrf_work$descriptor() {
        return LAPACKE_chptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptrf_work$handle() {
        return LAPACKE_chptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptrf_work$address() {
        return LAPACKE_chptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_chptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrf_work$descriptor() {
        return LAPACKE_zhptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptrf_work$handle() {
        return LAPACKE_zhptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptrf_work$address() {
        return LAPACKE_zhptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zhptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptri_work$descriptor() {
        return LAPACKE_chptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chptri_work$handle() {
        return LAPACKE_chptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chptri_work$address() {
        return LAPACKE_chptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_chptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_chptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptri_work$descriptor() {
        return LAPACKE_zhptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhptri_work$handle() {
        return LAPACKE_zhptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhptri_work$address() {
        return LAPACKE_zhptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zhptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrs_work$descriptor() {
        return LAPACKE_chptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chptrs_work$handle() {
        return LAPACKE_chptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chptrs_work$address() {
        return LAPACKE_chptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrs_work$descriptor() {
        return LAPACKE_zhptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhptrs_work$handle() {
        return LAPACKE_zhptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhptrs_work$address() {
        return LAPACKE_zhptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_shsein_work$descriptor() {
        return LAPACKE_shsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_shsein_work$handle() {
        return LAPACKE_shsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_shsein_work$address() {
        return LAPACKE_shsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_shsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_shsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhsein_work$descriptor() {
        return LAPACKE_dhsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_dhsein_work$handle() {
        return LAPACKE_dhsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_dhsein_work$address() {
        return LAPACKE_dhsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_dhsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_dhsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chsein_work$descriptor() {
        return LAPACKE_chsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_chsein_work$handle() {
        return LAPACKE_chsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_chsein_work$address() {
        return LAPACKE_chsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_chsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_chsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhsein_work$descriptor() {
        return LAPACKE_zhsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_zhsein_work$handle() {
        return LAPACKE_zhsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_zhsein_work$address() {
        return LAPACKE_zhsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_zhsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_zhsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_shseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_shseqr_work$descriptor() {
        return LAPACKE_shseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_shseqr_work$handle() {
        return LAPACKE_shseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_shseqr_work$address() {
        return LAPACKE_shseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_shseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_shseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dhseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhseqr_work$descriptor() {
        return LAPACKE_dhseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dhseqr_work$handle() {
        return LAPACKE_dhseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dhseqr_work$address() {
        return LAPACKE_dhseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dhseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dhseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chseqr_work$descriptor() {
        return LAPACKE_chseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chseqr_work$handle() {
        return LAPACKE_chseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chseqr_work$address() {
        return LAPACKE_chseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhseqr_work$descriptor() {
        return LAPACKE_zhseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhseqr_work$handle() {
        return LAPACKE_zhseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhseqr_work$address() {
        return LAPACKE_zhseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacgv_work$descriptor() {
        return LAPACKE_clacgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_clacgv_work$handle() {
        return LAPACKE_clacgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_clacgv_work$address() {
        return LAPACKE_clacgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static int LAPACKE_clacgv_work(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_clacgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacgv_work", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacgv_work$descriptor() {
        return LAPACKE_zlacgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlacgv_work$handle() {
        return LAPACKE_zlacgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlacgv_work$address() {
        return LAPACKE_zlacgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static int LAPACKE_zlacgv_work(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_zlacgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacgv_work", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacn2_work$descriptor() {
        return LAPACKE_slacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_slacn2_work$handle() {
        return LAPACKE_slacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_slacn2_work$address() {
        return LAPACKE_slacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_slacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_slacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacn2_work", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacn2_work$descriptor() {
        return LAPACKE_dlacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_dlacn2_work$handle() {
        return LAPACKE_dlacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_dlacn2_work$address() {
        return LAPACKE_dlacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_dlacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_dlacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacn2_work", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacn2_work$descriptor() {
        return LAPACKE_clacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_clacn2_work$handle() {
        return LAPACKE_clacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_clacn2_work$address() {
        return LAPACKE_clacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_clacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_clacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacn2_work", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacn2_work$descriptor() {
        return LAPACKE_zlacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_zlacn2_work$handle() {
        return LAPACKE_zlacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_zlacn2_work$address() {
        return LAPACKE_zlacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_zlacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_zlacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacn2_work", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacpy_work$descriptor() {
        return LAPACKE_slacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_slacpy_work$handle() {
        return LAPACKE_slacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_slacpy_work$address() {
        return LAPACKE_slacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_slacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_slacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacpy_work$descriptor() {
        return LAPACKE_dlacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dlacpy_work$handle() {
        return LAPACKE_dlacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dlacpy_work$address() {
        return LAPACKE_dlacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dlacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dlacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacpy_work$descriptor() {
        return LAPACKE_clacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacpy_work$handle() {
        return LAPACKE_clacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacpy_work$address() {
        return LAPACKE_clacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacpy_work$descriptor() {
        return LAPACKE_zlacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacpy_work$handle() {
        return LAPACKE_zlacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacpy_work$address() {
        return LAPACKE_zlacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacp2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacp2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacp2_work$descriptor() {
        return LAPACKE_clacp2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacp2_work$handle() {
        return LAPACKE_clacp2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacp2_work$address() {
        return LAPACKE_clacp2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacp2_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacp2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacp2_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacp2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacp2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacp2_work$descriptor() {
        return LAPACKE_zlacp2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacp2_work$handle() {
        return LAPACKE_zlacp2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacp2_work$address() {
        return LAPACKE_zlacp2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacp2_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacp2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacp2_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlag2c_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlag2c_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlag2c_work$descriptor() {
        return LAPACKE_zlag2c_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_zlag2c_work$handle() {
        return LAPACKE_zlag2c_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_zlag2c_work$address() {
        return LAPACKE_zlag2c_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_zlag2c_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlag2c_work", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slag2d_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slag2d_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slag2d_work$descriptor() {
        return LAPACKE_slag2d_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slag2d_work$handle() {
        return LAPACKE_slag2d_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slag2d_work$address() {
        return LAPACKE_slag2d_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static int LAPACKE_slag2d_work(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slag2d_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slag2d_work", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlag2s_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlag2s_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlag2s_work$descriptor() {
        return LAPACKE_dlag2s_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_dlag2s_work$handle() {
        return LAPACKE_dlag2s_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_dlag2s_work$address() {
        return LAPACKE_dlag2s_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_dlag2s_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlag2s_work", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clag2z_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clag2z_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clag2z_work$descriptor() {
        return LAPACKE_clag2z_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clag2z_work$handle() {
        return LAPACKE_clag2z_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clag2z_work$address() {
        return LAPACKE_clag2z_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_clag2z_work(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clag2z_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clag2z_work", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagge_work$descriptor() {
        return LAPACKE_slagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slagge_work$handle() {
        return LAPACKE_slagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slagge_work$address() {
        return LAPACKE_slagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_slagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagge_work$descriptor() {
        return LAPACKE_dlagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlagge_work$handle() {
        return LAPACKE_dlagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlagge_work$address() {
        return LAPACKE_dlagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_dlagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagge_work$descriptor() {
        return LAPACKE_clagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clagge_work$handle() {
        return LAPACKE_clagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clagge_work$address() {
        return LAPACKE_clagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_clagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagge_work$descriptor() {
        return LAPACKE_zlagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlagge_work$handle() {
        return LAPACKE_zlagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlagge_work$address() {
        return LAPACKE_zlagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claghe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claghe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_claghe_work$descriptor() {
        return LAPACKE_claghe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_claghe_work$handle() {
        return LAPACKE_claghe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_claghe_work$address() {
        return LAPACKE_claghe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_claghe_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_claghe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claghe_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaghe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaghe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaghe_work$descriptor() {
        return LAPACKE_zlaghe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlaghe_work$handle() {
        return LAPACKE_zlaghe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlaghe_work$address() {
        return LAPACKE_zlaghe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlaghe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaghe_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagsy_work$descriptor() {
        return LAPACKE_slagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slagsy_work$handle() {
        return LAPACKE_slagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slagsy_work$address() {
        return LAPACKE_slagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static int LAPACKE_slagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_slagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagsy_work$descriptor() {
        return LAPACKE_dlagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlagsy_work$handle() {
        return LAPACKE_dlagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlagsy_work$address() {
        return LAPACKE_dlagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_dlagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagsy_work$descriptor() {
        return LAPACKE_clagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clagsy_work$handle() {
        return LAPACKE_clagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clagsy_work$address() {
        return LAPACKE_clagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_clagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_clagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagsy_work$descriptor() {
        return LAPACKE_zlagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlagsy_work$handle() {
        return LAPACKE_zlagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlagsy_work$address() {
        return LAPACKE_zlagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmr_work$descriptor() {
        return LAPACKE_slapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmr_work$handle() {
        return LAPACKE_slapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmr_work$address() {
        return LAPACKE_slapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmr_work$descriptor() {
        return LAPACKE_dlapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmr_work$handle() {
        return LAPACKE_dlapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmr_work$address() {
        return LAPACKE_dlapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmr_work$descriptor() {
        return LAPACKE_clapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmr_work$handle() {
        return LAPACKE_clapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmr_work$address() {
        return LAPACKE_clapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmr_work$descriptor() {
        return LAPACKE_zlapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmr_work$handle() {
        return LAPACKE_zlapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmr_work$address() {
        return LAPACKE_zlapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmt_work$descriptor() {
        return LAPACKE_slapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmt_work$handle() {
        return LAPACKE_slapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmt_work$address() {
        return LAPACKE_slapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmt_work$descriptor() {
        return LAPACKE_dlapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmt_work$handle() {
        return LAPACKE_dlapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmt_work$address() {
        return LAPACKE_dlapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmt_work$descriptor() {
        return LAPACKE_clapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmt_work$handle() {
        return LAPACKE_clapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmt_work$address() {
        return LAPACKE_clapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmt_work$descriptor() {
        return LAPACKE_zlapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmt_work$handle() {
        return LAPACKE_zlapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmt_work$address() {
        return LAPACKE_zlapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slartgp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgp_work$descriptor() {
        return LAPACKE_slartgp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle LAPACKE_slartgp_work$handle() {
        return LAPACKE_slartgp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment LAPACKE_slartgp_work$address() {
        return LAPACKE_slartgp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static int LAPACKE_slartgp_work(float f, float g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_slartgp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgp_work", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlartgp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgp_work$descriptor() {
        return LAPACKE_dlartgp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle LAPACKE_dlartgp_work$handle() {
        return LAPACKE_dlartgp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment LAPACKE_dlartgp_work$address() {
        return LAPACKE_dlartgp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static int LAPACKE_dlartgp_work(double f, double g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_dlartgp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgp_work", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slartgs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgs_work$descriptor() {
        return LAPACKE_slartgs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle LAPACKE_slartgs_work$handle() {
        return LAPACKE_slartgs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment LAPACKE_slartgs_work$address() {
        return LAPACKE_slartgs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static int LAPACKE_slartgs_work(float x, float y, float sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_slartgs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgs_work", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlartgs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgs_work$descriptor() {
        return LAPACKE_dlartgs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle LAPACKE_dlartgs_work$handle() {
        return LAPACKE_dlartgs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment LAPACKE_dlartgs_work$address() {
        return LAPACKE_dlartgs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static int LAPACKE_dlartgs_work(double x, double y, double sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_dlartgs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgs_work", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapy2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy2_work$descriptor() {
        return LAPACKE_slapy2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static MethodHandle LAPACKE_slapy2_work$handle() {
        return LAPACKE_slapy2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static MemorySegment LAPACKE_slapy2_work$address() {
        return LAPACKE_slapy2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static float LAPACKE_slapy2_work(float x, float y) {
        var mh$ = LAPACKE_slapy2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy2_work", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapy2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy2_work$descriptor() {
        return LAPACKE_dlapy2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static MethodHandle LAPACKE_dlapy2_work$handle() {
        return LAPACKE_dlapy2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static MemorySegment LAPACKE_dlapy2_work$address() {
        return LAPACKE_dlapy2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static double LAPACKE_dlapy2_work(double x, double y) {
        var mh$ = LAPACKE_dlapy2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy2_work", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapy3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy3_work$descriptor() {
        return LAPACKE_slapy3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static MethodHandle LAPACKE_slapy3_work$handle() {
        return LAPACKE_slapy3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static MemorySegment LAPACKE_slapy3_work$address() {
        return LAPACKE_slapy3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static float LAPACKE_slapy3_work(float x, float y, float z) {
        var mh$ = LAPACKE_slapy3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy3_work", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapy3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy3_work$descriptor() {
        return LAPACKE_dlapy3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static MethodHandle LAPACKE_dlapy3_work$handle() {
        return LAPACKE_dlapy3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static MemorySegment LAPACKE_dlapy3_work$address() {
        return LAPACKE_dlapy3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static double LAPACKE_dlapy3_work(double x, double y, double z) {
        var mh$ = LAPACKE_dlapy3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy3_work", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slamch_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_CHAR
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slamch_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_slamch_work$descriptor() {
        return LAPACKE_slamch_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_slamch_work$handle() {
        return LAPACKE_slamch_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_slamch_work$address() {
        return LAPACKE_slamch_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static float LAPACKE_slamch_work(byte cmach) {
        var mh$ = LAPACKE_slamch_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slamch_work", cmach);
            }
            return (float)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlamch_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_CHAR
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlamch_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlamch_work$descriptor() {
        return LAPACKE_dlamch_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_dlamch_work$handle() {
        return LAPACKE_dlamch_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_dlamch_work$address() {
        return LAPACKE_dlamch_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static double LAPACKE_dlamch_work(byte cmach) {
        var mh$ = LAPACKE_dlamch_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlamch_work", cmach);
            }
            return (double)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slange_work$descriptor() {
        return LAPACKE_slange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slange_work$handle() {
        return LAPACKE_slange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slange_work$address() {
        return LAPACKE_slange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlange_work$descriptor() {
        return LAPACKE_dlange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlange_work$handle() {
        return LAPACKE_dlange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlange_work$address() {
        return LAPACKE_dlange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clange_work$descriptor() {
        return LAPACKE_clange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clange_work$handle() {
        return LAPACKE_clange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clange_work$address() {
        return LAPACKE_clange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlange_work$descriptor() {
        return LAPACKE_zlange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlange_work$handle() {
        return LAPACKE_zlange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlange_work$address() {
        return LAPACKE_zlange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clanhe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clanhe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clanhe_work$descriptor() {
        return LAPACKE_clanhe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clanhe_work$handle() {
        return LAPACKE_clanhe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clanhe_work$address() {
        return LAPACKE_clanhe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clanhe_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clanhe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clanhe_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlanhe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlanhe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlanhe_work$descriptor() {
        return LAPACKE_zlanhe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlanhe_work$handle() {
        return LAPACKE_zlanhe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlanhe_work$address() {
        return LAPACKE_zlanhe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlanhe_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlanhe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlanhe_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacrm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clacrm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacrm_work$descriptor() {
        return LAPACKE_clacrm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clacrm_work$handle() {
        return LAPACKE_clacrm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clacrm_work$address() {
        return LAPACKE_clacrm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_clacrm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clacrm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacrm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacrm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlacrm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacrm_work$descriptor() {
        return LAPACKE_zlacrm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlacrm_work$handle() {
        return LAPACKE_zlacrm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlacrm_work$address() {
        return LAPACKE_zlacrm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlacrm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacrm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarcm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarcm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarcm_work$descriptor() {
        return LAPACKE_clarcm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarcm_work$handle() {
        return LAPACKE_clarcm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarcm_work$address() {
        return LAPACKE_clarcm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_clarcm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarcm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarcm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarcm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarcm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarcm_work$descriptor() {
        return LAPACKE_zlarcm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarcm_work$handle() {
        return LAPACKE_zlarcm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarcm_work$address() {
        return LAPACKE_zlarcm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarcm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarcm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slansy_work$descriptor() {
        return LAPACKE_slansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slansy_work$handle() {
        return LAPACKE_slansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slansy_work$address() {
        return LAPACKE_slansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlansy_work$descriptor() {
        return LAPACKE_dlansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlansy_work$handle() {
        return LAPACKE_dlansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlansy_work$address() {
        return LAPACKE_dlansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clansy_work$descriptor() {
        return LAPACKE_clansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clansy_work$handle() {
        return LAPACKE_clansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clansy_work$address() {
        return LAPACKE_clansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlansy_work$descriptor() {
        return LAPACKE_zlansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlansy_work$handle() {
        return LAPACKE_zlansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlansy_work$address() {
        return LAPACKE_zlansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slantr_work$descriptor() {
        return LAPACKE_slantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slantr_work$handle() {
        return LAPACKE_slantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slantr_work$address() {
        return LAPACKE_slantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlantr_work$descriptor() {
        return LAPACKE_dlantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlantr_work$handle() {
        return LAPACKE_dlantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlantr_work$address() {
        return LAPACKE_dlantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clantr_work$descriptor() {
        return LAPACKE_clantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clantr_work$handle() {
        return LAPACKE_clantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clantr_work$address() {
        return LAPACKE_clantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlantr_work$descriptor() {
        return LAPACKE_zlantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlantr_work$handle() {
        return LAPACKE_zlantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlantr_work$address() {
        return LAPACKE_zlantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfb_work$descriptor() {
        return LAPACKE_slarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_slarfb_work$handle() {
        return LAPACKE_slarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_slarfb_work$address() {
        return LAPACKE_slarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static int LAPACKE_slarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_slarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfb_work$descriptor() {
        return LAPACKE_dlarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_dlarfb_work$handle() {
        return LAPACKE_dlarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_dlarfb_work$address() {
        return LAPACKE_dlarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static int LAPACKE_dlarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_dlarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfb_work$descriptor() {
        return LAPACKE_clarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_clarfb_work$handle() {
        return LAPACKE_clarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_clarfb_work$address() {
        return LAPACKE_clarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static int LAPACKE_clarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_clarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfb_work$descriptor() {
        return LAPACKE_zlarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_zlarfb_work$handle() {
        return LAPACKE_zlarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_zlarfb_work$address() {
        return LAPACKE_zlarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static int LAPACKE_zlarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_zlarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfg_work$descriptor() {
        return LAPACKE_slarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_slarfg_work$handle() {
        return LAPACKE_slarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_slarfg_work$address() {
        return LAPACKE_slarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static int LAPACKE_slarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_slarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfg_work$descriptor() {
        return LAPACKE_dlarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dlarfg_work$handle() {
        return LAPACKE_dlarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dlarfg_work$address() {
        return LAPACKE_dlarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static int LAPACKE_dlarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_dlarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfg_work$descriptor() {
        return LAPACKE_clarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_clarfg_work$handle() {
        return LAPACKE_clarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_clarfg_work$address() {
        return LAPACKE_clarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static int LAPACKE_clarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_clarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfg_work$descriptor() {
        return LAPACKE_zlarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zlarfg_work$handle() {
        return LAPACKE_zlarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zlarfg_work$address() {
        return LAPACKE_zlarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zlarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_zlarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarft_work$descriptor() {
        return LAPACKE_slarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_slarft_work$handle() {
        return LAPACKE_slarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_slarft_work$address() {
        return LAPACKE_slarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static int LAPACKE_slarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_slarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarft_work$descriptor() {
        return LAPACKE_dlarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dlarft_work$handle() {
        return LAPACKE_dlarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dlarft_work$address() {
        return LAPACKE_dlarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dlarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dlarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarft_work$descriptor() {
        return LAPACKE_clarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_clarft_work$handle() {
        return LAPACKE_clarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_clarft_work$address() {
        return LAPACKE_clarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_clarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_clarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarft_work$descriptor() {
        return LAPACKE_zlarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zlarft_work$handle() {
        return LAPACKE_zlarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zlarft_work$address() {
        return LAPACKE_zlarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zlarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zlarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfx_work$descriptor() {
        return LAPACKE_slarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slarfx_work$handle() {
        return LAPACKE_slarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slarfx_work$address() {
        return LAPACKE_slarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_slarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_slarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfx_work$descriptor() {
        return LAPACKE_dlarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlarfx_work$handle() {
        return LAPACKE_dlarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlarfx_work$address() {
        return LAPACKE_dlarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dlarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dlarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfx_work$descriptor() {
        return LAPACKE_clarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarfx_work$handle() {
        return LAPACKE_clarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarfx_work$address() {
        return LAPACKE_clarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_clarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfx_work$descriptor() {
        return LAPACKE_zlarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarfx_work$handle() {
        return LAPACKE_zlarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarfx_work$address() {
        return LAPACKE_zlarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarnv_work$descriptor() {
        return LAPACKE_slarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MethodHandle LAPACKE_slarnv_work$handle() {
        return LAPACKE_slarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MemorySegment LAPACKE_slarnv_work$address() {
        return LAPACKE_slarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static int LAPACKE_slarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_slarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarnv_work$descriptor() {
        return LAPACKE_dlarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dlarnv_work$handle() {
        return LAPACKE_dlarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dlarnv_work$address() {
        return LAPACKE_dlarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static int LAPACKE_dlarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_dlarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarnv_work$descriptor() {
        return LAPACKE_clarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_clarnv_work$handle() {
        return LAPACKE_clarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_clarnv_work$address() {
        return LAPACKE_clarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static int LAPACKE_clarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_clarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarnv_work$descriptor() {
        return LAPACKE_zlarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zlarnv_work$handle() {
        return LAPACKE_zlarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zlarnv_work$address() {
        return LAPACKE_zlarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static int LAPACKE_zlarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_zlarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slascl_work$descriptor() {
        return LAPACKE_slascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slascl_work$handle() {
        return LAPACKE_slascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slascl_work$address() {
        return LAPACKE_slascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slascl_work(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlascl_work$descriptor() {
        return LAPACKE_dlascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlascl_work$handle() {
        return LAPACKE_dlascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlascl_work$address() {
        return LAPACKE_dlascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlascl_work(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clascl_work$descriptor() {
        return LAPACKE_clascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clascl_work$handle() {
        return LAPACKE_clascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clascl_work$address() {
        return LAPACKE_clascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clascl_work(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlascl_work$descriptor() {
        return LAPACKE_zlascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlascl_work$handle() {
        return LAPACKE_zlascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlascl_work$address() {
        return LAPACKE_zlascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlascl_work(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaset_work$descriptor() {
        return LAPACKE_slaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slaset_work$handle() {
        return LAPACKE_slaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slaset_work$address() {
        return LAPACKE_slaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static int LAPACKE_slaset_work(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaset_work$descriptor() {
        return LAPACKE_dlaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlaset_work$handle() {
        return LAPACKE_dlaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlaset_work$address() {
        return LAPACKE_dlaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlaset_work(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_claset_work$descriptor() {
        return LAPACKE_claset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_claset_work$handle() {
        return LAPACKE_claset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_claset_work$address() {
        return LAPACKE_claset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_claset_work(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_claset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaset_work$descriptor() {
        return LAPACKE_zlaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlaset_work$handle() {
        return LAPACKE_zlaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlaset_work$address() {
        return LAPACKE_zlaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlaset_work(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slasrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slasrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_slasrt_work$descriptor() {
        return LAPACKE_slasrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static MethodHandle LAPACKE_slasrt_work$handle() {
        return LAPACKE_slasrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static MemorySegment LAPACKE_slasrt_work$address() {
        return LAPACKE_slasrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static int LAPACKE_slasrt_work(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_slasrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slasrt_work", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlasrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlasrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlasrt_work$descriptor() {
        return LAPACKE_dlasrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static MethodHandle LAPACKE_dlasrt_work$handle() {
        return LAPACKE_dlasrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static MemorySegment LAPACKE_dlasrt_work$address() {
        return LAPACKE_dlasrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static int LAPACKE_dlasrt_work(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_dlasrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlasrt_work", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_slassq_work$descriptor() {
        return LAPACKE_slassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_slassq_work$handle() {
        return LAPACKE_slassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_slassq_work$address() {
        return LAPACKE_slassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_slassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_slassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlassq_work$descriptor() {
        return LAPACKE_dlassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_dlassq_work$handle() {
        return LAPACKE_dlassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_dlassq_work$address() {
        return LAPACKE_dlassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_dlassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_dlassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_classq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_classq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_classq_work$descriptor() {
        return LAPACKE_classq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_classq_work$handle() {
        return LAPACKE_classq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_classq_work$address() {
        return LAPACKE_classq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_classq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_classq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_classq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlassq_work$descriptor() {
        return LAPACKE_zlassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_zlassq_work$handle() {
        return LAPACKE_zlassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_zlassq_work$address() {
        return LAPACKE_zlassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_zlassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_zlassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaswp_work$descriptor() {
        return LAPACKE_slaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_slaswp_work$handle() {
        return LAPACKE_slaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_slaswp_work$address() {
        return LAPACKE_slaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_slaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_slaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaswp_work$descriptor() {
        return LAPACKE_dlaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_dlaswp_work$handle() {
        return LAPACKE_dlaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_dlaswp_work$address() {
        return LAPACKE_dlaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_dlaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_dlaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_claswp_work$descriptor() {
        return LAPACKE_claswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_claswp_work$handle() {
        return LAPACKE_claswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_claswp_work$address() {
        return LAPACKE_claswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_claswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_claswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaswp_work$descriptor() {
        return LAPACKE_zlaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlaswp_work$handle() {
        return LAPACKE_zlaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlaswp_work$address() {
        return LAPACKE_zlaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_zlaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_zlaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slatms_work$descriptor() {
        return LAPACKE_slatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slatms_work$handle() {
        return LAPACKE_slatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slatms_work$address() {
        return LAPACKE_slatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static int LAPACKE_slatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlatms_work$descriptor() {
        return LAPACKE_dlatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlatms_work$handle() {
        return LAPACKE_dlatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlatms_work$address() {
        return LAPACKE_dlatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static int LAPACKE_dlatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clatms_work$descriptor() {
        return LAPACKE_clatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clatms_work$handle() {
        return LAPACKE_clatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clatms_work$address() {
        return LAPACKE_clatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static int LAPACKE_clatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlatms_work$descriptor() {
        return LAPACKE_zlatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlatms_work$handle() {
        return LAPACKE_zlatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlatms_work$address() {
        return LAPACKE_zlatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slauum_work$descriptor() {
        return LAPACKE_slauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slauum_work$handle() {
        return LAPACKE_slauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slauum_work$address() {
        return LAPACKE_slauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlauum_work$descriptor() {
        return LAPACKE_dlauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlauum_work$handle() {
        return LAPACKE_dlauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlauum_work$address() {
        return LAPACKE_dlauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clauum_work$descriptor() {
        return LAPACKE_clauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clauum_work$handle() {
        return LAPACKE_clauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clauum_work$address() {
        return LAPACKE_clauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlauum_work$descriptor() {
        return LAPACKE_zlauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlauum_work$handle() {
        return LAPACKE_zlauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlauum_work$address() {
        return LAPACKE_zlauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sopgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopgtr_work$descriptor() {
        return LAPACKE_sopgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sopgtr_work$handle() {
        return LAPACKE_sopgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sopgtr_work$address() {
        return LAPACKE_sopgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static int LAPACKE_sopgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_sopgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dopgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopgtr_work$descriptor() {
        return LAPACKE_dopgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dopgtr_work$handle() {
        return LAPACKE_dopgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dopgtr_work$address() {
        return LAPACKE_dopgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static int LAPACKE_dopgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_dopgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sopmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopmtr_work$descriptor() {
        return LAPACKE_sopmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sopmtr_work$handle() {
        return LAPACKE_sopmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sopmtr_work$address() {
        return LAPACKE_sopmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sopmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sopmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dopmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopmtr_work$descriptor() {
        return LAPACKE_dopmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dopmtr_work$handle() {
        return LAPACKE_dopmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dopmtr_work$address() {
        return LAPACKE_dopmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dopmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dopmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgbr_work$descriptor() {
        return LAPACKE_sorgbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgbr_work$handle() {
        return LAPACKE_sorgbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgbr_work$address() {
        return LAPACKE_sorgbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgbr_work$descriptor() {
        return LAPACKE_dorgbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgbr_work$handle() {
        return LAPACKE_dorgbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgbr_work$address() {
        return LAPACKE_dorgbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorghr_work$descriptor() {
        return LAPACKE_sorghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorghr_work$handle() {
        return LAPACKE_sorghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorghr_work$address() {
        return LAPACKE_sorghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorghr_work$descriptor() {
        return LAPACKE_dorghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorghr_work$handle() {
        return LAPACKE_dorghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorghr_work$address() {
        return LAPACKE_dorghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorglq_work$descriptor() {
        return LAPACKE_sorglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorglq_work$handle() {
        return LAPACKE_sorglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorglq_work$address() {
        return LAPACKE_sorglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorglq_work$descriptor() {
        return LAPACKE_dorglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorglq_work$handle() {
        return LAPACKE_dorglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorglq_work$address() {
        return LAPACKE_dorglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgql_work$descriptor() {
        return LAPACKE_sorgql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgql_work$handle() {
        return LAPACKE_sorgql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgql_work$address() {
        return LAPACKE_sorgql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgql_work$descriptor() {
        return LAPACKE_dorgql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgql_work$handle() {
        return LAPACKE_dorgql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgql_work$address() {
        return LAPACKE_dorgql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgqr_work$descriptor() {
        return LAPACKE_sorgqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgqr_work$handle() {
        return LAPACKE_sorgqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgqr_work$address() {
        return LAPACKE_sorgqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgqr_work$descriptor() {
        return LAPACKE_dorgqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgqr_work$handle() {
        return LAPACKE_dorgqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgqr_work$address() {
        return LAPACKE_dorgqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgrq_work$descriptor() {
        return LAPACKE_sorgrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgrq_work$handle() {
        return LAPACKE_sorgrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgrq_work$address() {
        return LAPACKE_sorgrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgrq_work$descriptor() {
        return LAPACKE_dorgrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgrq_work$handle() {
        return LAPACKE_dorgrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgrq_work$address() {
        return LAPACKE_dorgrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtr_work$descriptor() {
        return LAPACKE_sorgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgtr_work$handle() {
        return LAPACKE_sorgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgtr_work$address() {
        return LAPACKE_sorgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtr_work$descriptor() {
        return LAPACKE_dorgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgtr_work$handle() {
        return LAPACKE_dorgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgtr_work$address() {
        return LAPACKE_dorgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorgtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtsqr_row_work$descriptor() {
        return LAPACKE_sorgtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgtsqr_row_work$handle() {
        return LAPACKE_sorgtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgtsqr_row_work$address() {
        return LAPACKE_sorgtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorgtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtsqr_row_work$descriptor() {
        return LAPACKE_dorgtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgtsqr_row_work$handle() {
        return LAPACKE_dorgtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgtsqr_row_work$address() {
        return LAPACKE_dorgtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormbr_work$descriptor() {
        return LAPACKE_sormbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormbr_work$handle() {
        return LAPACKE_sormbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormbr_work$address() {
        return LAPACKE_sormbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormbr_work$descriptor() {
        return LAPACKE_dormbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormbr_work$handle() {
        return LAPACKE_dormbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormbr_work$address() {
        return LAPACKE_dormbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormhr_work$descriptor() {
        return LAPACKE_sormhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormhr_work$handle() {
        return LAPACKE_sormhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormhr_work$address() {
        return LAPACKE_sormhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormhr_work$descriptor() {
        return LAPACKE_dormhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormhr_work$handle() {
        return LAPACKE_dormhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormhr_work$address() {
        return LAPACKE_dormhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormlq_work$descriptor() {
        return LAPACKE_sormlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormlq_work$handle() {
        return LAPACKE_sormlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormlq_work$address() {
        return LAPACKE_sormlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormlq_work$descriptor() {
        return LAPACKE_dormlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormlq_work$handle() {
        return LAPACKE_dormlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormlq_work$address() {
        return LAPACKE_dormlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormql_work$descriptor() {
        return LAPACKE_sormql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormql_work$handle() {
        return LAPACKE_sormql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormql_work$address() {
        return LAPACKE_sormql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormql_work$descriptor() {
        return LAPACKE_dormql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormql_work$handle() {
        return LAPACKE_dormql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormql_work$address() {
        return LAPACKE_dormql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormqr_work$descriptor() {
        return LAPACKE_sormqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormqr_work$handle() {
        return LAPACKE_sormqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormqr_work$address() {
        return LAPACKE_sormqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormqr_work$descriptor() {
        return LAPACKE_dormqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormqr_work$handle() {
        return LAPACKE_dormqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormqr_work$address() {
        return LAPACKE_dormqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrq_work$descriptor() {
        return LAPACKE_sormrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormrq_work$handle() {
        return LAPACKE_sormrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormrq_work$address() {
        return LAPACKE_sormrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrq_work$descriptor() {
        return LAPACKE_dormrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormrq_work$handle() {
        return LAPACKE_dormrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormrq_work$address() {
        return LAPACKE_dormrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrz_work$descriptor() {
        return LAPACKE_sormrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormrz_work$handle() {
        return LAPACKE_sormrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormrz_work$address() {
        return LAPACKE_sormrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrz_work$descriptor() {
        return LAPACKE_dormrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormrz_work$handle() {
        return LAPACKE_dormrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormrz_work$address() {
        return LAPACKE_dormrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sormtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormtr_work$descriptor() {
        return LAPACKE_sormtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormtr_work$handle() {
        return LAPACKE_sormtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormtr_work$address() {
        return LAPACKE_sormtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dormtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormtr_work$descriptor() {
        return LAPACKE_dormtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormtr_work$handle() {
        return LAPACKE_dormtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormtr_work$address() {
        return LAPACKE_dormtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbcon_work$descriptor() {
        return LAPACKE_spbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbcon_work$handle() {
        return LAPACKE_spbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbcon_work$address() {
        return LAPACKE_spbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbcon_work$descriptor() {
        return LAPACKE_dpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbcon_work$handle() {
        return LAPACKE_dpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbcon_work$address() {
        return LAPACKE_dpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbcon_work$descriptor() {
        return LAPACKE_cpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbcon_work$handle() {
        return LAPACKE_cpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbcon_work$address() {
        return LAPACKE_cpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbcon_work$descriptor() {
        return LAPACKE_zpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbcon_work$handle() {
        return LAPACKE_zpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbcon_work$address() {
        return LAPACKE_zpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbequ_work$descriptor() {
        return LAPACKE_spbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spbequ_work$handle() {
        return LAPACKE_spbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spbequ_work$address() {
        return LAPACKE_spbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbequ_work$descriptor() {
        return LAPACKE_dpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpbequ_work$handle() {
        return LAPACKE_dpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpbequ_work$address() {
        return LAPACKE_dpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbequ_work$descriptor() {
        return LAPACKE_cpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpbequ_work$handle() {
        return LAPACKE_cpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpbequ_work$address() {
        return LAPACKE_cpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbequ_work$descriptor() {
        return LAPACKE_zpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpbequ_work$handle() {
        return LAPACKE_zpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpbequ_work$address() {
        return LAPACKE_zpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbrfs_work$descriptor() {
        return LAPACKE_spbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbrfs_work$handle() {
        return LAPACKE_spbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbrfs_work$address() {
        return LAPACKE_spbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbrfs_work$descriptor() {
        return LAPACKE_dpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbrfs_work$handle() {
        return LAPACKE_dpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbrfs_work$address() {
        return LAPACKE_dpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbrfs_work$descriptor() {
        return LAPACKE_cpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbrfs_work$handle() {
        return LAPACKE_cpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbrfs_work$address() {
        return LAPACKE_cpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbrfs_work$descriptor() {
        return LAPACKE_zpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbrfs_work$handle() {
        return LAPACKE_zpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbrfs_work$address() {
        return LAPACKE_zpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbstf_work$descriptor() {
        return LAPACKE_spbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_spbstf_work$handle() {
        return LAPACKE_spbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_spbstf_work$address() {
        return LAPACKE_spbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_spbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_spbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbstf_work$descriptor() {
        return LAPACKE_dpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_dpbstf_work$handle() {
        return LAPACKE_dpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_dpbstf_work$address() {
        return LAPACKE_dpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_dpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_dpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbstf_work$descriptor() {
        return LAPACKE_cpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_cpbstf_work$handle() {
        return LAPACKE_cpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_cpbstf_work$address() {
        return LAPACKE_cpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_cpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_cpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbstf_work$descriptor() {
        return LAPACKE_zpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_zpbstf_work$handle() {
        return LAPACKE_zpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_zpbstf_work$address() {
        return LAPACKE_zpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_zpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_zpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsv_work$descriptor() {
        return LAPACKE_spbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbsv_work$handle() {
        return LAPACKE_spbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbsv_work$address() {
        return LAPACKE_spbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsv_work$descriptor() {
        return LAPACKE_dpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbsv_work$handle() {
        return LAPACKE_dpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbsv_work$address() {
        return LAPACKE_dpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsv_work$descriptor() {
        return LAPACKE_cpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbsv_work$handle() {
        return LAPACKE_cpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbsv_work$address() {
        return LAPACKE_cpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsv_work$descriptor() {
        return LAPACKE_zpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbsv_work$handle() {
        return LAPACKE_zpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbsv_work$address() {
        return LAPACKE_zpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsvx_work$descriptor() {
        return LAPACKE_spbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbsvx_work$handle() {
        return LAPACKE_spbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbsvx_work$address() {
        return LAPACKE_spbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsvx_work$descriptor() {
        return LAPACKE_dpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbsvx_work$handle() {
        return LAPACKE_dpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbsvx_work$address() {
        return LAPACKE_dpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsvx_work$descriptor() {
        return LAPACKE_cpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbsvx_work$handle() {
        return LAPACKE_cpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbsvx_work$address() {
        return LAPACKE_cpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsvx_work$descriptor() {
        return LAPACKE_zpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbsvx_work$handle() {
        return LAPACKE_zpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbsvx_work$address() {
        return LAPACKE_zpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrf_work$descriptor() {
        return LAPACKE_spbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_spbtrf_work$handle() {
        return LAPACKE_spbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_spbtrf_work$address() {
        return LAPACKE_spbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static int LAPACKE_spbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_spbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrf_work$descriptor() {
        return LAPACKE_dpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrf_work$handle() {
        return LAPACKE_dpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrf_work$address() {
        return LAPACKE_dpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static int LAPACKE_dpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_dpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrf_work$descriptor() {
        return LAPACKE_cpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrf_work$handle() {
        return LAPACKE_cpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrf_work$address() {
        return LAPACKE_cpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static int LAPACKE_cpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_cpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrf_work$descriptor() {
        return LAPACKE_zpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrf_work$handle() {
        return LAPACKE_zpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrf_work$address() {
        return LAPACKE_zpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static int LAPACKE_zpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_zpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrs_work$descriptor() {
        return LAPACKE_spbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbtrs_work$handle() {
        return LAPACKE_spbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbtrs_work$address() {
        return LAPACKE_spbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrs_work$descriptor() {
        return LAPACKE_dpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrs_work$handle() {
        return LAPACKE_dpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrs_work$address() {
        return LAPACKE_dpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrs_work$descriptor() {
        return LAPACKE_cpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrs_work$handle() {
        return LAPACKE_cpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrs_work$address() {
        return LAPACKE_cpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrs_work$descriptor() {
        return LAPACKE_zpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrs_work$handle() {
        return LAPACKE_zpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrs_work$address() {
        return LAPACKE_zpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrf_work$descriptor() {
        return LAPACKE_spftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftrf_work$handle() {
        return LAPACKE_spftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftrf_work$address() {
        return LAPACKE_spftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrf_work$descriptor() {
        return LAPACKE_dpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftrf_work$handle() {
        return LAPACKE_dpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftrf_work$address() {
        return LAPACKE_dpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrf_work$descriptor() {
        return LAPACKE_cpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftrf_work$handle() {
        return LAPACKE_cpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftrf_work$address() {
        return LAPACKE_cpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrf_work$descriptor() {
        return LAPACKE_zpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftrf_work$handle() {
        return LAPACKE_zpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftrf_work$address() {
        return LAPACKE_zpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftri_work$descriptor() {
        return LAPACKE_spftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftri_work$handle() {
        return LAPACKE_spftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftri_work$address() {
        return LAPACKE_spftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftri_work$descriptor() {
        return LAPACKE_dpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftri_work$handle() {
        return LAPACKE_dpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftri_work$address() {
        return LAPACKE_dpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftri_work$descriptor() {
        return LAPACKE_cpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftri_work$handle() {
        return LAPACKE_cpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftri_work$address() {
        return LAPACKE_cpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftri_work$descriptor() {
        return LAPACKE_zpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftri_work$handle() {
        return LAPACKE_zpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftri_work$address() {
        return LAPACKE_zpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrs_work$descriptor() {
        return LAPACKE_spftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spftrs_work$handle() {
        return LAPACKE_spftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spftrs_work$address() {
        return LAPACKE_spftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrs_work$descriptor() {
        return LAPACKE_dpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpftrs_work$handle() {
        return LAPACKE_dpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpftrs_work$address() {
        return LAPACKE_dpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrs_work$descriptor() {
        return LAPACKE_cpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpftrs_work$handle() {
        return LAPACKE_cpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpftrs_work$address() {
        return LAPACKE_cpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrs_work$descriptor() {
        return LAPACKE_zpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpftrs_work$handle() {
        return LAPACKE_zpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpftrs_work$address() {
        return LAPACKE_zpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spocon_work$descriptor() {
        return LAPACKE_spocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spocon_work$handle() {
        return LAPACKE_spocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spocon_work$address() {
        return LAPACKE_spocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpocon_work$descriptor() {
        return LAPACKE_dpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpocon_work$handle() {
        return LAPACKE_dpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpocon_work$address() {
        return LAPACKE_dpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpocon_work$descriptor() {
        return LAPACKE_cpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpocon_work$handle() {
        return LAPACKE_cpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpocon_work$address() {
        return LAPACKE_cpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpocon_work$descriptor() {
        return LAPACKE_zpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpocon_work$handle() {
        return LAPACKE_zpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpocon_work$address() {
        return LAPACKE_zpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequ_work$descriptor() {
        return LAPACKE_spoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequ_work$handle() {
        return LAPACKE_spoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequ_work$address() {
        return LAPACKE_spoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequ_work$descriptor() {
        return LAPACKE_dpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequ_work$handle() {
        return LAPACKE_dpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequ_work$address() {
        return LAPACKE_dpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequ_work$descriptor() {
        return LAPACKE_cpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequ_work$handle() {
        return LAPACKE_cpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequ_work$address() {
        return LAPACKE_cpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequ_work$descriptor() {
        return LAPACKE_zpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequ_work$handle() {
        return LAPACKE_zpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequ_work$address() {
        return LAPACKE_zpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequb_work$descriptor() {
        return LAPACKE_spoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequb_work$handle() {
        return LAPACKE_spoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequb_work$address() {
        return LAPACKE_spoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequb_work$descriptor() {
        return LAPACKE_dpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequb_work$handle() {
        return LAPACKE_dpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequb_work$address() {
        return LAPACKE_dpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequb_work$descriptor() {
        return LAPACKE_cpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequb_work$handle() {
        return LAPACKE_cpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequb_work$address() {
        return LAPACKE_cpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequb_work$descriptor() {
        return LAPACKE_zpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequb_work$handle() {
        return LAPACKE_zpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequb_work$address() {
        return LAPACKE_zpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfs_work$descriptor() {
        return LAPACKE_sporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sporfs_work$handle() {
        return LAPACKE_sporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sporfs_work$address() {
        return LAPACKE_sporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfs_work$descriptor() {
        return LAPACKE_dporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dporfs_work$handle() {
        return LAPACKE_dporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dporfs_work$address() {
        return LAPACKE_dporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfs_work$descriptor() {
        return LAPACKE_cporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cporfs_work$handle() {
        return LAPACKE_cporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cporfs_work$address() {
        return LAPACKE_cporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfs_work$descriptor() {
        return LAPACKE_zporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zporfs_work$handle() {
        return LAPACKE_zporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zporfs_work$address() {
        return LAPACKE_zporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfsx_work$descriptor() {
        return LAPACKE_sporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sporfsx_work$handle() {
        return LAPACKE_sporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sporfsx_work$address() {
        return LAPACKE_sporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfsx_work$descriptor() {
        return LAPACKE_dporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dporfsx_work$handle() {
        return LAPACKE_dporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dporfsx_work$address() {
        return LAPACKE_dporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfsx_work$descriptor() {
        return LAPACKE_cporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cporfsx_work$handle() {
        return LAPACKE_cporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cporfsx_work$address() {
        return LAPACKE_cporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfsx_work$descriptor() {
        return LAPACKE_zporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zporfsx_work$handle() {
        return LAPACKE_zporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zporfsx_work$address() {
        return LAPACKE_zporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposv_work$descriptor() {
        return LAPACKE_sposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sposv_work$handle() {
        return LAPACKE_sposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sposv_work$address() {
        return LAPACKE_sposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposv_work$descriptor() {
        return LAPACKE_dposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dposv_work$handle() {
        return LAPACKE_dposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dposv_work$address() {
        return LAPACKE_dposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposv_work$descriptor() {
        return LAPACKE_cposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cposv_work$handle() {
        return LAPACKE_cposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cposv_work$address() {
        return LAPACKE_cposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposv_work$descriptor() {
        return LAPACKE_zposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zposv_work$handle() {
        return LAPACKE_zposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zposv_work$address() {
        return LAPACKE_zposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsposv_work$descriptor() {
        return LAPACKE_dsposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsposv_work$handle() {
        return LAPACKE_dsposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsposv_work$address() {
        return LAPACKE_dsposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static int LAPACKE_dsposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment iter) {
        var mh$ = LAPACKE_dsposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zcposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcposv_work$descriptor() {
        return LAPACKE_zcposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcposv_work$handle() {
        return LAPACKE_zcposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcposv_work$address() {
        return LAPACKE_zcposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static int LAPACKE_zcposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter) {
        var mh$ = LAPACKE_zcposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvx_work$descriptor() {
        return LAPACKE_sposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sposvx_work$handle() {
        return LAPACKE_sposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sposvx_work$address() {
        return LAPACKE_sposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvx_work$descriptor() {
        return LAPACKE_dposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dposvx_work$handle() {
        return LAPACKE_dposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dposvx_work$address() {
        return LAPACKE_dposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvx_work$descriptor() {
        return LAPACKE_cposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cposvx_work$handle() {
        return LAPACKE_cposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cposvx_work$address() {
        return LAPACKE_cposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvx_work$descriptor() {
        return LAPACKE_zposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zposvx_work$handle() {
        return LAPACKE_zposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zposvx_work$address() {
        return LAPACKE_zposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvxx_work$descriptor() {
        return LAPACKE_sposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sposvxx_work$handle() {
        return LAPACKE_sposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sposvxx_work$address() {
        return LAPACKE_sposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvxx_work$descriptor() {
        return LAPACKE_dposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dposvxx_work$handle() {
        return LAPACKE_dposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dposvxx_work$address() {
        return LAPACKE_dposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvxx_work$descriptor() {
        return LAPACKE_cposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cposvxx_work$handle() {
        return LAPACKE_cposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cposvxx_work$address() {
        return LAPACKE_cposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvxx_work$descriptor() {
        return LAPACKE_zposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zposvxx_work$handle() {
        return LAPACKE_zposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zposvxx_work$address() {
        return LAPACKE_zposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf2_work$descriptor() {
        return LAPACKE_spotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf2_work$handle() {
        return LAPACKE_spotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf2_work$address() {
        return LAPACKE_spotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf2_work$descriptor() {
        return LAPACKE_dpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf2_work$handle() {
        return LAPACKE_dpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf2_work$address() {
        return LAPACKE_dpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf2_work$descriptor() {
        return LAPACKE_cpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf2_work$handle() {
        return LAPACKE_cpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf2_work$address() {
        return LAPACKE_cpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf2_work$descriptor() {
        return LAPACKE_zpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf2_work$handle() {
        return LAPACKE_zpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf2_work$address() {
        return LAPACKE_zpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf_work$descriptor() {
        return LAPACKE_spotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf_work$handle() {
        return LAPACKE_spotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf_work$address() {
        return LAPACKE_spotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf_work$descriptor() {
        return LAPACKE_dpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf_work$handle() {
        return LAPACKE_dpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf_work$address() {
        return LAPACKE_dpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf_work$descriptor() {
        return LAPACKE_cpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf_work$handle() {
        return LAPACKE_cpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf_work$address() {
        return LAPACKE_cpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf_work$descriptor() {
        return LAPACKE_zpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf_work$handle() {
        return LAPACKE_zpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf_work$address() {
        return LAPACKE_zpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotri_work$descriptor() {
        return LAPACKE_spotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotri_work$handle() {
        return LAPACKE_spotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotri_work$address() {
        return LAPACKE_spotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotri_work$descriptor() {
        return LAPACKE_dpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotri_work$handle() {
        return LAPACKE_dpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotri_work$address() {
        return LAPACKE_dpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotri_work$descriptor() {
        return LAPACKE_cpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotri_work$handle() {
        return LAPACKE_cpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotri_work$address() {
        return LAPACKE_cpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotri_work$descriptor() {
        return LAPACKE_zpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotri_work$handle() {
        return LAPACKE_zpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotri_work$address() {
        return LAPACKE_zpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrs_work$descriptor() {
        return LAPACKE_spotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spotrs_work$handle() {
        return LAPACKE_spotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spotrs_work$address() {
        return LAPACKE_spotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrs_work$descriptor() {
        return LAPACKE_dpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpotrs_work$handle() {
        return LAPACKE_dpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpotrs_work$address() {
        return LAPACKE_dpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrs_work$descriptor() {
        return LAPACKE_cpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpotrs_work$handle() {
        return LAPACKE_cpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpotrs_work$address() {
        return LAPACKE_cpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrs_work$descriptor() {
        return LAPACKE_zpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpotrs_work$handle() {
        return LAPACKE_zpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpotrs_work$address() {
        return LAPACKE_zpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppcon_work$descriptor() {
        return LAPACKE_sppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sppcon_work$handle() {
        return LAPACKE_sppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sppcon_work$address() {
        return LAPACKE_sppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppcon_work$descriptor() {
        return LAPACKE_dppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dppcon_work$handle() {
        return LAPACKE_dppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dppcon_work$address() {
        return LAPACKE_dppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppcon_work$descriptor() {
        return LAPACKE_cppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cppcon_work$handle() {
        return LAPACKE_cppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cppcon_work$address() {
        return LAPACKE_cppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppcon_work$descriptor() {
        return LAPACKE_zppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zppcon_work$handle() {
        return LAPACKE_zppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zppcon_work$address() {
        return LAPACKE_zppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppequ_work$descriptor() {
        return LAPACKE_sppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sppequ_work$handle() {
        return LAPACKE_sppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sppequ_work$address() {
        return LAPACKE_sppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_sppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_sppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppequ_work$descriptor() {
        return LAPACKE_dppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dppequ_work$handle() {
        return LAPACKE_dppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dppequ_work$address() {
        return LAPACKE_dppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppequ_work$descriptor() {
        return LAPACKE_cppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cppequ_work$handle() {
        return LAPACKE_cppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cppequ_work$address() {
        return LAPACKE_cppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppequ_work$descriptor() {
        return LAPACKE_zppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zppequ_work$handle() {
        return LAPACKE_zppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zppequ_work$address() {
        return LAPACKE_zppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spprfs_work$descriptor() {
        return LAPACKE_spprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spprfs_work$handle() {
        return LAPACKE_spprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spprfs_work$address() {
        return LAPACKE_spprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpprfs_work$descriptor() {
        return LAPACKE_dpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpprfs_work$handle() {
        return LAPACKE_dpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpprfs_work$address() {
        return LAPACKE_dpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpprfs_work$descriptor() {
        return LAPACKE_cpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpprfs_work$handle() {
        return LAPACKE_cpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpprfs_work$address() {
        return LAPACKE_cpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpprfs_work$descriptor() {
        return LAPACKE_zpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpprfs_work$handle() {
        return LAPACKE_zpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpprfs_work$address() {
        return LAPACKE_zpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsv_work$descriptor() {
        return LAPACKE_sppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sppsv_work$handle() {
        return LAPACKE_sppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sppsv_work$address() {
        return LAPACKE_sppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsv_work$descriptor() {
        return LAPACKE_dppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dppsv_work$handle() {
        return LAPACKE_dppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dppsv_work$address() {
        return LAPACKE_dppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsv_work$descriptor() {
        return LAPACKE_cppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cppsv_work$handle() {
        return LAPACKE_cppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cppsv_work$address() {
        return LAPACKE_cppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsv_work$descriptor() {
        return LAPACKE_zppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zppsv_work$handle() {
        return LAPACKE_zppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zppsv_work$address() {
        return LAPACKE_zppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsvx_work$descriptor() {
        return LAPACKE_sppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sppsvx_work$handle() {
        return LAPACKE_sppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sppsvx_work$address() {
        return LAPACKE_sppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsvx_work$descriptor() {
        return LAPACKE_dppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dppsvx_work$handle() {
        return LAPACKE_dppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dppsvx_work$address() {
        return LAPACKE_dppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsvx_work$descriptor() {
        return LAPACKE_cppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cppsvx_work$handle() {
        return LAPACKE_cppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cppsvx_work$address() {
        return LAPACKE_cppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsvx_work$descriptor() {
        return LAPACKE_zppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zppsvx_work$handle() {
        return LAPACKE_zppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zppsvx_work$address() {
        return LAPACKE_zppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrf_work$descriptor() {
        return LAPACKE_spptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptrf_work$handle() {
        return LAPACKE_spptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptrf_work$address() {
        return LAPACKE_spptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrf_work$descriptor() {
        return LAPACKE_dpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptrf_work$handle() {
        return LAPACKE_dpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptrf_work$address() {
        return LAPACKE_dpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrf_work$descriptor() {
        return LAPACKE_cpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptrf_work$handle() {
        return LAPACKE_cpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptrf_work$address() {
        return LAPACKE_cpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrf_work$descriptor() {
        return LAPACKE_zpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptrf_work$handle() {
        return LAPACKE_zpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptrf_work$address() {
        return LAPACKE_zpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptri_work$descriptor() {
        return LAPACKE_spptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptri_work$handle() {
        return LAPACKE_spptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptri_work$address() {
        return LAPACKE_spptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptri_work$descriptor() {
        return LAPACKE_dpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptri_work$handle() {
        return LAPACKE_dpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptri_work$address() {
        return LAPACKE_dpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptri_work$descriptor() {
        return LAPACKE_cpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptri_work$handle() {
        return LAPACKE_cpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptri_work$address() {
        return LAPACKE_cpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptri_work$descriptor() {
        return LAPACKE_zpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptri_work$handle() {
        return LAPACKE_zpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptri_work$address() {
        return LAPACKE_zpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrs_work$descriptor() {
        return LAPACKE_spptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spptrs_work$handle() {
        return LAPACKE_spptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spptrs_work$address() {
        return LAPACKE_spptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrs_work$descriptor() {
        return LAPACKE_dpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpptrs_work$handle() {
        return LAPACKE_dpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpptrs_work$address() {
        return LAPACKE_dpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrs_work$descriptor() {
        return LAPACKE_cpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpptrs_work$handle() {
        return LAPACKE_cpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpptrs_work$address() {
        return LAPACKE_cpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrs_work$descriptor() {
        return LAPACKE_zpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpptrs_work$handle() {
        return LAPACKE_zpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpptrs_work$address() {
        return LAPACKE_zpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_spstrf_work$descriptor() {
        return LAPACKE_spstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MethodHandle LAPACKE_spstrf_work$handle() {
        return LAPACKE_spstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MemorySegment LAPACKE_spstrf_work$address() {
        return LAPACKE_spstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static int LAPACKE_spstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol, MemorySegment work) {
        var mh$ = LAPACKE_spstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpstrf_work$descriptor() {
        return LAPACKE_dpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dpstrf_work$handle() {
        return LAPACKE_dpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dpstrf_work$address() {
        return LAPACKE_dpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static int LAPACKE_dpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol, MemorySegment work) {
        var mh$ = LAPACKE_dpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpstrf_work$descriptor() {
        return LAPACKE_cpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cpstrf_work$handle() {
        return LAPACKE_cpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cpstrf_work$address() {
        return LAPACKE_cpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static int LAPACKE_cpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol, MemorySegment work) {
        var mh$ = LAPACKE_cpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpstrf_work$descriptor() {
        return LAPACKE_zpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zpstrf_work$handle() {
        return LAPACKE_zpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zpstrf_work$address() {
        return LAPACKE_zpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static int LAPACKE_zpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol, MemorySegment work) {
        var mh$ = LAPACKE_zpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptcon_work$descriptor() {
        return LAPACKE_sptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptcon_work$handle() {
        return LAPACKE_sptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptcon_work$address() {
        return LAPACKE_sptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static int LAPACKE_sptcon_work(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_sptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptcon_work$descriptor() {
        return LAPACKE_dptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptcon_work$handle() {
        return LAPACKE_dptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptcon_work$address() {
        return LAPACKE_dptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static int LAPACKE_dptcon_work(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_dptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptcon_work$descriptor() {
        return LAPACKE_cptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cptcon_work$handle() {
        return LAPACKE_cptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cptcon_work$address() {
        return LAPACKE_cptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static int LAPACKE_cptcon_work(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptcon_work$descriptor() {
        return LAPACKE_zptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zptcon_work$handle() {
        return LAPACKE_zptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zptcon_work$address() {
        return LAPACKE_zptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static int LAPACKE_zptcon_work(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_spteqr_work$descriptor() {
        return LAPACKE_spteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_spteqr_work$handle() {
        return LAPACKE_spteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_spteqr_work$address() {
        return LAPACKE_spteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_spteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_spteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpteqr_work$descriptor() {
        return LAPACKE_dpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dpteqr_work$handle() {
        return LAPACKE_dpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dpteqr_work$address() {
        return LAPACKE_dpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpteqr_work$descriptor() {
        return LAPACKE_cpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cpteqr_work$handle() {
        return LAPACKE_cpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cpteqr_work$address() {
        return LAPACKE_cpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_cpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_cpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpteqr_work$descriptor() {
        return LAPACKE_zpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zpteqr_work$handle() {
        return LAPACKE_zpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zpteqr_work$address() {
        return LAPACKE_zpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_zpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_zpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptrfs_work$descriptor() {
        return LAPACKE_sptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptrfs_work$handle() {
        return LAPACKE_sptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptrfs_work$address() {
        return LAPACKE_sptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_sptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptrfs_work", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptrfs_work$descriptor() {
        return LAPACKE_dptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptrfs_work$handle() {
        return LAPACKE_dptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptrfs_work$address() {
        return LAPACKE_dptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_dptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptrfs_work", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptrfs_work$descriptor() {
        return LAPACKE_cptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cptrfs_work$handle() {
        return LAPACKE_cptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cptrfs_work$address() {
        return LAPACKE_cptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cptrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptrfs_work", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptrfs_work$descriptor() {
        return LAPACKE_zptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zptrfs_work$handle() {
        return LAPACKE_zptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zptrfs_work$address() {
        return LAPACKE_zptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zptrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptrfs_work", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsv_work$descriptor() {
        return LAPACKE_sptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sptsv_work$handle() {
        return LAPACKE_sptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sptsv_work$address() {
        return LAPACKE_sptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsv_work$descriptor() {
        return LAPACKE_dptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dptsv_work$handle() {
        return LAPACKE_dptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dptsv_work$address() {
        return LAPACKE_dptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsv_work$descriptor() {
        return LAPACKE_cptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cptsv_work$handle() {
        return LAPACKE_cptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cptsv_work$address() {
        return LAPACKE_cptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsv_work$descriptor() {
        return LAPACKE_zptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zptsv_work$handle() {
        return LAPACKE_zptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zptsv_work$address() {
        return LAPACKE_zptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsvx_work$descriptor() {
        return LAPACKE_sptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptsvx_work$handle() {
        return LAPACKE_sptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptsvx_work$address() {
        return LAPACKE_sptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static int LAPACKE_sptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_sptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsvx_work$descriptor() {
        return LAPACKE_dptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptsvx_work$handle() {
        return LAPACKE_dptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptsvx_work$address() {
        return LAPACKE_dptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static int LAPACKE_dptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_dptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsvx_work$descriptor() {
        return LAPACKE_cptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cptsvx_work$handle() {
        return LAPACKE_cptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cptsvx_work$address() {
        return LAPACKE_cptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsvx_work$descriptor() {
        return LAPACKE_zptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zptsvx_work$handle() {
        return LAPACKE_zptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zptsvx_work$address() {
        return LAPACKE_zptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrf_work$descriptor() {
        return LAPACKE_spttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_spttrf_work$handle() {
        return LAPACKE_spttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_spttrf_work$address() {
        return LAPACKE_spttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_spttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_spttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrf_work$descriptor() {
        return LAPACKE_dpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dpttrf_work$handle() {
        return LAPACKE_dpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dpttrf_work$address() {
        return LAPACKE_dpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrf_work$descriptor() {
        return LAPACKE_cpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_cpttrf_work$handle() {
        return LAPACKE_cpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_cpttrf_work$address() {
        return LAPACKE_cpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static int LAPACKE_cpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_cpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrf_work$descriptor() {
        return LAPACKE_zpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zpttrf_work$handle() {
        return LAPACKE_zpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zpttrf_work$address() {
        return LAPACKE_zpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static int LAPACKE_zpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_zpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_spttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrs_work$descriptor() {
        return LAPACKE_spttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spttrs_work$handle() {
        return LAPACKE_spttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spttrs_work$address() {
        return LAPACKE_spttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrs_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrs_work$descriptor() {
        return LAPACKE_dpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpttrs_work$handle() {
        return LAPACKE_dpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpttrs_work$address() {
        return LAPACKE_dpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrs_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrs_work$descriptor() {
        return LAPACKE_cpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpttrs_work$handle() {
        return LAPACKE_cpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpttrs_work$address() {
        return LAPACKE_cpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpttrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrs_work", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrs_work$descriptor() {
        return LAPACKE_zpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpttrs_work$handle() {
        return LAPACKE_zpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpttrs_work$address() {
        return LAPACKE_zpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpttrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrs_work", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev_work$descriptor() {
        return LAPACKE_ssbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbev_work$handle() {
        return LAPACKE_ssbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbev_work$address() {
        return LAPACKE_ssbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev_work$descriptor() {
        return LAPACKE_dsbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbev_work$handle() {
        return LAPACKE_dsbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbev_work$address() {
        return LAPACKE_dsbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd_work$descriptor() {
        return LAPACKE_ssbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd_work$handle() {
        return LAPACKE_ssbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd_work$address() {
        return LAPACKE_ssbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd_work$descriptor() {
        return LAPACKE_dsbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd_work$handle() {
        return LAPACKE_dsbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd_work$address() {
        return LAPACKE_dsbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx_work$descriptor() {
        return LAPACKE_ssbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx_work$handle() {
        return LAPACKE_ssbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx_work$address() {
        return LAPACKE_ssbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx_work$descriptor() {
        return LAPACKE_dsbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx_work$handle() {
        return LAPACKE_dsbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx_work$address() {
        return LAPACKE_dsbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgst_work$descriptor() {
        return LAPACKE_ssbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbgst_work$handle() {
        return LAPACKE_ssbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbgst_work$address() {
        return LAPACKE_ssbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static int LAPACKE_ssbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work) {
        var mh$ = LAPACKE_ssbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgst_work$descriptor() {
        return LAPACKE_dsbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbgst_work$handle() {
        return LAPACKE_dsbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbgst_work$address() {
        return LAPACKE_dsbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static int LAPACKE_dsbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work) {
        var mh$ = LAPACKE_dsbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgv_work$descriptor() {
        return LAPACKE_ssbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbgv_work$handle() {
        return LAPACKE_ssbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbgv_work$address() {
        return LAPACKE_ssbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgv_work$descriptor() {
        return LAPACKE_dsbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbgv_work$handle() {
        return LAPACKE_dsbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbgv_work$address() {
        return LAPACKE_dsbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvd_work$descriptor() {
        return LAPACKE_ssbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvd_work$handle() {
        return LAPACKE_ssbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvd_work$address() {
        return LAPACKE_ssbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvd_work$descriptor() {
        return LAPACKE_dsbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvd_work$handle() {
        return LAPACKE_dsbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvd_work$address() {
        return LAPACKE_dsbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvx_work$descriptor() {
        return LAPACKE_ssbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvx_work$handle() {
        return LAPACKE_ssbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvx_work$address() {
        return LAPACKE_ssbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvx_work$descriptor() {
        return LAPACKE_dsbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvx_work$handle() {
        return LAPACKE_dsbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvx_work$address() {
        return LAPACKE_dsbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbtrd_work$descriptor() {
        return LAPACKE_ssbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbtrd_work$handle() {
        return LAPACKE_ssbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbtrd_work$address() {
        return LAPACKE_ssbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static int LAPACKE_ssbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_ssbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbtrd_work$descriptor() {
        return LAPACKE_dsbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbtrd_work$handle() {
        return LAPACKE_dsbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbtrd_work$address() {
        return LAPACKE_dsbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static int LAPACKE_dsbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_dsbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssfrk_work$descriptor() {
        return LAPACKE_ssfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MethodHandle LAPACKE_ssfrk_work$handle() {
        return LAPACKE_ssfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MemorySegment LAPACKE_ssfrk_work$address() {
        return LAPACKE_ssfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static int LAPACKE_ssfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_ssfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsfrk_work$descriptor() {
        return LAPACKE_dsfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MethodHandle LAPACKE_dsfrk_work$handle() {
        return LAPACKE_dsfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MemorySegment LAPACKE_dsfrk_work$address() {
        return LAPACKE_dsfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static int LAPACKE_dsfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_dsfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspcon_work$descriptor() {
        return LAPACKE_sspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sspcon_work$handle() {
        return LAPACKE_sspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sspcon_work$address() {
        return LAPACKE_sspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspcon_work$descriptor() {
        return LAPACKE_dspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dspcon_work$handle() {
        return LAPACKE_dspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dspcon_work$address() {
        return LAPACKE_dspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspcon_work$descriptor() {
        return LAPACKE_cspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cspcon_work$handle() {
        return LAPACKE_cspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cspcon_work$address() {
        return LAPACKE_cspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_cspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspcon_work$descriptor() {
        return LAPACKE_zspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zspcon_work$handle() {
        return LAPACKE_zspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zspcon_work$address() {
        return LAPACKE_zspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspev_work$descriptor() {
        return LAPACKE_sspev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sspev_work$handle() {
        return LAPACKE_sspev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sspev_work$address() {
        return LAPACKE_sspev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sspev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sspev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspev_work$descriptor() {
        return LAPACKE_dspev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dspev_work$handle() {
        return LAPACKE_dspev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dspev_work$address() {
        return LAPACKE_dspev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dspev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dspev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevd_work$descriptor() {
        return LAPACKE_sspevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sspevd_work$handle() {
        return LAPACKE_sspevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sspevd_work$address() {
        return LAPACKE_sspevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sspevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sspevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevd_work$descriptor() {
        return LAPACKE_dspevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dspevd_work$handle() {
        return LAPACKE_dspevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dspevd_work$address() {
        return LAPACKE_dspevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dspevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dspevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevx_work$descriptor() {
        return LAPACKE_sspevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspevx_work$handle() {
        return LAPACKE_sspevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspevx_work$address() {
        return LAPACKE_sspevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sspevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sspevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevx_work$descriptor() {
        return LAPACKE_dspevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspevx_work$handle() {
        return LAPACKE_dspevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspevx_work$address() {
        return LAPACKE_dspevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dspevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dspevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgst_work$descriptor() {
        return LAPACKE_sspgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MethodHandle LAPACKE_sspgst_work$handle() {
        return LAPACKE_sspgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MemorySegment LAPACKE_sspgst_work$address() {
        return LAPACKE_sspgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static int LAPACKE_sspgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_sspgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgst_work$descriptor() {
        return LAPACKE_dspgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MethodHandle LAPACKE_dspgst_work$handle() {
        return LAPACKE_dspgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MemorySegment LAPACKE_dspgst_work$address() {
        return LAPACKE_dspgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static int LAPACKE_dspgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_dspgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgv_work$descriptor() {
        return LAPACKE_sspgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sspgv_work$handle() {
        return LAPACKE_sspgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sspgv_work$address() {
        return LAPACKE_sspgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sspgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sspgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgv_work$descriptor() {
        return LAPACKE_dspgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dspgv_work$handle() {
        return LAPACKE_dspgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dspgv_work$address() {
        return LAPACKE_dspgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dspgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dspgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvd_work$descriptor() {
        return LAPACKE_sspgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sspgvd_work$handle() {
        return LAPACKE_sspgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sspgvd_work$address() {
        return LAPACKE_sspgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sspgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sspgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvd_work$descriptor() {
        return LAPACKE_dspgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dspgvd_work$handle() {
        return LAPACKE_dspgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dspgvd_work$address() {
        return LAPACKE_dspgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dspgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dspgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvx_work$descriptor() {
        return LAPACKE_sspgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspgvx_work$handle() {
        return LAPACKE_sspgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspgvx_work$address() {
        return LAPACKE_sspgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sspgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sspgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvx_work$descriptor() {
        return LAPACKE_dspgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspgvx_work$handle() {
        return LAPACKE_dspgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspgvx_work$address() {
        return LAPACKE_dspgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dspgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dspgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssprfs_work$descriptor() {
        return LAPACKE_ssprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssprfs_work$handle() {
        return LAPACKE_ssprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssprfs_work$address() {
        return LAPACKE_ssprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsprfs_work$descriptor() {
        return LAPACKE_dsprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsprfs_work$handle() {
        return LAPACKE_dsprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsprfs_work$address() {
        return LAPACKE_dsprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csprfs_work$descriptor() {
        return LAPACKE_csprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csprfs_work$handle() {
        return LAPACKE_csprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csprfs_work$address() {
        return LAPACKE_csprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsprfs_work$descriptor() {
        return LAPACKE_zsprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsprfs_work$handle() {
        return LAPACKE_zsprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsprfs_work$address() {
        return LAPACKE_zsprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsv_work$descriptor() {
        return LAPACKE_sspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sspsv_work$handle() {
        return LAPACKE_sspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sspsv_work$address() {
        return LAPACKE_sspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsv_work$descriptor() {
        return LAPACKE_dspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dspsv_work$handle() {
        return LAPACKE_dspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dspsv_work$address() {
        return LAPACKE_dspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsv_work$descriptor() {
        return LAPACKE_cspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cspsv_work$handle() {
        return LAPACKE_cspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cspsv_work$address() {
        return LAPACKE_cspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsv_work$descriptor() {
        return LAPACKE_zspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zspsv_work$handle() {
        return LAPACKE_zspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zspsv_work$address() {
        return LAPACKE_zspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsvx_work$descriptor() {
        return LAPACKE_sspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sspsvx_work$handle() {
        return LAPACKE_sspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sspsvx_work$address() {
        return LAPACKE_sspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsvx_work$descriptor() {
        return LAPACKE_dspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dspsvx_work$handle() {
        return LAPACKE_dspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dspsvx_work$address() {
        return LAPACKE_dspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsvx_work$descriptor() {
        return LAPACKE_cspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cspsvx_work$handle() {
        return LAPACKE_cspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cspsvx_work$address() {
        return LAPACKE_cspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsvx_work$descriptor() {
        return LAPACKE_zspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zspsvx_work$handle() {
        return LAPACKE_zspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zspsvx_work$address() {
        return LAPACKE_zspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrd_work$descriptor() {
        return LAPACKE_ssptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssptrd_work$handle() {
        return LAPACKE_ssptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssptrd_work$address() {
        return LAPACKE_ssptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrd_work$descriptor() {
        return LAPACKE_dsptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsptrd_work$handle() {
        return LAPACKE_dsptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsptrd_work$address() {
        return LAPACKE_dsptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrf_work$descriptor() {
        return LAPACKE_ssptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptrf_work$handle() {
        return LAPACKE_ssptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptrf_work$address() {
        return LAPACKE_ssptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_ssptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrf_work$descriptor() {
        return LAPACKE_dsptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptrf_work$handle() {
        return LAPACKE_dsptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptrf_work$address() {
        return LAPACKE_dsptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_dsptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrf_work$descriptor() {
        return LAPACKE_csptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptrf_work$handle() {
        return LAPACKE_csptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptrf_work$address() {
        return LAPACKE_csptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_csptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrf_work$descriptor() {
        return LAPACKE_zsptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptrf_work$handle() {
        return LAPACKE_zsptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptrf_work$address() {
        return LAPACKE_zsptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zsptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptri_work$descriptor() {
        return LAPACKE_ssptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssptri_work$handle() {
        return LAPACKE_ssptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssptri_work$address() {
        return LAPACKE_ssptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static int LAPACKE_ssptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_ssptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptri_work$descriptor() {
        return LAPACKE_dsptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsptri_work$handle() {
        return LAPACKE_dsptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsptri_work$address() {
        return LAPACKE_dsptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static int LAPACKE_dsptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_dsptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptri_work$descriptor() {
        return LAPACKE_csptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csptri_work$handle() {
        return LAPACKE_csptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csptri_work$address() {
        return LAPACKE_csptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_csptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_csptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptri_work$descriptor() {
        return LAPACKE_zsptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsptri_work$handle() {
        return LAPACKE_zsptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsptri_work$address() {
        return LAPACKE_zsptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zsptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrs_work$descriptor() {
        return LAPACKE_ssptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssptrs_work$handle() {
        return LAPACKE_ssptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssptrs_work$address() {
        return LAPACKE_ssptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrs_work$descriptor() {
        return LAPACKE_dsptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsptrs_work$handle() {
        return LAPACKE_dsptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsptrs_work$address() {
        return LAPACKE_dsptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrs_work$descriptor() {
        return LAPACKE_csptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csptrs_work$handle() {
        return LAPACKE_csptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csptrs_work$address() {
        return LAPACKE_csptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrs_work$descriptor() {
        return LAPACKE_zsptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsptrs_work$handle() {
        return LAPACKE_zsptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsptrs_work$address() {
        return LAPACKE_zsptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstebz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstebz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstebz_work$descriptor() {
        return LAPACKE_sstebz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sstebz_work$handle() {
        return LAPACKE_sstebz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sstebz_work$address() {
        return LAPACKE_sstebz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sstebz_work(byte range, byte order, int n, float vl, float vu, int il, int iu, float abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sstebz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstebz_work", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstebz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstebz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstebz_work$descriptor() {
        return LAPACKE_dstebz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dstebz_work$handle() {
        return LAPACKE_dstebz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dstebz_work$address() {
        return LAPACKE_dstebz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dstebz_work(byte range, byte order, int n, double vl, double vu, int il, int iu, double abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dstebz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstebz_work", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstedc_work$descriptor() {
        return LAPACKE_sstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstedc_work$handle() {
        return LAPACKE_sstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstedc_work$address() {
        return LAPACKE_sstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstedc_work$descriptor() {
        return LAPACKE_dstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstedc_work$handle() {
        return LAPACKE_dstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstedc_work$address() {
        return LAPACKE_dstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstedc_work$descriptor() {
        return LAPACKE_cstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstedc_work$handle() {
        return LAPACKE_cstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstedc_work$address() {
        return LAPACKE_cstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstedc_work$descriptor() {
        return LAPACKE_zstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstedc_work$handle() {
        return LAPACKE_zstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstedc_work$address() {
        return LAPACKE_zstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstegr_work$descriptor() {
        return LAPACKE_sstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstegr_work$handle() {
        return LAPACKE_sstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstegr_work$address() {
        return LAPACKE_sstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstegr_work$descriptor() {
        return LAPACKE_dstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstegr_work$handle() {
        return LAPACKE_dstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstegr_work$address() {
        return LAPACKE_dstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstegr_work$descriptor() {
        return LAPACKE_cstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstegr_work$handle() {
        return LAPACKE_cstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstegr_work$address() {
        return LAPACKE_cstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstegr_work$descriptor() {
        return LAPACKE_zstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstegr_work$handle() {
        return LAPACKE_zstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstegr_work$address() {
        return LAPACKE_zstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstein_work$descriptor() {
        return LAPACKE_sstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_sstein_work$handle() {
        return LAPACKE_sstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_sstein_work$address() {
        return LAPACKE_sstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_sstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_sstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstein_work$descriptor() {
        return LAPACKE_dstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_dstein_work$handle() {
        return LAPACKE_dstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_dstein_work$address() {
        return LAPACKE_dstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_dstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_dstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstein_work$descriptor() {
        return LAPACKE_cstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_cstein_work$handle() {
        return LAPACKE_cstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_cstein_work$address() {
        return LAPACKE_cstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_cstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_cstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstein_work$descriptor() {
        return LAPACKE_zstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_zstein_work$handle() {
        return LAPACKE_zstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_zstein_work$address() {
        return LAPACKE_zstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_zstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_zstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstemr_work$descriptor() {
        return LAPACKE_sstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstemr_work$handle() {
        return LAPACKE_sstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstemr_work$address() {
        return LAPACKE_sstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstemr_work$descriptor() {
        return LAPACKE_dstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstemr_work$handle() {
        return LAPACKE_dstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstemr_work$address() {
        return LAPACKE_dstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstemr_work$descriptor() {
        return LAPACKE_cstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstemr_work$handle() {
        return LAPACKE_cstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstemr_work$address() {
        return LAPACKE_cstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstemr_work$descriptor() {
        return LAPACKE_zstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstemr_work$handle() {
        return LAPACKE_zstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstemr_work$address() {
        return LAPACKE_zstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssteqr_work$descriptor() {
        return LAPACKE_ssteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssteqr_work$handle() {
        return LAPACKE_ssteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssteqr_work$address() {
        return LAPACKE_ssteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsteqr_work$descriptor() {
        return LAPACKE_dsteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsteqr_work$handle() {
        return LAPACKE_dsteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsteqr_work$address() {
        return LAPACKE_dsteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csteqr_work$descriptor() {
        return LAPACKE_csteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_csteqr_work$handle() {
        return LAPACKE_csteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_csteqr_work$address() {
        return LAPACKE_csteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_csteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_csteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsteqr_work$descriptor() {
        return LAPACKE_zsteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsteqr_work$handle() {
        return LAPACKE_zsteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsteqr_work$address() {
        return LAPACKE_zsteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_zsteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_zsteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssterf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssterf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssterf_work$descriptor() {
        return LAPACKE_ssterf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssterf_work$handle() {
        return LAPACKE_ssterf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssterf_work$address() {
        return LAPACKE_ssterf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_ssterf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_ssterf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssterf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsterf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsterf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsterf_work$descriptor() {
        return LAPACKE_dsterf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsterf_work$handle() {
        return LAPACKE_dsterf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsterf_work$address() {
        return LAPACKE_dsterf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dsterf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dsterf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsterf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstev_work$descriptor() {
        return LAPACKE_sstev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sstev_work$handle() {
        return LAPACKE_sstev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sstev_work$address() {
        return LAPACKE_sstev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sstev_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sstev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstev_work", matrix_layout, jobz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstev_work$descriptor() {
        return LAPACKE_dstev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dstev_work$handle() {
        return LAPACKE_dstev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dstev_work$address() {
        return LAPACKE_dstev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dstev_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dstev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstev_work", matrix_layout, jobz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevd_work$descriptor() {
        return LAPACKE_sstevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstevd_work$handle() {
        return LAPACKE_sstevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstevd_work$address() {
        return LAPACKE_sstevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstevd_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevd_work", matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevd_work$descriptor() {
        return LAPACKE_dstevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstevd_work$handle() {
        return LAPACKE_dstevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstevd_work$address() {
        return LAPACKE_dstevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstevd_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevd_work", matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevr_work$descriptor() {
        return LAPACKE_sstevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstevr_work$handle() {
        return LAPACKE_sstevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstevr_work$address() {
        return LAPACKE_sstevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstevr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevr_work$descriptor() {
        return LAPACKE_dstevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstevr_work$handle() {
        return LAPACKE_dstevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstevr_work$address() {
        return LAPACKE_dstevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstevr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sstevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevx_work$descriptor() {
        return LAPACKE_sstevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sstevx_work$handle() {
        return LAPACKE_sstevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sstevx_work$address() {
        return LAPACKE_sstevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sstevx_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sstevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevx_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dstevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevx_work$descriptor() {
        return LAPACKE_dstevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dstevx_work$handle() {
        return LAPACKE_dstevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dstevx_work$address() {
        return LAPACKE_dstevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dstevx_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dstevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevx_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon_work$descriptor() {
        return LAPACKE_ssycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssycon_work$handle() {
        return LAPACKE_ssycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssycon_work$address() {
        return LAPACKE_ssycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon_work$descriptor() {
        return LAPACKE_dsycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsycon_work$handle() {
        return LAPACKE_dsycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsycon_work$address() {
        return LAPACKE_dsycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon_work$descriptor() {
        return LAPACKE_csycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csycon_work$handle() {
        return LAPACKE_csycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csycon_work$address() {
        return LAPACKE_csycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_csycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_csycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon_work$descriptor() {
        return LAPACKE_zsycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsycon_work$handle() {
        return LAPACKE_zsycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsycon_work$address() {
        return LAPACKE_zsycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zsycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyequb_work$descriptor() {
        return LAPACKE_ssyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssyequb_work$handle() {
        return LAPACKE_ssyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssyequb_work$address() {
        return LAPACKE_ssyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static int LAPACKE_ssyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_ssyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyequb_work$descriptor() {
        return LAPACKE_dsyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsyequb_work$handle() {
        return LAPACKE_dsyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsyequb_work$address() {
        return LAPACKE_dsyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static int LAPACKE_dsyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_dsyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyequb_work$descriptor() {
        return LAPACKE_csyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csyequb_work$handle() {
        return LAPACKE_csyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csyequb_work$address() {
        return LAPACKE_csyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static int LAPACKE_csyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_csyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyequb_work$descriptor() {
        return LAPACKE_zsyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsyequb_work$handle() {
        return LAPACKE_zsyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsyequb_work$address() {
        return LAPACKE_zsyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_zsyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev_work$descriptor() {
        return LAPACKE_ssyev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyev_work$handle() {
        return LAPACKE_ssyev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyev_work$address() {
        return LAPACKE_ssyev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssyev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssyev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev_work$descriptor() {
        return LAPACKE_dsyev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyev_work$handle() {
        return LAPACKE_dsyev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyev_work$address() {
        return LAPACKE_dsyev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsyev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsyev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd_work$descriptor() {
        return LAPACKE_ssyevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd_work$handle() {
        return LAPACKE_ssyevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd_work$address() {
        return LAPACKE_ssyevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd_work$descriptor() {
        return LAPACKE_dsyevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd_work$handle() {
        return LAPACKE_dsyevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd_work$address() {
        return LAPACKE_dsyevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr_work$descriptor() {
        return LAPACKE_ssyevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr_work$handle() {
        return LAPACKE_ssyevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr_work$address() {
        return LAPACKE_ssyevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr_work$descriptor() {
        return LAPACKE_dsyevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr_work$handle() {
        return LAPACKE_dsyevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr_work$address() {
        return LAPACKE_dsyevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx_work$descriptor() {
        return LAPACKE_ssyevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx_work$handle() {
        return LAPACKE_ssyevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx_work$address() {
        return LAPACKE_ssyevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx_work$descriptor() {
        return LAPACKE_dsyevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx_work$handle() {
        return LAPACKE_dsyevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx_work$address() {
        return LAPACKE_dsyevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygst_work$descriptor() {
        return LAPACKE_ssygst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssygst_work$handle() {
        return LAPACKE_ssygst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssygst_work$address() {
        return LAPACKE_ssygst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssygst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssygst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygst_work$descriptor() {
        return LAPACKE_dsygst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsygst_work$handle() {
        return LAPACKE_dsygst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsygst_work$address() {
        return LAPACKE_dsygst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsygst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsygst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv_work$descriptor() {
        return LAPACKE_ssygv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssygv_work$handle() {
        return LAPACKE_ssygv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssygv_work$address() {
        return LAPACKE_ssygv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssygv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssygv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv_work$descriptor() {
        return LAPACKE_dsygv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsygv_work$handle() {
        return LAPACKE_dsygv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsygv_work$address() {
        return LAPACKE_dsygv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsygv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsygv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvd_work$descriptor() {
        return LAPACKE_ssygvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssygvd_work$handle() {
        return LAPACKE_ssygvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssygvd_work$address() {
        return LAPACKE_ssygvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssygvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssygvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvd_work$descriptor() {
        return LAPACKE_dsygvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsygvd_work$handle() {
        return LAPACKE_dsygvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsygvd_work$address() {
        return LAPACKE_dsygvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsygvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsygvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvx_work$descriptor() {
        return LAPACKE_ssygvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssygvx_work$handle() {
        return LAPACKE_ssygvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssygvx_work$address() {
        return LAPACKE_ssygvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssygvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssygvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvx_work$descriptor() {
        return LAPACKE_dsygvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsygvx_work$handle() {
        return LAPACKE_dsygvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsygvx_work$address() {
        return LAPACKE_dsygvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsygvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsygvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfs_work$descriptor() {
        return LAPACKE_ssyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfs_work$handle() {
        return LAPACKE_ssyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfs_work$address() {
        return LAPACKE_ssyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfs_work$descriptor() {
        return LAPACKE_dsyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfs_work$handle() {
        return LAPACKE_dsyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfs_work$address() {
        return LAPACKE_dsyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfs_work$descriptor() {
        return LAPACKE_csyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csyrfs_work$handle() {
        return LAPACKE_csyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csyrfs_work$address() {
        return LAPACKE_csyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfs_work$descriptor() {
        return LAPACKE_zsyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfs_work$handle() {
        return LAPACKE_zsyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfs_work$address() {
        return LAPACKE_zsyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfsx_work$descriptor() {
        return LAPACKE_ssyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfsx_work$handle() {
        return LAPACKE_ssyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfsx_work$address() {
        return LAPACKE_ssyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfsx_work$descriptor() {
        return LAPACKE_dsyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfsx_work$handle() {
        return LAPACKE_dsyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfsx_work$address() {
        return LAPACKE_dsyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfsx_work$descriptor() {
        return LAPACKE_csyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csyrfsx_work$handle() {
        return LAPACKE_csyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csyrfsx_work$address() {
        return LAPACKE_csyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfsx_work$descriptor() {
        return LAPACKE_zsyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfsx_work$handle() {
        return LAPACKE_zsyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfsx_work$address() {
        return LAPACKE_zsyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_work$descriptor() {
        return LAPACKE_ssysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_work$handle() {
        return LAPACKE_ssysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_work$address() {
        return LAPACKE_ssysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_work$descriptor() {
        return LAPACKE_dsysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_work$handle() {
        return LAPACKE_dsysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_work$address() {
        return LAPACKE_dsysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_work$descriptor() {
        return LAPACKE_csysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_work$handle() {
        return LAPACKE_csysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_work$address() {
        return LAPACKE_csysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_work$descriptor() {
        return LAPACKE_zsysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_work$handle() {
        return LAPACKE_zsysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_work$address() {
        return LAPACKE_zsysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvx_work$descriptor() {
        return LAPACKE_ssysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysvx_work$handle() {
        return LAPACKE_ssysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysvx_work$address() {
        return LAPACKE_ssysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ssysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ssysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvx_work$descriptor() {
        return LAPACKE_dsysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysvx_work$handle() {
        return LAPACKE_dsysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysvx_work$address() {
        return LAPACKE_dsysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dsysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dsysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvx_work$descriptor() {
        return LAPACKE_csysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csysvx_work$handle() {
        return LAPACKE_csysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csysvx_work$address() {
        return LAPACKE_csysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_csysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_csysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvx_work$descriptor() {
        return LAPACKE_zsysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysvx_work$handle() {
        return LAPACKE_zsysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysvx_work$address() {
        return LAPACKE_zsysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zsysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zsysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvxx_work$descriptor() {
        return LAPACKE_ssysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysvxx_work$handle() {
        return LAPACKE_ssysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysvxx_work$address() {
        return LAPACKE_ssysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvxx_work$descriptor() {
        return LAPACKE_dsysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysvxx_work$handle() {
        return LAPACKE_dsysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysvxx_work$address() {
        return LAPACKE_dsysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvxx_work$descriptor() {
        return LAPACKE_csysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csysvxx_work$handle() {
        return LAPACKE_csysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csysvxx_work$address() {
        return LAPACKE_csysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvxx_work$descriptor() {
        return LAPACKE_zsysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysvxx_work$handle() {
        return LAPACKE_zsysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysvxx_work$address() {
        return LAPACKE_zsysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrd_work$descriptor() {
        return LAPACKE_ssytrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrd_work$handle() {
        return LAPACKE_ssytrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrd_work$address() {
        return LAPACKE_ssytrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrd_work$descriptor() {
        return LAPACKE_dsytrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrd_work$handle() {
        return LAPACKE_dsytrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrd_work$address() {
        return LAPACKE_dsytrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_work$descriptor() {
        return LAPACKE_ssytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_work$handle() {
        return LAPACKE_ssytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_work$address() {
        return LAPACKE_ssytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_work$descriptor() {
        return LAPACKE_dsytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_work$handle() {
        return LAPACKE_dsytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_work$address() {
        return LAPACKE_dsytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_work$descriptor() {
        return LAPACKE_csytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_work$handle() {
        return LAPACKE_csytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_work$address() {
        return LAPACKE_csytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_work$descriptor() {
        return LAPACKE_zsytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_work$handle() {
        return LAPACKE_zsytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_work$address() {
        return LAPACKE_zsytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri_work$descriptor() {
        return LAPACKE_ssytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssytri_work$handle() {
        return LAPACKE_ssytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssytri_work$address() {
        return LAPACKE_ssytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static int LAPACKE_ssytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_ssytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri_work$descriptor() {
        return LAPACKE_dsytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsytri_work$handle() {
        return LAPACKE_dsytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsytri_work$address() {
        return LAPACKE_dsytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static int LAPACKE_dsytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_dsytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri_work$descriptor() {
        return LAPACKE_csytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csytri_work$handle() {
        return LAPACKE_csytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csytri_work$address() {
        return LAPACKE_csytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_csytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_csytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri_work$descriptor() {
        return LAPACKE_zsytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsytri_work$handle() {
        return LAPACKE_zsytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsytri_work$address() {
        return LAPACKE_zsytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zsytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_work$descriptor() {
        return LAPACKE_ssytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_work$handle() {
        return LAPACKE_ssytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_work$address() {
        return LAPACKE_ssytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_work$descriptor() {
        return LAPACKE_dsytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_work$handle() {
        return LAPACKE_dsytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_work$address() {
        return LAPACKE_dsytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_work$descriptor() {
        return LAPACKE_csytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_work$handle() {
        return LAPACKE_csytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_work$address() {
        return LAPACKE_csytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_work$descriptor() {
        return LAPACKE_zsytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_work$handle() {
        return LAPACKE_zsytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_work$address() {
        return LAPACKE_zsytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbcon_work$descriptor() {
        return LAPACKE_stbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stbcon_work$handle() {
        return LAPACKE_stbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stbcon_work$address() {
        return LAPACKE_stbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbcon_work$descriptor() {
        return LAPACKE_dtbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtbcon_work$handle() {
        return LAPACKE_dtbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtbcon_work$address() {
        return LAPACKE_dtbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbcon_work$descriptor() {
        return LAPACKE_ctbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctbcon_work$handle() {
        return LAPACKE_ctbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctbcon_work$address() {
        return LAPACKE_ctbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbcon_work$descriptor() {
        return LAPACKE_ztbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztbcon_work$handle() {
        return LAPACKE_ztbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztbcon_work$address() {
        return LAPACKE_ztbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

