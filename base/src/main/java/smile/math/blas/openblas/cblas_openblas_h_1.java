// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h_1 {

    cblas_openblas_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final String OS = System.getProperty("os.name", "linux").toLowerCase().split(" ")[0];
    static final String LIBRARY_NAME = switch (OS) {
        case "mac" -> "blas"; // macOS's builtin Accelerate framework
        case "windows" -> "mkl_rt"; // Intel's MKL
        default -> "openblas"; // OpenBLAS
    };
    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName(LIBRARY_NAME), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int OPENBLAS_OS_LINUX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OS_LINUX 1
     * }
     */
    public static int OPENBLAS_OS_LINUX() {
        return OPENBLAS_OS_LINUX;
    }
    private static final int OPENBLAS_ARCH_X86_64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ARCH_X86_64 1
     * }
     */
    public static int OPENBLAS_ARCH_X86_64() {
        return OPENBLAS_ARCH_X86_64;
    }
    private static final int OPENBLAS_C_GCC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_C_GCC 1
     * }
     */
    public static int OPENBLAS_C_GCC() {
        return OPENBLAS_C_GCC;
    }
    private static final int OPENBLAS___64BIT__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS___64BIT__ 1
     * }
     */
    public static int OPENBLAS___64BIT__() {
        return OPENBLAS___64BIT__;
    }
    private static final int OPENBLAS_HAVE_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_HAVE_C11 1
     * }
     */
    public static int OPENBLAS_HAVE_C11() {
        return OPENBLAS_HAVE_C11;
    }
    private static final int OPENBLAS_NEEDBUNDERSCORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_NEEDBUNDERSCORE 1
     * }
     */
    public static int OPENBLAS_NEEDBUNDERSCORE() {
        return OPENBLAS_NEEDBUNDERSCORE;
    }
    private static final int OPENBLAS_L1_DATA_SIZE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_SIZE 32768
     * }
     */
    public static int OPENBLAS_L1_DATA_SIZE() {
        return OPENBLAS_L1_DATA_SIZE;
    }
    private static final int OPENBLAS_L1_DATA_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L1_DATA_LINESIZE() {
        return OPENBLAS_L1_DATA_LINESIZE;
    }
    private static final int OPENBLAS_L2_SIZE = (int)512488L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_SIZE 512488
     * }
     */
    public static int OPENBLAS_L2_SIZE() {
        return OPENBLAS_L2_SIZE;
    }
    private static final int OPENBLAS_L2_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L2_LINESIZE() {
        return OPENBLAS_L2_LINESIZE;
    }
    private static final int OPENBLAS_DTB_DEFAULT_ENTRIES = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_DEFAULT_ENTRIES 128
     * }
     */
    public static int OPENBLAS_DTB_DEFAULT_ENTRIES() {
        return OPENBLAS_DTB_DEFAULT_ENTRIES;
    }
    private static final int OPENBLAS_DTB_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_SIZE 4096
     * }
     */
    public static int OPENBLAS_DTB_SIZE() {
        return OPENBLAS_DTB_SIZE;
    }
    private static final int OPENBLAS_L2_ASSOCIATIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_ASSOCIATIVE 8
     * }
     */
    public static int OPENBLAS_L2_ASSOCIATIVE() {
        return OPENBLAS_L2_ASSOCIATIVE;
    }
    private static final int OPENBLAS_SLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_SLOCAL_BUFFER_SIZE() {
        return OPENBLAS_SLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_DLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_DLOCAL_BUFFER_SIZE() {
        return OPENBLAS_DLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_CLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_CLOCAL_BUFFER_SIZE() {
        return OPENBLAS_CLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_ZLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ZLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_ZLOCAL_BUFFER_SIZE() {
        return OPENBLAS_ZLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_GEMM_MULTITHREAD_THRESHOLD 4
     * }
     */
    public static int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD() {
        return OPENBLAS_GEMM_MULTITHREAD_THRESHOLD;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _COMPLEX_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _COMPLEX_H 1
     * }
     */
    public static int _COMPLEX_H() {
        return _COMPLEX_H;
    }
    private static final int _SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SCHED_H 1
     * }
     */
    public static int _SCHED_H() {
        return _SCHED_H;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SCHED_H 1
     * }
     */
    public static int _BITS_SCHED_H() {
        return _BITS_SCHED_H;
    }
    private static final int SCHED_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 0
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 1
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int _BITS_TYPES_STRUCT_SCHED_PARAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_STRUCT_SCHED_PARAM 1
     * }
     */
    public static int _BITS_TYPES_STRUCT_SCHED_PARAM() {
        return _BITS_TYPES_STRUCT_SCHED_PARAM;
    }
    private static final int _BITS_CPU_SET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_CPU_SET_H 1
     * }
     */
    public static int _BITS_CPU_SET_H() {
        return _BITS_CPU_SET_H;
    }
    private static final int __CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __CPU_SETSIZE 1024
     * }
     */
    public static int __CPU_SETSIZE() {
        return __CPU_SETSIZE;
    }
    private static final int OPENBLAS_SEQUENTIAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SEQUENTIAL 0
     * }
     */
    public static int OPENBLAS_SEQUENTIAL() {
        return OPENBLAS_SEQUENTIAL;
    }
    private static final int OPENBLAS_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_THREAD 1
     * }
     */
    public static int OPENBLAS_THREAD() {
        return OPENBLAS_THREAD;
    }
    private static final int OPENBLAS_OPENMP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OPENMP 2
     * }
     */
    public static int OPENBLAS_OPENMP() {
        return OPENBLAS_OPENMP;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long BLASLONG
     * }
     */
    public static final OfLong BLASLONG = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long BLASULONG
     * }
     */
    public static final OfLong BLASULONG = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = cblas_openblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = cblas_openblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint16_t bfloat16
     * }
     */
    public static final OfShort bfloat16 = cblas_openblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int blasint
     * }
     */
    public static final OfInt blasint = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = cblas_openblas_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = cblas_openblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_openblas_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_LONG,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = cblas_openblas_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = cblas_openblas_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = cblas_openblas_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacos$descriptor() {
        return cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MethodHandle cacos$handle() {
        return cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MemorySegment cacos$address() {
        return cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static double cacos(double __z) {
        var mh$ = cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacos$descriptor() {
        return __cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MethodHandle __cacos$handle() {
        return __cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MemorySegment __cacos$address() {
        return __cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static double __cacos(double __z) {
        var mh$ = __cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casin$descriptor() {
        return casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MethodHandle casin$handle() {
        return casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MemorySegment casin$address() {
        return casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static double casin(double __z) {
        var mh$ = casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casin$descriptor() {
        return __casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MethodHandle __casin$handle() {
        return __casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MemorySegment __casin$address() {
        return __casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static double __casin(double __z) {
        var mh$ = __casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catan$descriptor() {
        return catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MethodHandle catan$handle() {
        return catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MemorySegment catan$address() {
        return catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static double catan(double __z) {
        var mh$ = catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catan$descriptor() {
        return __catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MethodHandle __catan$handle() {
        return __catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MemorySegment __catan$address() {
        return __catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static double __catan(double __z) {
        var mh$ = __catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccos$descriptor() {
        return ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MethodHandle ccos$handle() {
        return ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MemorySegment ccos$address() {
        return ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static double ccos(double __z) {
        var mh$ = ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccos$descriptor() {
        return __ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MethodHandle __ccos$handle() {
        return __ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MemorySegment __ccos$address() {
        return __ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static double __ccos(double __z) {
        var mh$ = __ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csin$descriptor() {
        return csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MethodHandle csin$handle() {
        return csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MemorySegment csin$address() {
        return csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static double csin(double __z) {
        var mh$ = csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csin$descriptor() {
        return __csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MethodHandle __csin$handle() {
        return __csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MemorySegment __csin$address() {
        return __csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static double __csin(double __z) {
        var mh$ = __csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctan$descriptor() {
        return ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MethodHandle ctan$handle() {
        return ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MemorySegment ctan$address() {
        return ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static double ctan(double __z) {
        var mh$ = ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctan$descriptor() {
        return __ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MethodHandle __ctan$handle() {
        return __ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MemorySegment __ctan$address() {
        return __ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static double __ctan(double __z) {
        var mh$ = __ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacosh$descriptor() {
        return cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle cacosh$handle() {
        return cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment cacosh$address() {
        return cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static double cacosh(double __z) {
        var mh$ = cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacosh$descriptor() {
        return __cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle __cacosh$handle() {
        return __cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment __cacosh$address() {
        return __cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static double __cacosh(double __z) {
        var mh$ = __cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casinh$descriptor() {
        return casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MethodHandle casinh$handle() {
        return casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MemorySegment casinh$address() {
        return casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static double casinh(double __z) {
        var mh$ = casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casinh$descriptor() {
        return __casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MethodHandle __casinh$handle() {
        return __casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MemorySegment __casinh$address() {
        return __casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static double __casinh(double __z) {
        var mh$ = __casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catanh$descriptor() {
        return catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MethodHandle catanh$handle() {
        return catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MemorySegment catanh$address() {
        return catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static double catanh(double __z) {
        var mh$ = catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catanh$descriptor() {
        return __catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MethodHandle __catanh$handle() {
        return __catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MemorySegment __catanh$address() {
        return __catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static double __catanh(double __z) {
        var mh$ = __catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccosh$descriptor() {
        return ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle ccosh$handle() {
        return ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment ccosh$address() {
        return ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static double ccosh(double __z) {
        var mh$ = ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccosh$descriptor() {
        return __ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle __ccosh$handle() {
        return __ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment __ccosh$address() {
        return __ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static double __ccosh(double __z) {
        var mh$ = __ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csinh$descriptor() {
        return csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MethodHandle csinh$handle() {
        return csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MemorySegment csinh$address() {
        return csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static double csinh(double __z) {
        var mh$ = csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csinh$descriptor() {
        return __csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MethodHandle __csinh$handle() {
        return __csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MemorySegment __csinh$address() {
        return __csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static double __csinh(double __z) {
        var mh$ = __csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctanh$descriptor() {
        return ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle ctanh$handle() {
        return ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment ctanh$address() {
        return ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static double ctanh(double __z) {
        var mh$ = ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctanh$descriptor() {
        return __ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle __ctanh$handle() {
        return __ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment __ctanh$address() {
        return __ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static double __ctanh(double __z) {
        var mh$ = __ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cexp$descriptor() {
        return cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MethodHandle cexp$handle() {
        return cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MemorySegment cexp$address() {
        return cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static double cexp(double __z) {
        var mh$ = cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cexp$descriptor() {
        return __cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MethodHandle __cexp$handle() {
        return __cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MemorySegment __cexp$address() {
        return __cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static double __cexp(double __z) {
        var mh$ = __cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor clog$descriptor() {
        return clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MethodHandle clog$handle() {
        return clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MemorySegment clog$address() {
        return clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static double clog(double __z) {
        var mh$ = clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __clog$descriptor() {
        return __clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MethodHandle __clog$handle() {
        return __clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MemorySegment __clog$address() {
        return __clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static double __clog(double __z) {
        var mh$ = __clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor cpow$descriptor() {
        return cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle cpow$handle() {
        return cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment cpow$address() {
        return cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double cpow(double __x, double __y) {
        var mh$ = cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor __cpow$descriptor() {
        return __cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle __cpow$handle() {
        return __cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment __cpow$address() {
        return __cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double __cpow(double __x, double __y) {
        var mh$ = __cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csqrt$descriptor() {
        return csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle csqrt$handle() {
        return csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment csqrt$address() {
        return csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static double csqrt(double __z) {
        var mh$ = csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csqrt$descriptor() {
        return __csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle __csqrt$handle() {
        return __csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment __csqrt$address() {
        return __csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static double __csqrt(double __z) {
        var mh$ = __csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cabs$descriptor() {
        return cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MethodHandle cabs$handle() {
        return cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MemorySegment cabs$address() {
        return cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static double cabs(double __z) {
        var mh$ = cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cabs$descriptor() {
        return __cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MethodHandle __cabs$handle() {
        return __cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MemorySegment __cabs$address() {
        return __cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static double __cabs(double __z) {
        var mh$ = __cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor carg$descriptor() {
        return carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MethodHandle carg$handle() {
        return carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MemorySegment carg$address() {
        return carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static double carg(double __z) {
        var mh$ = carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __carg$descriptor() {
        return __carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MethodHandle __carg$handle() {
        return __carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MemorySegment __carg$address() {
        return __carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static double __carg(double __z) {
        var mh$ = __carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor conj$descriptor() {
        return conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MethodHandle conj$handle() {
        return conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MemorySegment conj$address() {
        return conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static double conj(double __z) {
        var mh$ = conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __conj$descriptor() {
        return __conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MethodHandle __conj$handle() {
        return __conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MemorySegment __conj$address() {
        return __conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static double __conj(double __z) {
        var mh$ = __conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cproj$descriptor() {
        return cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MethodHandle cproj$handle() {
        return cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MemorySegment cproj$address() {
        return cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static double cproj(double __z) {
        var mh$ = cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cproj$descriptor() {
        return __cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MethodHandle __cproj$handle() {
        return __cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MemorySegment __cproj$address() {
        return __cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static double __cproj(double __z) {
        var mh$ = __cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cimag$descriptor() {
        return cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MethodHandle cimag$handle() {
        return cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MemorySegment cimag$address() {
        return cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static double cimag(double __z) {
        var mh$ = cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cimag$descriptor() {
        return __cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MethodHandle __cimag$handle() {
        return __cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MemorySegment __cimag$address() {
        return __cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static double __cimag(double __z) {
        var mh$ = __cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor creal$descriptor() {
        return creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MethodHandle creal$handle() {
        return creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MemorySegment creal$address() {
        return creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static double creal(double __z) {
        var mh$ = creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __creal$descriptor() {
        return __creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MethodHandle __creal$handle() {
        return __creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MemorySegment __creal$address() {
        return __creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static double __creal(double __z) {
        var mh$ = __creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacosf$descriptor() {
        return cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle cacosf$handle() {
        return cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment cacosf$address() {
        return cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static float cacosf(float __z) {
        var mh$ = cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacosf$descriptor() {
        return __cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacosf$handle() {
        return __cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacosf$address() {
        return __cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static float __cacosf(float __z) {
        var mh$ = __cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinf$descriptor() {
        return casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MethodHandle casinf$handle() {
        return casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MemorySegment casinf$address() {
        return casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static float casinf(float __z) {
        var mh$ = casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinf$descriptor() {
        return __casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinf$handle() {
        return __casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinf$address() {
        return __casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static float __casinf(float __z) {
        var mh$ = __casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanf$descriptor() {
        return catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MethodHandle catanf$handle() {
        return catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MemorySegment catanf$address() {
        return catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static float catanf(float __z) {
        var mh$ = catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanf$descriptor() {
        return __catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanf$handle() {
        return __catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanf$address() {
        return __catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static float __catanf(float __z) {
        var mh$ = __catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccosf$descriptor() {
        return ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle ccosf$handle() {
        return ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment ccosf$address() {
        return ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static float ccosf(float __z) {
        var mh$ = ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccosf$descriptor() {
        return __ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccosf$handle() {
        return __ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccosf$address() {
        return __ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static float __ccosf(float __z) {
        var mh$ = __ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinf$descriptor() {
        return csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MethodHandle csinf$handle() {
        return csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MemorySegment csinf$address() {
        return csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static float csinf(float __z) {
        var mh$ = csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinf$descriptor() {
        return __csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinf$handle() {
        return __csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinf$address() {
        return __csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static float __csinf(float __z) {
        var mh$ = __csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanf$descriptor() {
        return ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanf$handle() {
        return ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanf$address() {
        return ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static float ctanf(float __z) {
        var mh$ = ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanf$descriptor() {
        return __ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanf$handle() {
        return __ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanf$address() {
        return __ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static float __ctanf(float __z) {
        var mh$ = __ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacoshf$descriptor() {
        return cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle cacoshf$handle() {
        return cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment cacoshf$address() {
        return cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static float cacoshf(float __z) {
        var mh$ = cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacoshf$descriptor() {
        return __cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacoshf$handle() {
        return __cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacoshf$address() {
        return __cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static float __cacoshf(float __z) {
        var mh$ = __cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinhf$descriptor() {
        return casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle casinhf$handle() {
        return casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment casinhf$address() {
        return casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static float casinhf(float __z) {
        var mh$ = casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinhf$descriptor() {
        return __casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinhf$handle() {
        return __casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinhf$address() {
        return __casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static float __casinhf(float __z) {
        var mh$ = __casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanhf$descriptor() {
        return catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle catanhf$handle() {
        return catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment catanhf$address() {
        return catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static float catanhf(float __z) {
        var mh$ = catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanhf$descriptor() {
        return __catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanhf$handle() {
        return __catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanhf$address() {
        return __catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static float __catanhf(float __z) {
        var mh$ = __catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccoshf$descriptor() {
        return ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle ccoshf$handle() {
        return ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment ccoshf$address() {
        return ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static float ccoshf(float __z) {
        var mh$ = ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccoshf$descriptor() {
        return __ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccoshf$handle() {
        return __ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccoshf$address() {
        return __ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static float __ccoshf(float __z) {
        var mh$ = __ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinhf$descriptor() {
        return csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle csinhf$handle() {
        return csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment csinhf$address() {
        return csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static float csinhf(float __z) {
        var mh$ = csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinhf$descriptor() {
        return __csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinhf$handle() {
        return __csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinhf$address() {
        return __csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static float __csinhf(float __z) {
        var mh$ = __csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanhf$descriptor() {
        return ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanhf$handle() {
        return ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanhf$address() {
        return ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static float ctanhf(float __z) {
        var mh$ = ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanhf$descriptor() {
        return __ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanhf$handle() {
        return __ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanhf$address() {
        return __ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static float __ctanhf(float __z) {
        var mh$ = __ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cexpf$descriptor() {
        return cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle cexpf$handle() {
        return cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment cexpf$address() {
        return cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static float cexpf(float __z) {
        var mh$ = cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cexpf$descriptor() {
        return __cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle __cexpf$handle() {
        return __cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment __cexpf$address() {
        return __cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static float __cexpf(float __z) {
        var mh$ = __cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor clogf$descriptor() {
        return clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MethodHandle clogf$handle() {
        return clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MemorySegment clogf$address() {
        return clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static float clogf(float __z) {
        var mh$ = clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __clogf$descriptor() {
        return __clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MethodHandle __clogf$handle() {
        return __clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MemorySegment __clogf$address() {
        return __clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static float __clogf(float __z) {
        var mh$ = __clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor cpowf$descriptor() {
        return cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle cpowf$handle() {
        return cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment cpowf$address() {
        return cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float cpowf(float __x, float __y) {
        var mh$ = cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor __cpowf$descriptor() {
        return __cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle __cpowf$handle() {
        return __cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment __cpowf$address() {
        return __cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float __cpowf(float __x, float __y) {
        var mh$ = __cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csqrtf$descriptor() {
        return csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle csqrtf$handle() {
        return csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment csqrtf$address() {
        return csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static float csqrtf(float __z) {
        var mh$ = csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csqrtf$descriptor() {
        return __csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle __csqrtf$handle() {
        return __csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment __csqrtf$address() {
        return __csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static float __csqrtf(float __z) {
        var mh$ = __csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cabsf$descriptor() {
        return cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle cabsf$handle() {
        return cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment cabsf$address() {
        return cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static float cabsf(float __z) {
        var mh$ = cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cabsf$descriptor() {
        return __cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle __cabsf$handle() {
        return __cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment __cabsf$address() {
        return __cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static float __cabsf(float __z) {
        var mh$ = __cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cargf$descriptor() {
        return cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MethodHandle cargf$handle() {
        return cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MemorySegment cargf$address() {
        return cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static float cargf(float __z) {
        var mh$ = cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cargf$descriptor() {
        return __cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MethodHandle __cargf$handle() {
        return __cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MemorySegment __cargf$address() {
        return __cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static float __cargf(float __z) {
        var mh$ = __cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor conjf$descriptor() {
        return conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MethodHandle conjf$handle() {
        return conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MemorySegment conjf$address() {
        return conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static float conjf(float __z) {
        var mh$ = conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __conjf$descriptor() {
        return __conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MethodHandle __conjf$handle() {
        return __conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MemorySegment __conjf$address() {
        return __conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static float __conjf(float __z) {
        var mh$ = __conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cprojf$descriptor() {
        return cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle cprojf$handle() {
        return cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment cprojf$address() {
        return cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static float cprojf(float __z) {
        var mh$ = cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cprojf$descriptor() {
        return __cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle __cprojf$handle() {
        return __cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment __cprojf$address() {
        return __cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static float __cprojf(float __z) {
        var mh$ = __cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cimagf$descriptor() {
        return cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle cimagf$handle() {
        return cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment cimagf$address() {
        return cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static float cimagf(float __z) {
        var mh$ = cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cimagf$descriptor() {
        return __cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle __cimagf$handle() {
        return __cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment __cimagf$address() {
        return __cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static float __cimagf(float __z) {
        var mh$ = __cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor crealf$descriptor() {
        return crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MethodHandle crealf$handle() {
        return crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MemorySegment crealf$address() {
        return crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static float crealf(float __z) {
        var mh$ = crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __crealf$descriptor() {
        return __crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MethodHandle __crealf$handle() {
        return __crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MemorySegment __crealf$address() {
        return __crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static float __crealf(float __z) {
        var mh$ = __crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = cblas_openblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = cblas_openblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = cblas_openblas_h.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor openblas_set_num_threads$descriptor() {
        return openblas_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle openblas_set_num_threads$handle() {
        return openblas_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment openblas_set_num_threads$address() {
        return openblas_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static void openblas_set_num_threads(int num_threads) {
        var mh$ = openblas_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class goto_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("goto_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor goto_set_num_threads$descriptor() {
        return goto_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle goto_set_num_threads$handle() {
        return goto_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment goto_set_num_threads$address() {
        return goto_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static void goto_set_num_threads(int num_threads) {
        var mh$ = goto_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("goto_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static FunctionDescriptor openblas_get_num_threads$descriptor() {
        return openblas_get_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MethodHandle openblas_get_num_threads$handle() {
        return openblas_get_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MemorySegment openblas_get_num_threads$address() {
        return openblas_get_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static int openblas_get_num_threads() {
        var mh$ = openblas_get_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_threads");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_procs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_num_procs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static FunctionDescriptor openblas_get_num_procs$descriptor() {
        return openblas_get_num_procs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MethodHandle openblas_get_num_procs$handle() {
        return openblas_get_num_procs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MemorySegment openblas_get_num_procs$address() {
        return openblas_get_num_procs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static int openblas_get_num_procs() {
        var mh$ = openblas_get_num_procs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_procs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static FunctionDescriptor openblas_get_config$descriptor() {
        return openblas_get_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MethodHandle openblas_get_config$handle() {
        return openblas_get_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config$address() {
        return openblas_get_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config() {
        var mh$ = openblas_get_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_config");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_corename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_corename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static FunctionDescriptor openblas_get_corename$descriptor() {
        return openblas_get_corename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MethodHandle openblas_get_corename$handle() {
        return openblas_get_corename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename$address() {
        return openblas_get_corename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename() {
        var mh$ = openblas_get_corename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_corename");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_setaffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_setaffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static FunctionDescriptor openblas_setaffinity$descriptor() {
        return openblas_setaffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MethodHandle openblas_setaffinity$handle() {
        return openblas_setaffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MemorySegment openblas_setaffinity$address() {
        return openblas_setaffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static int openblas_setaffinity(int thread_idx, long cpusetsize, MemorySegment cpu_set) {
        var mh$ = openblas_setaffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_setaffinity", thread_idx, cpusetsize, cpu_set);
            }
            return (int)mh$.invokeExact(thread_idx, cpusetsize, cpu_set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_parallel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_get_parallel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static FunctionDescriptor openblas_get_parallel$descriptor() {
        return openblas_get_parallel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MethodHandle openblas_get_parallel$handle() {
        return openblas_get_parallel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MemorySegment openblas_get_parallel$address() {
        return openblas_get_parallel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static int openblas_get_parallel() {
        var mh$ = openblas_get_parallel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_parallel");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CblasRowMajor = (int)101L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasRowMajor = 101
     * }
     */
    public static int CblasRowMajor() {
        return CblasRowMajor;
    }
    private static final int CblasColMajor = (int)102L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasColMajor = 102
     * }
     */
    public static int CblasColMajor() {
        return CblasColMajor;
    }
    private static final int CblasNoTrans = (int)111L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasNoTrans = 111
     * }
     */
    public static int CblasNoTrans() {
        return CblasNoTrans;
    }
    private static final int CblasTrans = (int)112L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasTrans = 112
     * }
     */
    public static int CblasTrans() {
        return CblasTrans;
    }
    private static final int CblasConjTrans = (int)113L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjTrans = 113
     * }
     */
    public static int CblasConjTrans() {
        return CblasConjTrans;
    }
    private static final int CblasConjNoTrans = (int)114L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjNoTrans = 114
     * }
     */
    public static int CblasConjNoTrans() {
        return CblasConjNoTrans;
    }
    private static final int CblasUpper = (int)121L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasUpper = 121
     * }
     */
    public static int CblasUpper() {
        return CblasUpper;
    }
    private static final int CblasLower = (int)122L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasLower = 122
     * }
     */
    public static int CblasLower() {
        return CblasLower;
    }
    private static final int CblasNonUnit = (int)131L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasNonUnit = 131
     * }
     */
    public static int CblasNonUnit() {
        return CblasNonUnit;
    }
    private static final int CblasUnit = (int)132L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasUnit = 132
     * }
     */
    public static int CblasUnit() {
        return CblasUnit;
    }
    private static final int CblasLeft = (int)141L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasLeft = 141
     * }
     */
    public static int CblasLeft() {
        return CblasLeft;
    }
    private static final int CblasRight = (int)142L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasRight = 142
     * }
     */
    public static int CblasRight() {
        return CblasRight;
    }

    private static class cblas_sdsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sdsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdsdot$descriptor() {
        return cblas_sdsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdsdot$handle() {
        return cblas_sdsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdsdot$address() {
        return cblas_sdsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdsdot(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdsdot", n, alpha, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dsdot$descriptor() {
        return cblas_dsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dsdot$handle() {
        return cblas_dsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dsdot$address() {
        return cblas_dsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static double cblas_dsdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsdot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdot$descriptor() {
        return cblas_sdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdot$handle() {
        return cblas_sdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdot$address() {
        return cblas_sdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ddot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ddot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ddot$descriptor() {
        return cblas_ddot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ddot$handle() {
        return cblas_ddot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ddot$address() {
        return cblas_ddot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static double cblas_ddot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ddot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ddot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotu$descriptor() {
        return cblas_cdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotu$handle() {
        return cblas_cdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotu$address() {
        return cblas_cdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotc$descriptor() {
        return cblas_cdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotc$handle() {
        return cblas_cdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotc$address() {
        return cblas_cdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotu$descriptor() {
        return cblas_zdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotu$handle() {
        return cblas_zdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotu$address() {
        return cblas_zdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotc$descriptor() {
        return cblas_zdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotc$handle() {
        return cblas_zdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotc$address() {
        return cblas_zdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotu_sub$descriptor() {
        return cblas_cdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotu_sub$handle() {
        return cblas_cdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotu_sub$address() {
        return cblas_cdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotc_sub$descriptor() {
        return cblas_cdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotc_sub$handle() {
        return cblas_cdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotc_sub$address() {
        return cblas_cdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotu_sub$descriptor() {
        return cblas_zdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotu_sub$handle() {
        return cblas_zdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotu_sub$address() {
        return cblas_zdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotc_sub$descriptor() {
        return cblas_zdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotc_sub$handle() {
        return cblas_zdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotc_sub$address() {
        return cblas_zdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_sasum$descriptor() {
        return cblas_sasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_sasum$handle() {
        return cblas_sasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_sasum$address() {
        return cblas_sasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_sasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_sasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dasum$descriptor() {
        return cblas_dasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dasum$handle() {
        return cblas_dasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dasum$address() {
        return cblas_dasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scasum$descriptor() {
        return cblas_scasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scasum$handle() {
        return cblas_scasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scasum$address() {
        return cblas_scasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dzasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzasum$descriptor() {
        return cblas_dzasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzasum$handle() {
        return cblas_dzasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzasum$address() {
        return cblas_dzasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ssum$descriptor() {
        return cblas_ssum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ssum$handle() {
        return cblas_ssum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ssum$address() {
        return cblas_ssum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_ssum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ssum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dsum$descriptor() {
        return cblas_dsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dsum$handle() {
        return cblas_dsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dsum$address() {
        return cblas_dsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scsum$descriptor() {
        return cblas_scsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scsum$handle() {
        return cblas_scsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scsum$address() {
        return cblas_scsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scsum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dzsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzsum$descriptor() {
        return cblas_dzsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzsum$handle() {
        return cblas_dzsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzsum$address() {
        return cblas_dzsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_snrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_snrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_snrm2$descriptor() {
        return cblas_snrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_snrm2$handle() {
        return cblas_snrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_snrm2$address() {
        return cblas_snrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static float cblas_snrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_snrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_snrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dnrm2$descriptor() {
        return cblas_dnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dnrm2$handle() {
        return cblas_dnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dnrm2$address() {
        return cblas_dnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static double cblas_dnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dnrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_scnrm2$descriptor() {
        return cblas_scnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_scnrm2$handle() {
        return cblas_scnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_scnrm2$address() {
        return cblas_scnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static float cblas_scnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_scnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scnrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dznrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dznrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dznrm2$descriptor() {
        return cblas_dznrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dznrm2$handle() {
        return cblas_dznrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dznrm2$address() {
        return cblas_dznrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static double cblas_dznrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dznrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dznrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_isamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamax$descriptor() {
        return cblas_isamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamax$handle() {
        return cblas_isamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamax$address() {
        return cblas_isamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamax$descriptor() {
        return cblas_idamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamax$handle() {
        return cblas_idamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamax$address() {
        return cblas_idamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamax$descriptor() {
        return cblas_icamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamax$handle() {
        return cblas_icamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamax$address() {
        return cblas_icamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamax$descriptor() {
        return cblas_izamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamax$handle() {
        return cblas_izamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamax$address() {
        return cblas_izamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_isamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamin$descriptor() {
        return cblas_isamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamin$handle() {
        return cblas_isamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamin$address() {
        return cblas_isamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamin$descriptor() {
        return cblas_idamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamin$handle() {
        return cblas_idamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamin$address() {
        return cblas_idamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamin$descriptor() {
        return cblas_icamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamin$handle() {
        return cblas_icamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamin$address() {
        return cblas_icamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamin$descriptor() {
        return cblas_izamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamin$handle() {
        return cblas_izamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamin$address() {
        return cblas_izamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ismax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismax$descriptor() {
        return cblas_ismax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismax$handle() {
        return cblas_ismax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismax$address() {
        return cblas_ismax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmax$descriptor() {
        return cblas_idmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmax$handle() {
        return cblas_idmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmax$address() {
        return cblas_idmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmax$descriptor() {
        return cblas_icmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmax$handle() {
        return cblas_icmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmax$address() {
        return cblas_icmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmax$descriptor() {
        return cblas_izmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmax$handle() {
        return cblas_izmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmax$address() {
        return cblas_izmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ismin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismin$descriptor() {
        return cblas_ismin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismin$handle() {
        return cblas_ismin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismin$address() {
        return cblas_ismin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_idmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmin$descriptor() {
        return cblas_idmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmin$handle() {
        return cblas_idmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmin$address() {
        return cblas_idmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_icmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmin$descriptor() {
        return cblas_icmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmin$handle() {
        return cblas_icmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmin$address() {
        return cblas_icmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_izmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmin$descriptor() {
        return cblas_izmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmin$handle() {
        return cblas_izmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmin$address() {
        return cblas_izmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_saxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_saxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpy$descriptor() {
        return cblas_saxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpy$handle() {
        return cblas_saxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpy$address() {
        return cblas_saxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpy(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_saxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_daxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpy$descriptor() {
        return cblas_daxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpy$handle() {
        return cblas_daxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpy$address() {
        return cblas_daxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpy(int n, double alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_daxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_caxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpy$descriptor() {
        return cblas_caxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpy$handle() {
        return cblas_caxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpy$address() {
        return cblas_caxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_caxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zaxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpy$descriptor() {
        return cblas_zaxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpy$handle() {
        return cblas_zaxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpy$address() {
        return cblas_zaxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_scopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_scopy$descriptor() {
        return cblas_scopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_scopy$handle() {
        return cblas_scopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_scopy$address() {
        return cblas_scopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_scopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_scopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dcopy$descriptor() {
        return cblas_dcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dcopy$handle() {
        return cblas_dcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dcopy$address() {
        return cblas_dcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ccopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ccopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ccopy$descriptor() {
        return cblas_ccopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ccopy$handle() {
        return cblas_ccopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ccopy$address() {
        return cblas_ccopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_ccopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ccopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ccopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zcopy$descriptor() {
        return cblas_zcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zcopy$handle() {
        return cblas_zcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zcopy$address() {
        return cblas_zcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sswap$descriptor() {
        return cblas_sswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sswap$handle() {
        return cblas_sswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sswap$address() {
        return cblas_sswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_sswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dswap$descriptor() {
        return cblas_dswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dswap$handle() {
        return cblas_dswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dswap$address() {
        return cblas_dswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cswap$descriptor() {
        return cblas_cswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cswap$handle() {
        return cblas_cswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cswap$address() {
        return cblas_cswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_cswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zswap$descriptor() {
        return cblas_zswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zswap$handle() {
        return cblas_zswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zswap$address() {
        return cblas_zswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_srot$descriptor() {
        return cblas_srot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_srot$handle() {
        return cblas_srot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_srot$address() {
        return cblas_srot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_srot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, float c, float s) {
        var mh$ = cblas_srot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_drot$descriptor() {
        return cblas_drot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_drot$handle() {
        return cblas_drot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_drot$address() {
        return cblas_drot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_drot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, double c, double s) {
        var mh$ = cblas_drot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_csrot$descriptor() {
        return cblas_csrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_csrot$handle() {
        return cblas_csrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_csrot$address() {
        return cblas_csrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_csrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, float c, float s) {
        var mh$ = cblas_csrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_zdrot$descriptor() {
        return cblas_zdrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_zdrot$handle() {
        return cblas_zdrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_zdrot$address() {
        return cblas_zdrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_zdrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, double c, double s) {
        var mh$ = cblas_zdrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static FunctionDescriptor cblas_srotg$descriptor() {
        return cblas_srotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MethodHandle cblas_srotg$handle() {
        return cblas_srotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MemorySegment cblas_srotg$address() {
        return cblas_srotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static void cblas_srotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_srotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static FunctionDescriptor cblas_drotg$descriptor() {
        return cblas_drotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MethodHandle cblas_drotg$handle() {
        return cblas_drotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MemorySegment cblas_drotg$address() {
        return cblas_drotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static void cblas_drotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_drotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_crotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_crotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_crotg$descriptor() {
        return cblas_crotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MethodHandle cblas_crotg$handle() {
        return cblas_crotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MemorySegment cblas_crotg$address() {
        return cblas_crotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static void cblas_crotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_crotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_crotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zrotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zrotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_zrotg$descriptor() {
        return cblas_zrotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MethodHandle cblas_zrotg$handle() {
        return cblas_zrotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MemorySegment cblas_zrotg$address() {
        return cblas_zrotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static void cblas_zrotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_zrotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zrotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotm$descriptor() {
        return cblas_srotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MethodHandle cblas_srotm$handle() {
        return cblas_srotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MemorySegment cblas_srotm$address() {
        return cblas_srotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static void cblas_srotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_srotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotm$descriptor() {
        return cblas_drotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MethodHandle cblas_drotm$handle() {
        return cblas_drotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MemorySegment cblas_drotm$address() {
        return cblas_drotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static void cblas_drotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_drotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_srotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotmg$descriptor() {
        return cblas_srotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MethodHandle cblas_srotmg$handle() {
        return cblas_srotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MemorySegment cblas_srotmg$address() {
        return cblas_srotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static void cblas_srotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, float b2, MemorySegment P) {
        var mh$ = cblas_srotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_drotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotmg$descriptor() {
        return cblas_drotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MethodHandle cblas_drotmg$handle() {
        return cblas_drotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MemorySegment cblas_drotmg$address() {
        return cblas_drotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static void cblas_drotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, double b2, MemorySegment P) {
        var mh$ = cblas_drotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_sscal$descriptor() {
        return cblas_sscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_sscal$handle() {
        return cblas_sscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_sscal$address() {
        return cblas_sscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static void cblas_sscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_sscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dscal$descriptor() {
        return cblas_dscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dscal$handle() {
        return cblas_dscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dscal$address() {
        return cblas_dscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static void cblas_dscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_dscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_cscal$descriptor() {
        return cblas_cscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_cscal$handle() {
        return cblas_cscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_cscal$address() {
        return cblas_cscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_cscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_cscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zscal$descriptor() {
        return cblas_zscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zscal$handle() {
        return cblas_zscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zscal$address() {
        return cblas_zscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_csscal$descriptor() {
        return cblas_csscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_csscal$handle() {
        return cblas_csscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_csscal$address() {
        return cblas_csscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_csscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_csscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zdscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zdscal$descriptor() {
        return cblas_zdscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zdscal$handle() {
        return cblas_zdscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zdscal$address() {
        return cblas_zdscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zdscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zdscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sgemv$descriptor() {
        return cblas_sgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sgemv$handle() {
        return cblas_sgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sgemv$address() {
        return cblas_sgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dgemv$descriptor() {
        return cblas_dgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dgemv$handle() {
        return cblas_dgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dgemv$address() {
        return cblas_dgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_dgemv(int order, int trans, int m, int n, double alpha, MemorySegment a, int lda, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_dgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cgemv$descriptor() {
        return cblas_cgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cgemv$handle() {
        return cblas_cgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cgemv$address() {
        return cblas_cgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_cgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_cgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zgemv$descriptor() {
        return cblas_zgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zgemv$handle() {
        return cblas_zgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zgemv$address() {
        return cblas_zgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_sger$descriptor() {
        return cblas_sger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_sger$handle() {
        return cblas_sger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_sger$address() {
        return cblas_sger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_sger(int order, int M, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_sger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dger$descriptor() {
        return cblas_dger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dger$handle() {
        return cblas_dger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dger$address() {
        return cblas_dger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dger(int order, int M, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgeru$descriptor() {
        return cblas_cgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgeru$handle() {
        return cblas_cgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgeru$address() {
        return cblas_cgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgerc$descriptor() {
        return cblas_cgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgerc$handle() {
        return cblas_cgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgerc$address() {
        return cblas_cgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgeru$descriptor() {
        return cblas_zgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgeru$handle() {
        return cblas_zgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgeru$address() {
        return cblas_zgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgerc$descriptor() {
        return cblas_zgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgerc$handle() {
        return cblas_zgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgerc$address() {
        return cblas_zgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strsv$descriptor() {
        return cblas_strsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strsv$handle() {
        return cblas_strsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strsv$address() {
        return cblas_strsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrsv$descriptor() {
        return cblas_dtrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrsv$handle() {
        return cblas_dtrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrsv$address() {
        return cblas_dtrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrsv$descriptor() {
        return cblas_ctrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrsv$handle() {
        return cblas_ctrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrsv$address() {
        return cblas_ctrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrsv$descriptor() {
        return cblas_ztrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrsv$handle() {
        return cblas_ztrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrsv$address() {
        return cblas_ztrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strmv$descriptor() {
        return cblas_strmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strmv$handle() {
        return cblas_strmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strmv$address() {
        return cblas_strmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrmv$descriptor() {
        return cblas_dtrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrmv$handle() {
        return cblas_dtrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrmv$address() {
        return cblas_dtrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrmv$descriptor() {
        return cblas_ctrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrmv$handle() {
        return cblas_ctrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrmv$address() {
        return cblas_ctrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrmv$descriptor() {
        return cblas_ztrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrmv$handle() {
        return cblas_ztrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrmv$address() {
        return cblas_ztrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr$descriptor() {
        return cblas_ssyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr$handle() {
        return cblas_ssyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr$address() {
        return cblas_ssyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr$descriptor() {
        return cblas_dsyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr$handle() {
        return cblas_dsyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr$address() {
        return cblas_dsyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher$descriptor() {
        return cblas_cher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher$handle() {
        return cblas_cher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher$address() {
        return cblas_cher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_cher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher$descriptor() {
        return cblas_zher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher$handle() {
        return cblas_zher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher$address() {
        return cblas_zher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_zher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2$descriptor() {
        return cblas_ssyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr2$handle() {
        return cblas_ssyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr2$address() {
        return cblas_ssyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2$descriptor() {
        return cblas_dsyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr2$handle() {
        return cblas_dsyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr2$address() {
        return cblas_dsyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher2$descriptor() {
        return cblas_cher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher2$handle() {
        return cblas_cher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher2$address() {
        return cblas_cher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher2$descriptor() {
        return cblas_zher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher2$handle() {
        return cblas_zher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher2$address() {
        return cblas_zher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sgbmv$descriptor() {
        return cblas_sgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sgbmv$handle() {
        return cblas_sgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sgbmv$address() {
        return cblas_sgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sgbmv(int order, int TransA, int M, int N, int KL, int KU, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dgbmv$descriptor() {
        return cblas_dgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dgbmv$handle() {
        return cblas_dgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dgbmv$address() {
        return cblas_dgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dgbmv(int order, int TransA, int M, int N, int KL, int KU, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_cgbmv$descriptor() {
        return cblas_cgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_cgbmv$handle() {
        return cblas_cgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_cgbmv$address() {
        return cblas_cgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_cgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_cgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zgbmv$descriptor() {
        return cblas_zgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zgbmv$handle() {
        return cblas_zgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zgbmv$address() {
        return cblas_zgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssbmv$descriptor() {
        return cblas_ssbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssbmv$handle() {
        return cblas_ssbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssbmv$address() {
        return cblas_ssbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssbmv(int order, int Uplo, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsbmv$descriptor() {
        return cblas_dsbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsbmv$handle() {
        return cblas_dsbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsbmv$address() {
        return cblas_dsbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsbmv(int order, int Uplo, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbmv$descriptor() {
        return cblas_stbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbmv$handle() {
        return cblas_stbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbmv$address() {
        return cblas_stbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbmv$descriptor() {
        return cblas_dtbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbmv$handle() {
        return cblas_dtbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbmv$address() {
        return cblas_dtbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbmv$descriptor() {
        return cblas_ctbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbmv$handle() {
        return cblas_ctbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbmv$address() {
        return cblas_ctbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbmv$descriptor() {
        return cblas_ztbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbmv$handle() {
        return cblas_ztbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbmv$address() {
        return cblas_ztbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbsv$descriptor() {
        return cblas_stbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbsv$handle() {
        return cblas_stbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbsv$address() {
        return cblas_stbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbsv$descriptor() {
        return cblas_dtbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbsv$handle() {
        return cblas_dtbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbsv$address() {
        return cblas_dtbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbsv$descriptor() {
        return cblas_ctbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbsv$handle() {
        return cblas_ctbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbsv$address() {
        return cblas_ctbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbsv$descriptor() {
        return cblas_ztbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbsv$handle() {
        return cblas_ztbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbsv$address() {
        return cblas_ztbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpmv$descriptor() {
        return cblas_stpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpmv$handle() {
        return cblas_stpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpmv$address() {
        return cblas_stpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpmv$descriptor() {
        return cblas_dtpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpmv$handle() {
        return cblas_dtpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpmv$address() {
        return cblas_dtpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpmv$descriptor() {
        return cblas_ctpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpmv$handle() {
        return cblas_ctpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpmv$address() {
        return cblas_ctpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpmv$descriptor() {
        return cblas_ztpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpmv$handle() {
        return cblas_ztpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpmv$address() {
        return cblas_ztpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_stpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpsv$descriptor() {
        return cblas_stpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpsv$handle() {
        return cblas_stpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpsv$address() {
        return cblas_stpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpsv$descriptor() {
        return cblas_dtpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpsv$handle() {
        return cblas_dtpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpsv$address() {
        return cblas_dtpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpsv$descriptor() {
        return cblas_ctpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpsv$handle() {
        return cblas_ctpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpsv$address() {
        return cblas_ctpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpsv$descriptor() {
        return cblas_ztpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpsv$handle() {
        return cblas_ztpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpsv$address() {
        return cblas_ztpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssymv$descriptor() {
        return cblas_ssymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssymv$handle() {
        return cblas_ssymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssymv$address() {
        return cblas_ssymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssymv(int order, int Uplo, int N, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsymv$descriptor() {
        return cblas_dsymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsymv$handle() {
        return cblas_dsymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsymv$address() {
        return cblas_dsymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsymv(int order, int Uplo, int N, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chemv$descriptor() {
        return cblas_chemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chemv$handle() {
        return cblas_chemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chemv$address() {
        return cblas_chemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhemv$descriptor() {
        return cblas_zhemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhemv$handle() {
        return cblas_zhemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhemv$address() {
        return cblas_zhemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sspmv$descriptor() {
        return cblas_sspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sspmv$handle() {
        return cblas_sspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sspmv$address() {
        return cblas_sspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sspmv(int order, int Uplo, int N, float alpha, MemorySegment Ap, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dspmv$descriptor() {
        return cblas_dspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dspmv$handle() {
        return cblas_dspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dspmv$address() {
        return cblas_dspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dspmv(int order, int Uplo, int N, double alpha, MemorySegment Ap, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static FunctionDescriptor cblas_sspr$descriptor() {
        return cblas_sspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MethodHandle cblas_sspr$handle() {
        return cblas_sspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MemorySegment cblas_sspr$address() {
        return cblas_sspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static void cblas_sspr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_sspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static FunctionDescriptor cblas_dspr$descriptor() {
        return cblas_dspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MethodHandle cblas_dspr$handle() {
        return cblas_dspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MemorySegment cblas_dspr$address() {
        return cblas_dspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static void cblas_dspr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_dspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_chpr$descriptor() {
        return cblas_chpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_chpr$handle() {
        return cblas_chpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_chpr$address() {
        return cblas_chpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_chpr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_chpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_zhpr$descriptor() {
        return cblas_zhpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_zhpr$handle() {
        return cblas_zhpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_zhpr$address() {
        return cblas_zhpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_zhpr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_zhpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static FunctionDescriptor cblas_sspr2$descriptor() {
        return cblas_sspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MethodHandle cblas_sspr2$handle() {
        return cblas_sspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MemorySegment cblas_sspr2$address() {
        return cblas_sspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static void cblas_sspr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_sspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static FunctionDescriptor cblas_dspr2$descriptor() {
        return cblas_dspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MethodHandle cblas_dspr2$handle() {
        return cblas_dspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MemorySegment cblas_dspr2$address() {
        return cblas_dspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static void cblas_dspr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_dspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_chpr2$descriptor() {
        return cblas_chpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_chpr2$handle() {
        return cblas_chpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_chpr2$address() {
        return cblas_chpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_chpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_chpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_zhpr2$descriptor() {
        return cblas_zhpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_zhpr2$handle() {
        return cblas_zhpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_zhpr2$address() {
        return cblas_zhpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_zhpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_zhpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chbmv$descriptor() {
        return cblas_chbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chbmv$handle() {
        return cblas_chbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chbmv$address() {
        return cblas_chbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhbmv$descriptor() {
        return cblas_zhbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhbmv$handle() {
        return cblas_zhbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhbmv$address() {
        return cblas_zhbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chpmv$descriptor() {
        return cblas_chpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chpmv$handle() {
        return cblas_chpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chpmv$address() {
        return cblas_chpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhpmv$descriptor() {
        return cblas_zhpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhpmv$handle() {
        return cblas_zhpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhpmv$address() {
        return cblas_zhpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sgemm$descriptor() {
        return cblas_sgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sgemm$handle() {
        return cblas_sgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sgemm$address() {
        return cblas_sgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dgemm$descriptor() {
        return cblas_dgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dgemm$handle() {
        return cblas_dgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dgemm$address() {
        return cblas_dgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dgemm(int Order, int TransA, int TransB, int M, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm$descriptor() {
        return cblas_cgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm$handle() {
        return cblas_cgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm$address() {
        return cblas_cgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm3m$descriptor() {
        return cblas_cgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm3m$handle() {
        return cblas_cgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm3m$address() {
        return cblas_cgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm$descriptor() {
        return cblas_zgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm$handle() {
        return cblas_zgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm$address() {
        return cblas_zgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm3m$descriptor() {
        return cblas_zgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm3m$handle() {
        return cblas_zgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm3m$address() {
        return cblas_zgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssymm$descriptor() {
        return cblas_ssymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssymm$handle() {
        return cblas_ssymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssymm$address() {
        return cblas_ssymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssymm(int Order, int Side, int Uplo, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsymm$descriptor() {
        return cblas_dsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsymm$handle() {
        return cblas_dsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsymm$address() {
        return cblas_dsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsymm(int Order, int Side, int Uplo, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csymm$descriptor() {
        return cblas_csymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csymm$handle() {
        return cblas_csymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csymm$address() {
        return cblas_csymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsymm$descriptor() {
        return cblas_zsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsymm$handle() {
        return cblas_zsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsymm$address() {
        return cblas_zsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyrk$descriptor() {
        return cblas_ssyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyrk$handle() {
        return cblas_ssyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyrk$address() {
        return cblas_ssyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyrk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyrk$descriptor() {
        return cblas_dsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyrk$handle() {
        return cblas_dsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyrk$address() {
        return cblas_dsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyrk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyrk$descriptor() {
        return cblas_csyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyrk$handle() {
        return cblas_csyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyrk$address() {
        return cblas_csyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyrk$descriptor() {
        return cblas_zsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyrk$handle() {
        return cblas_zsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyrk$address() {
        return cblas_zsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ssyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2k$descriptor() {
        return cblas_ssyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyr2k$handle() {
        return cblas_ssyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyr2k$address() {
        return cblas_ssyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyr2k(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2k$descriptor() {
        return cblas_dsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyr2k$handle() {
        return cblas_dsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyr2k$address() {
        return cblas_dsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyr2k(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_csyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyr2k$descriptor() {
        return cblas_csyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyr2k$handle() {
        return cblas_csyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyr2k$address() {
        return cblas_csyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyr2k$descriptor() {
        return cblas_zsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyr2k$handle() {
        return cblas_zsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyr2k$address() {
        return cblas_zsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strmm$descriptor() {
        return cblas_strmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strmm$handle() {
        return cblas_strmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strmm$address() {
        return cblas_strmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrmm$descriptor() {
        return cblas_dtrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrmm$handle() {
        return cblas_dtrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrmm$address() {
        return cblas_dtrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrmm$descriptor() {
        return cblas_ctrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrmm$handle() {
        return cblas_ctrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrmm$address() {
        return cblas_ctrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrmm$descriptor() {
        return cblas_ztrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrmm$handle() {
        return cblas_ztrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrmm$address() {
        return cblas_ztrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_strsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strsm$descriptor() {
        return cblas_strsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strsm$handle() {
        return cblas_strsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strsm$address() {
        return cblas_strsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dtrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrsm$descriptor() {
        return cblas_dtrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrsm$handle() {
        return cblas_dtrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrsm$address() {
        return cblas_dtrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ctrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrsm$descriptor() {
        return cblas_ctrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrsm$handle() {
        return cblas_ctrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrsm$address() {
        return cblas_ctrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_ztrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrsm$descriptor() {
        return cblas_ztrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrsm$handle() {
        return cblas_ztrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrsm$address() {
        return cblas_ztrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_chemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_chemm$descriptor() {
        return cblas_chemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_chemm$handle() {
        return cblas_chemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_chemm$address() {
        return cblas_chemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_chemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_chemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zhemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zhemm$descriptor() {
        return cblas_zhemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zhemm$handle() {
        return cblas_zhemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zhemm$address() {
        return cblas_zhemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zhemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zhemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cherk$descriptor() {
        return cblas_cherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cherk$handle() {
        return cblas_cherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cherk$address() {
        return cblas_cherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cherk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zherk$descriptor() {
        return cblas_zherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zherk$handle() {
        return cblas_zherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zherk$address() {
        return cblas_zherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zherk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cher2k$descriptor() {
        return cblas_cher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cher2k$handle() {
        return cblas_cher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cher2k$address() {
        return cblas_cher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zher2k$descriptor() {
        return cblas_zher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zher2k$handle() {
        return cblas_zher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zher2k$address() {
        return cblas_zher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void cblas_xerbla(blasint p, char *rout, char *form, ...)
     * }
     */
    public static class cblas_xerbla {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                cblas_openblas_h.C_INT,
                cblas_openblas_h.C_POINTER,
                cblas_openblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_xerbla");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private cblas_xerbla(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void cblas_xerbla(blasint p, char *rout, char *form, ...)
         * }
         */
        public static cblas_xerbla makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new cblas_xerbla(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int p, MemorySegment rout, MemorySegment form, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("cblas_xerbla", p, rout, form, x3);
                }
                 spreader.invokeExact(p, rout, form, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class cblas_saxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_saxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpby$descriptor() {
        return cblas_saxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpby$handle() {
        return cblas_saxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpby$address() {
        return cblas_saxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpby(int n, float alpha, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_saxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_daxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpby$descriptor() {
        return cblas_daxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpby$handle() {
        return cblas_daxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpby$address() {
        return cblas_daxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpby(int n, double alpha, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_daxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_caxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpby$descriptor() {
        return cblas_caxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpby$handle() {
        return cblas_caxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpby$address() {
        return cblas_caxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_caxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zaxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpby$descriptor() {
        return cblas_zaxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpby$handle() {
        return cblas_zaxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpby$address() {
        return cblas_zaxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_somatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_somatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_somatcopy$descriptor() {
        return cblas_somatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_somatcopy$handle() {
        return cblas_somatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_somatcopy$address() {
        return cblas_somatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_somatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_somatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_somatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_domatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_domatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_domatcopy$descriptor() {
        return cblas_domatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_domatcopy$handle() {
        return cblas_domatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_domatcopy$address() {
        return cblas_domatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_domatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_domatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_domatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_comatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_comatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_comatcopy$descriptor() {
        return cblas_comatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_comatcopy$handle() {
        return cblas_comatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_comatcopy$address() {
        return cblas_comatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_comatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_comatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_comatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zomatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zomatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zomatcopy$descriptor() {
        return cblas_zomatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zomatcopy$handle() {
        return cblas_zomatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zomatcopy$address() {
        return cblas_zomatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_zomatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_zomatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zomatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_simatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_simatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_simatcopy$descriptor() {
        return cblas_simatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_simatcopy$handle() {
        return cblas_simatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_simatcopy$address() {
        return cblas_simatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_simatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_simatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_simatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_dimatcopy$descriptor() {
        return cblas_dimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_dimatcopy$handle() {
        return cblas_dimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_dimatcopy$address() {
        return cblas_dimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_dimatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_dimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_cimatcopy$descriptor() {
        return cblas_cimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_cimatcopy$handle() {
        return cblas_cimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_cimatcopy$address() {
        return cblas_cimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_cimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_cimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zimatcopy$descriptor() {
        return cblas_zimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zimatcopy$handle() {
        return cblas_zimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zimatcopy$address() {
        return cblas_zimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_zimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_zimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_sgeadd$descriptor() {
        return cblas_sgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_sgeadd$handle() {
        return cblas_sgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_sgeadd$address() {
        return cblas_sgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_sgeadd(int CORDER, int crows, int ccols, float calpha, MemorySegment a, int clda, float cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_sgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_dgeadd$descriptor() {
        return cblas_dgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_dgeadd$handle() {
        return cblas_dgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_dgeadd$address() {
        return cblas_dgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_dgeadd(int CORDER, int crows, int ccols, double calpha, MemorySegment a, int clda, double cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_dgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_cgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_cgeadd$descriptor() {
        return cblas_cgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_cgeadd$handle() {
        return cblas_cgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_cgeadd$address() {
        return cblas_cgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_cgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_cgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_zgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_zgeadd$descriptor() {
        return cblas_zgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_zgeadd$handle() {
        return cblas_zgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_zgeadd$address() {
        return cblas_zgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_zgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_zgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbstobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbstobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbstobf16$descriptor() {
        return cblas_sbstobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbstobf16$handle() {
        return cblas_sbstobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbstobf16$address() {
        return cblas_sbstobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbstobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbstobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbstobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdtobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbdtobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbdtobf16$descriptor() {
        return cblas_sbdtobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbdtobf16$handle() {
        return cblas_sbdtobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbdtobf16$address() {
        return cblas_sbdtobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbdtobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbdtobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdtobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbf16tos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbf16tos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbf16tos$descriptor() {
        return cblas_sbf16tos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbf16tos$handle() {
        return cblas_sbf16tos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbf16tos$address() {
        return cblas_sbf16tos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static void cblas_sbf16tos(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbf16tos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbf16tos", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dbf16tod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_dbf16tod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_dbf16tod$descriptor() {
        return cblas_dbf16tod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_dbf16tod$handle() {
        return cblas_dbf16tod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_dbf16tod$address() {
        return cblas_dbf16tod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static void cblas_dbf16tod(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_dbf16tod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dbf16tod", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbdot$descriptor() {
        return cblas_sbdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbdot$handle() {
        return cblas_sbdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbdot$address() {
        return cblas_sbdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static float cblas_sbdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sbdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbgemv$descriptor() {
        return cblas_sbgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbgemv$handle() {
        return cblas_sbgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbgemv$address() {
        return cblas_sbgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sbgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sbgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cblas_sbgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sbgemm$descriptor() {
        return cblas_sbgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sbgemm$handle() {
        return cblas_sbgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sbgemm$address() {
        return cblas_sbgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sbgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sbgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xerbla_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xerbla_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xerbla_(char *, blasint *info, blasint)
     * }
     */
    public static FunctionDescriptor xerbla_$descriptor() {
        return xerbla_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xerbla_(char *, blasint *info, blasint)
     * }
     */
    public static MethodHandle xerbla_$handle() {
        return xerbla_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xerbla_(char *, blasint *info, blasint)
     * }
     */
    public static MemorySegment xerbla_$address() {
        return xerbla_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xerbla_(char *, blasint *info, blasint)
     * }
     */
    public static int xerbla_(MemorySegment x0, MemorySegment info, int x2) {
        var mh$ = xerbla_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xerbla_", x0, info, x2);
            }
            return (int)mh$.invokeExact(x0, info, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_set_num_threads_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("openblas_set_num_threads_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void openblas_set_num_threads_(int *)
     * }
     */
    public static FunctionDescriptor openblas_set_num_threads_$descriptor() {
        return openblas_set_num_threads_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void openblas_set_num_threads_(int *)
     * }
     */
    public static MethodHandle openblas_set_num_threads_$handle() {
        return openblas_set_num_threads_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void openblas_set_num_threads_(int *)
     * }
     */
    public static MemorySegment openblas_set_num_threads_$address() {
        return openblas_set_num_threads_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void openblas_set_num_threads_(int *)
     * }
     */
    public static void openblas_set_num_threads_(MemorySegment x0) {
        var mh$ = openblas_set_num_threads_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_set_num_threads_", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sdot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sdot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sdot_$descriptor() {
        return sdot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sdot_$handle() {
        return sdot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sdot_$address() {
        return sdot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static float sdot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sdot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sdot_", x0, x1, x2, x3, x4);
            }
            return (float)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sdsdot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sdsdot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sdsdot_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sdsdot_$descriptor() {
        return sdsdot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sdsdot_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sdsdot_$handle() {
        return sdsdot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sdsdot_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sdsdot_$address() {
        return sdsdot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sdsdot_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static float sdsdot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = sdsdot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sdsdot_", x0, x1, x2, x3, x4, x5);
            }
            return (float)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsdot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsdot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dsdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor dsdot_$descriptor() {
        return dsdot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dsdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle dsdot_$handle() {
        return dsdot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dsdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment dsdot_$address() {
        return dsdot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dsdot_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static double dsdot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dsdot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsdot_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ddot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ddot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ddot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ddot_$descriptor() {
        return ddot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ddot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ddot_$handle() {
        return ddot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ddot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ddot_$address() {
        return ddot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ddot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double ddot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ddot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ddot_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qdot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qdot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qdot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qdot_$descriptor() {
        return qdot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qdot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qdot_$handle() {
        return qdot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qdot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qdot_$address() {
        return qdot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qdot_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double qdot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qdot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qdot_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbdot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sbdot_(blasint *, bfloat16 *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static FunctionDescriptor sbdot_$descriptor() {
        return sbdot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sbdot_(blasint *, bfloat16 *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MethodHandle sbdot_$handle() {
        return sbdot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sbdot_(blasint *, bfloat16 *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MemorySegment sbdot_$address() {
        return sbdot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sbdot_(blasint *, bfloat16 *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static float sbdot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sbdot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdot_", x0, x1, x2, x3, x4);
            }
            return (float)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbstobf16_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbstobf16_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbstobf16_(blasint *, float *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static FunctionDescriptor sbstobf16_$descriptor() {
        return sbstobf16_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbstobf16_(blasint *, float *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MethodHandle sbstobf16_$handle() {
        return sbstobf16_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbstobf16_(blasint *, float *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MemorySegment sbstobf16_$address() {
        return sbstobf16_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbstobf16_(blasint *, float *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static void sbstobf16_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sbstobf16_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbstobf16_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdtobf16_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbdtobf16_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdtobf16_(blasint *, double *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static FunctionDescriptor sbdtobf16_$descriptor() {
        return sbdtobf16_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdtobf16_(blasint *, double *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MethodHandle sbdtobf16_$handle() {
        return sbdtobf16_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdtobf16_(blasint *, double *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static MemorySegment sbdtobf16_$address() {
        return sbdtobf16_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdtobf16_(blasint *, double *, blasint *, bfloat16 *, blasint *)
     * }
     */
    public static void sbdtobf16_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sbdtobf16_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdtobf16_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbf16tos_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbf16tos_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbf16tos_(blasint *, bfloat16 *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sbf16tos_$descriptor() {
        return sbf16tos_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbf16tos_(blasint *, bfloat16 *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sbf16tos_$handle() {
        return sbf16tos_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbf16tos_(blasint *, bfloat16 *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sbf16tos_$address() {
        return sbf16tos_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbf16tos_(blasint *, bfloat16 *, blasint *, float *, blasint *)
     * }
     */
    public static void sbf16tos_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sbf16tos_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbf16tos_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbf16tod_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dbf16tod_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbf16tod_(blasint *, bfloat16 *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dbf16tod_$descriptor() {
        return dbf16tod_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbf16tod_(blasint *, bfloat16 *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dbf16tod_$handle() {
        return dbf16tod_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbf16tod_(blasint *, bfloat16 *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dbf16tod_$address() {
        return dbf16tod_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbf16tod_(blasint *, bfloat16 *, blasint *, double *, blasint *)
     * }
     */
    public static void dbf16tod_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dbf16tod_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbf16tod_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cdotu_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cdotu_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cdotu_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cdotu_$descriptor() {
        return cdotu_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cdotu_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cdotu_$handle() {
        return cdotu_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cdotu_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cdotu_$address() {
        return cdotu_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cdotu_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static float cdotu_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cdotu_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cdotu_", x0, x1, x2, x3, x4);
            }
            return (float)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cdotc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cdotc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cdotc_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cdotc_$descriptor() {
        return cdotc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cdotc_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cdotc_$handle() {
        return cdotc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cdotc_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cdotc_$address() {
        return cdotc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cdotc_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static float cdotc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cdotc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cdotc_", x0, x1, x2, x3, x4);
            }
            return (float)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zdotu_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zdotu_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double zdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zdotu_$descriptor() {
        return zdotu_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double zdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zdotu_$handle() {
        return zdotu_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double zdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zdotu_$address() {
        return zdotu_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double zdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double zdotu_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zdotu_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zdotu_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zdotc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zdotc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double zdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zdotc_$descriptor() {
        return zdotc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double zdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zdotc_$handle() {
        return zdotc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double zdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zdotc_$address() {
        return zdotc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double zdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double zdotc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zdotc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zdotc_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xdotu_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xdotu_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xdotu_$descriptor() {
        return xdotu_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xdotu_$handle() {
        return xdotu_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xdotu_$address() {
        return xdotu_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotu_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double xdotu_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xdotu_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xdotu_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xdotc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xdotc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xdotc_$descriptor() {
        return xdotc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xdotc_$handle() {
        return xdotc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xdotc_$address() {
        return xdotc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_xdouble xdotc_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static double xdotc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xdotc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xdotc_", x0, x1, x2, x3, x4);
            }
            return (double)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class saxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("saxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void saxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor saxpy_$descriptor() {
        return saxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void saxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle saxpy_$handle() {
        return saxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void saxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment saxpy_$address() {
        return saxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void saxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void saxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = saxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("saxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("daxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void daxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor daxpy_$descriptor() {
        return daxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void daxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle daxpy_$handle() {
        return daxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void daxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment daxpy_$address() {
        return daxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void daxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void daxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = daxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qaxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qaxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qaxpy_$descriptor() {
        return qaxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qaxpy_$handle() {
        return qaxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qaxpy_$address() {
        return qaxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qaxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qaxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qaxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class caxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("caxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void caxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor caxpy_$descriptor() {
        return caxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void caxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle caxpy_$handle() {
        return caxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void caxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment caxpy_$address() {
        return caxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void caxpy_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void caxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = caxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("caxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zaxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zaxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zaxpy_$descriptor() {
        return zaxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zaxpy_$handle() {
        return zaxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zaxpy_$address() {
        return zaxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zaxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zaxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zaxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xaxpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xaxpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xaxpy_$descriptor() {
        return xaxpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xaxpy_$handle() {
        return xaxpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xaxpy_$address() {
        return xaxpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xaxpy_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xaxpy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xaxpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xaxpy_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class caxpyc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("caxpyc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void caxpyc_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor caxpyc_$descriptor() {
        return caxpyc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void caxpyc_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle caxpyc_$handle() {
        return caxpyc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void caxpyc_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment caxpyc_$address() {
        return caxpyc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void caxpyc_(blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void caxpyc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = caxpyc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("caxpyc_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zaxpyc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zaxpyc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zaxpyc_$descriptor() {
        return zaxpyc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zaxpyc_$handle() {
        return zaxpyc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zaxpyc_$address() {
        return zaxpyc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zaxpyc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zaxpyc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zaxpyc_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xaxpyc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xaxpyc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xaxpyc_$descriptor() {
        return xaxpyc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xaxpyc_$handle() {
        return xaxpyc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xaxpyc_$address() {
        return xaxpyc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xaxpyc_(blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xaxpyc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xaxpyc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xaxpyc_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void scopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scopy_$descriptor() {
        return scopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void scopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scopy_$handle() {
        return scopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void scopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scopy_$address() {
        return scopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void scopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void scopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = scopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dcopy_$descriptor() {
        return dcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dcopy_$handle() {
        return dcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dcopy_$address() {
        return dcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dcopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qcopy_$descriptor() {
        return qcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qcopy_$handle() {
        return qcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qcopy_$address() {
        return qcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qcopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ccopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ccopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ccopy_$descriptor() {
        return ccopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ccopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ccopy_$handle() {
        return ccopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ccopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ccopy_$address() {
        return ccopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ccopy_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ccopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ccopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zcopy_$descriptor() {
        return zcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zcopy_$handle() {
        return zcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zcopy_$address() {
        return zcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xcopy_$descriptor() {
        return xcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xcopy_$handle() {
        return xcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xcopy_$address() {
        return xcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xcopy_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xcopy_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sswap_$descriptor() {
        return sswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sswap_$handle() {
        return sswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sswap_$address() {
        return sswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void sswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = sswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dswap_$descriptor() {
        return dswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dswap_$handle() {
        return dswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dswap_$address() {
        return dswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qswap_$descriptor() {
        return qswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qswap_$handle() {
        return qswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qswap_$address() {
        return qswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cswap_$descriptor() {
        return cswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cswap_$handle() {
        return cswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cswap_$address() {
        return cswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cswap_(blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void cswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zswap_$descriptor() {
        return zswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zswap_$handle() {
        return zswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zswap_$address() {
        return zswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xswap_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xswap_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xswap_$descriptor() {
        return xswap_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xswap_$handle() {
        return xswap_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xswap_$address() {
        return xswap_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xswap_(blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xswap_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xswap_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xswap_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sasum_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sasum_$descriptor() {
        return sasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sasum_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sasum_$handle() {
        return sasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sasum_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sasum_$address() {
        return sasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sasum_(blasint *, float *, blasint *)
     * }
     */
    public static float sasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = sasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sasum_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scasum_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scasum_$descriptor() {
        return scasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scasum_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scasum_$handle() {
        return scasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scasum_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scasum_$address() {
        return scasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scasum_(blasint *, float *, blasint *)
     * }
     */
    public static float scasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scasum_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dasum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dasum_$descriptor() {
        return dasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dasum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dasum_$handle() {
        return dasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dasum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dasum_$address() {
        return dasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dasum_(blasint *, double *, blasint *)
     * }
     */
    public static double dasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dasum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qasum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qasum_$descriptor() {
        return qasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qasum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qasum_$handle() {
        return qasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qasum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qasum_$address() {
        return qasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qasum_(blasint *, double *, blasint *)
     * }
     */
    public static double qasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qasum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzasum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzasum_$descriptor() {
        return dzasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzasum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzasum_$handle() {
        return dzasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzasum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzasum_$address() {
        return dzasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzasum_(blasint *, double *, blasint *)
     * }
     */
    public static double dzasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzasum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxasum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxasum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxasum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxasum_$descriptor() {
        return qxasum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxasum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxasum_$handle() {
        return qxasum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxasum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxasum_$address() {
        return qxasum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxasum_(blasint *, double *, blasint *)
     * }
     */
    public static double qxasum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxasum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxasum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ssum_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssum_$descriptor() {
        return ssum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ssum_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ssum_$handle() {
        return ssum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ssum_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ssum_$address() {
        return ssum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ssum_(blasint *, float *, blasint *)
     * }
     */
    public static float ssum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ssum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssum_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scsum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scsum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scsum_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scsum_$descriptor() {
        return scsum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scsum_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scsum_$handle() {
        return scsum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scsum_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scsum_$address() {
        return scsum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scsum_(blasint *, float *, blasint *)
     * }
     */
    public static float scsum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scsum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scsum_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dsum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsum_$descriptor() {
        return dsum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dsum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dsum_$handle() {
        return dsum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dsum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dsum_$address() {
        return dsum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dsum_(blasint *, double *, blasint *)
     * }
     */
    public static double dsum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dsum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qsum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsum_$descriptor() {
        return qsum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qsum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qsum_$handle() {
        return qsum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qsum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qsum_$address() {
        return qsum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qsum_(blasint *, double *, blasint *)
     * }
     */
    public static double qsum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qsum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzsum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzsum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzsum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzsum_$descriptor() {
        return dzsum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzsum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzsum_$handle() {
        return dzsum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzsum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzsum_$address() {
        return dzsum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzsum_(blasint *, double *, blasint *)
     * }
     */
    public static double dzsum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzsum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzsum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxsum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxsum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxsum_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxsum_$descriptor() {
        return qxsum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxsum_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxsum_$handle() {
        return qxsum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxsum_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxsum_$address() {
        return qxsum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxsum_(blasint *, double *, blasint *)
     * }
     */
    public static double qxsum_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxsum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxsum_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("isamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint isamax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor isamax_$descriptor() {
        return isamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint isamax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle isamax_$handle() {
        return isamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint isamax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment isamax_$address() {
        return isamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint isamax_(blasint *, float *, blasint *)
     * }
     */
    public static int isamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = isamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class idamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("idamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint idamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor idamax_$descriptor() {
        return idamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint idamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle idamax_$handle() {
        return idamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint idamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment idamax_$address() {
        return idamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint idamax_(blasint *, double *, blasint *)
     * }
     */
    public static int idamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = idamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("idamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iqamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("iqamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint iqamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor iqamax_$descriptor() {
        return iqamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint iqamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle iqamax_$handle() {
        return iqamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint iqamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment iqamax_$address() {
        return iqamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint iqamax_(blasint *, double *, blasint *)
     * }
     */
    public static int iqamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = iqamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iqamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class icamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("icamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint icamax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor icamax_$descriptor() {
        return icamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint icamax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle icamax_$handle() {
        return icamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint icamax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment icamax_$address() {
        return icamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint icamax_(blasint *, float *, blasint *)
     * }
     */
    public static int icamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = icamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("icamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class izamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("izamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint izamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor izamax_$descriptor() {
        return izamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint izamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle izamax_$handle() {
        return izamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint izamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment izamax_$address() {
        return izamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint izamax_(blasint *, double *, blasint *)
     * }
     */
    public static int izamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = izamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("izamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ixamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ixamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ixamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ixamax_$descriptor() {
        return ixamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ixamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ixamax_$handle() {
        return ixamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ixamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ixamax_$address() {
        return ixamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ixamax_(blasint *, double *, blasint *)
     * }
     */
    public static int ixamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ixamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ixamax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ismax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ismax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ismax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ismax_$descriptor() {
        return ismax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ismax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ismax_$handle() {
        return ismax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ismax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ismax_$address() {
        return ismax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ismax_(blasint *, float *, blasint *)
     * }
     */
    public static int ismax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ismax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ismax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class idmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("idmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint idmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor idmax_$descriptor() {
        return idmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint idmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle idmax_$handle() {
        return idmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint idmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment idmax_$address() {
        return idmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint idmax_(blasint *, double *, blasint *)
     * }
     */
    public static int idmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = idmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("idmax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iqmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("iqmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint iqmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor iqmax_$descriptor() {
        return iqmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint iqmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle iqmax_$handle() {
        return iqmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint iqmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment iqmax_$address() {
        return iqmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint iqmax_(blasint *, double *, blasint *)
     * }
     */
    public static int iqmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = iqmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iqmax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class icmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("icmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint icmax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor icmax_$descriptor() {
        return icmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint icmax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle icmax_$handle() {
        return icmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint icmax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment icmax_$address() {
        return icmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint icmax_(blasint *, float *, blasint *)
     * }
     */
    public static int icmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = icmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("icmax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class izmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("izmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint izmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor izmax_$descriptor() {
        return izmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint izmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle izmax_$handle() {
        return izmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint izmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment izmax_$address() {
        return izmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint izmax_(blasint *, double *, blasint *)
     * }
     */
    public static int izmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = izmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("izmax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ixmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ixmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ixmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ixmax_$descriptor() {
        return ixmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ixmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ixmax_$handle() {
        return ixmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ixmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ixmax_$address() {
        return ixmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ixmax_(blasint *, double *, blasint *)
     * }
     */
    public static int ixmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ixmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ixmax_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("isamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint isamin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor isamin_$descriptor() {
        return isamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint isamin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle isamin_$handle() {
        return isamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint isamin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment isamin_$address() {
        return isamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint isamin_(blasint *, float *, blasint *)
     * }
     */
    public static int isamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = isamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class idamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("idamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint idamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor idamin_$descriptor() {
        return idamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint idamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle idamin_$handle() {
        return idamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint idamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment idamin_$address() {
        return idamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint idamin_(blasint *, double *, blasint *)
     * }
     */
    public static int idamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = idamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("idamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iqamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("iqamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint iqamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor iqamin_$descriptor() {
        return iqamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint iqamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle iqamin_$handle() {
        return iqamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint iqamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment iqamin_$address() {
        return iqamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint iqamin_(blasint *, double *, blasint *)
     * }
     */
    public static int iqamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = iqamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iqamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class icamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("icamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint icamin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor icamin_$descriptor() {
        return icamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint icamin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle icamin_$handle() {
        return icamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint icamin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment icamin_$address() {
        return icamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint icamin_(blasint *, float *, blasint *)
     * }
     */
    public static int icamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = icamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("icamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class izamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("izamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint izamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor izamin_$descriptor() {
        return izamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint izamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle izamin_$handle() {
        return izamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint izamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment izamin_$address() {
        return izamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint izamin_(blasint *, double *, blasint *)
     * }
     */
    public static int izamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = izamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("izamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ixamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ixamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ixamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ixamin_$descriptor() {
        return ixamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ixamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ixamin_$handle() {
        return ixamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ixamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ixamin_$address() {
        return ixamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ixamin_(blasint *, double *, blasint *)
     * }
     */
    public static int ixamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ixamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ixamin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ismin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ismin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ismin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ismin_$descriptor() {
        return ismin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ismin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ismin_$handle() {
        return ismin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ismin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ismin_$address() {
        return ismin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ismin_(blasint *, float *, blasint *)
     * }
     */
    public static int ismin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ismin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ismin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class idmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("idmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint idmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor idmin_$descriptor() {
        return idmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint idmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle idmin_$handle() {
        return idmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint idmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment idmin_$address() {
        return idmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint idmin_(blasint *, double *, blasint *)
     * }
     */
    public static int idmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = idmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("idmin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iqmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("iqmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint iqmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor iqmin_$descriptor() {
        return iqmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint iqmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle iqmin_$handle() {
        return iqmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint iqmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment iqmin_$address() {
        return iqmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint iqmin_(blasint *, double *, blasint *)
     * }
     */
    public static int iqmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = iqmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iqmin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class icmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("icmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint icmin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor icmin_$descriptor() {
        return icmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint icmin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle icmin_$handle() {
        return icmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint icmin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment icmin_$address() {
        return icmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint icmin_(blasint *, float *, blasint *)
     * }
     */
    public static int icmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = icmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("icmin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class izmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("izmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint izmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor izmin_$descriptor() {
        return izmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint izmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle izmin_$handle() {
        return izmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint izmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment izmin_$address() {
        return izmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint izmin_(blasint *, double *, blasint *)
     * }
     */
    public static int izmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = izmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("izmin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ixmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ixmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * blasint ixmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ixmin_$descriptor() {
        return ixmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * blasint ixmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ixmin_$handle() {
        return ixmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * blasint ixmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ixmin_$address() {
        return ixmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * blasint ixmin_(blasint *, double *, blasint *)
     * }
     */
    public static int ixmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ixmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ixmin_", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("samax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float samax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor samax_$descriptor() {
        return samax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float samax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle samax_$handle() {
        return samax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float samax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment samax_$address() {
        return samax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float samax_(blasint *, float *, blasint *)
     * }
     */
    public static float samax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = samax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samax_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class damax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("damax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double damax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor damax_$descriptor() {
        return damax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double damax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle damax_$handle() {
        return damax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double damax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment damax_$address() {
        return damax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double damax_(blasint *, double *, blasint *)
     * }
     */
    public static double damax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = damax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("damax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qamax_$descriptor() {
        return qamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qamax_$handle() {
        return qamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qamax_$address() {
        return qamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qamax_(blasint *, double *, blasint *)
     * }
     */
    public static double qamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qamax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scamax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scamax_$descriptor() {
        return scamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scamax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scamax_$handle() {
        return scamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scamax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scamax_$address() {
        return scamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scamax_(blasint *, float *, blasint *)
     * }
     */
    public static float scamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scamax_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzamax_$descriptor() {
        return dzamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzamax_$handle() {
        return dzamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzamax_$address() {
        return dzamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzamax_(blasint *, double *, blasint *)
     * }
     */
    public static double dzamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzamax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxamax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxamax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxamax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxamax_$descriptor() {
        return qxamax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxamax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxamax_$handle() {
        return qxamax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxamax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxamax_$address() {
        return qxamax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxamax_(blasint *, double *, blasint *)
     * }
     */
    public static double qxamax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxamax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxamax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("samin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float samin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor samin_$descriptor() {
        return samin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float samin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle samin_$handle() {
        return samin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float samin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment samin_$address() {
        return samin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float samin_(blasint *, float *, blasint *)
     * }
     */
    public static float samin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = samin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samin_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class damin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("damin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double damin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor damin_$descriptor() {
        return damin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double damin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle damin_$handle() {
        return damin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double damin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment damin_$address() {
        return damin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double damin_(blasint *, double *, blasint *)
     * }
     */
    public static double damin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = damin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("damin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qamin_$descriptor() {
        return qamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qamin_$handle() {
        return qamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qamin_$address() {
        return qamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qamin_(blasint *, double *, blasint *)
     * }
     */
    public static double qamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qamin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scamin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scamin_$descriptor() {
        return scamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scamin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scamin_$handle() {
        return scamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scamin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scamin_$address() {
        return scamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scamin_(blasint *, float *, blasint *)
     * }
     */
    public static float scamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scamin_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzamin_$descriptor() {
        return dzamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzamin_$handle() {
        return dzamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzamin_$address() {
        return dzamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzamin_(blasint *, double *, blasint *)
     * }
     */
    public static double dzamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzamin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxamin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxamin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxamin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxamin_$descriptor() {
        return qxamin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxamin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxamin_$handle() {
        return qxamin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxamin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxamin_$address() {
        return qxamin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxamin_(blasint *, double *, blasint *)
     * }
     */
    public static double qxamin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxamin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxamin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class smax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("smax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float smax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor smax_$descriptor() {
        return smax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float smax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle smax_$handle() {
        return smax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float smax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment smax_$address() {
        return smax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float smax_(blasint *, float *, blasint *)
     * }
     */
    public static float smax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = smax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("smax_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dmax_$descriptor() {
        return dmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dmax_$handle() {
        return dmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dmax_$address() {
        return dmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dmax_(blasint *, double *, blasint *)
     * }
     */
    public static double dmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dmax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qmax_$descriptor() {
        return qmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qmax_$handle() {
        return qmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qmax_$address() {
        return qmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qmax_(blasint *, double *, blasint *)
     * }
     */
    public static double qmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qmax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scmax_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scmax_$descriptor() {
        return scmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scmax_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scmax_$handle() {
        return scmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scmax_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scmax_$address() {
        return scmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scmax_(blasint *, float *, blasint *)
     * }
     */
    public static float scmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scmax_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzmax_$descriptor() {
        return dzmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzmax_$handle() {
        return dzmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzmax_$address() {
        return dzmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzmax_(blasint *, double *, blasint *)
     * }
     */
    public static double dzmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzmax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxmax_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxmax_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxmax_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxmax_$descriptor() {
        return qxmax_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxmax_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxmax_$handle() {
        return qxmax_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxmax_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxmax_$address() {
        return qxmax_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxmax_(blasint *, double *, blasint *)
     * }
     */
    public static double qxmax_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxmax_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxmax_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class smin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("smin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float smin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor smin_$descriptor() {
        return smin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float smin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle smin_$handle() {
        return smin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float smin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment smin_$address() {
        return smin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float smin_(blasint *, float *, blasint *)
     * }
     */
    public static float smin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = smin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("smin_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dmin_$descriptor() {
        return dmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dmin_$handle() {
        return dmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dmin_$address() {
        return dmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dmin_(blasint *, double *, blasint *)
     * }
     */
    public static double dmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dmin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qmin_$descriptor() {
        return qmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qmin_$handle() {
        return qmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qmin_$address() {
        return qmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qmin_(blasint *, double *, blasint *)
     * }
     */
    public static double qmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qmin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scmin_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scmin_$descriptor() {
        return scmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scmin_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scmin_$handle() {
        return scmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scmin_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scmin_$address() {
        return scmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scmin_(blasint *, float *, blasint *)
     * }
     */
    public static float scmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scmin_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dzmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dzmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dzmin_$descriptor() {
        return dzmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dzmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dzmin_$handle() {
        return dzmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dzmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dzmin_$address() {
        return dzmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dzmin_(blasint *, double *, blasint *)
     * }
     */
    public static double dzmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dzmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzmin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxmin_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxmin_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxmin_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxmin_$descriptor() {
        return qxmin_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxmin_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxmin_$handle() {
        return qxmin_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxmin_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxmin_$address() {
        return qxmin_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxmin_(blasint *, double *, blasint *)
     * }
     */
    public static double qxmin_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxmin_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxmin_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sscal_$descriptor() {
        return sscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sscal_$handle() {
        return sscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sscal_$address() {
        return sscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static void sscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = sscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dscal_$descriptor() {
        return dscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dscal_$handle() {
        return dscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dscal_$address() {
        return dscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void dscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = dscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qscal_$descriptor() {
        return qscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qscal_$handle() {
        return qscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qscal_$address() {
        return qscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void qscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = qscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cscal_$descriptor() {
        return cscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cscal_$handle() {
        return cscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cscal_$address() {
        return cscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static void cscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = cscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zscal_$descriptor() {
        return zscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zscal_$handle() {
        return zscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zscal_$address() {
        return zscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void zscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = zscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xscal_$descriptor() {
        return xscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xscal_$handle() {
        return xscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xscal_$address() {
        return xscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void xscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = xscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csscal_$descriptor() {
        return csscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csscal_$handle() {
        return csscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csscal_$address() {
        return csscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csscal_(blasint *, float *, float *, blasint *)
     * }
     */
    public static void csscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = csscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zdscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zdscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zdscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zdscal_$descriptor() {
        return zdscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zdscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zdscal_$handle() {
        return zdscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zdscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zdscal_$address() {
        return zdscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zdscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void zdscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = zdscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zdscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xqscal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xqscal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xqscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xqscal_$descriptor() {
        return xqscal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xqscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xqscal_$handle() {
        return xqscal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xqscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xqscal_$address() {
        return xqscal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xqscal_(blasint *, double *, double *, blasint *)
     * }
     */
    public static void xqscal_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = xqscal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xqscal_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class snrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("snrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float snrm2_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor snrm2_$descriptor() {
        return snrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float snrm2_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle snrm2_$handle() {
        return snrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float snrm2_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment snrm2_$address() {
        return snrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float snrm2_(blasint *, float *, blasint *)
     * }
     */
    public static float snrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = snrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("snrm2_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scnrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("scnrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scnrm2_(blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor scnrm2_$descriptor() {
        return scnrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scnrm2_(blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle scnrm2_$handle() {
        return scnrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scnrm2_(blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment scnrm2_$address() {
        return scnrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scnrm2_(blasint *, float *, blasint *)
     * }
     */
    public static float scnrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = scnrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scnrm2_", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dnrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dnrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dnrm2_$descriptor() {
        return dnrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dnrm2_$handle() {
        return dnrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dnrm2_$address() {
        return dnrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static double dnrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dnrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dnrm2_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qnrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qnrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qnrm2_$descriptor() {
        return qnrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qnrm2_$handle() {
        return qnrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qnrm2_$address() {
        return qnrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static double qnrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qnrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qnrm2_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dznrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dznrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dznrm2_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dznrm2_$descriptor() {
        return dznrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dznrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dznrm2_$handle() {
        return dznrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dznrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dznrm2_$address() {
        return dznrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dznrm2_(blasint *, double *, blasint *)
     * }
     */
    public static double dznrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = dznrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dznrm2_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qxnrm2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qxnrm2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qxnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qxnrm2_$descriptor() {
        return qxnrm2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qxnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qxnrm2_$handle() {
        return qxnrm2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qxnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qxnrm2_$address() {
        return qxnrm2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qxnrm2_(blasint *, double *, blasint *)
     * }
     */
    public static double qxnrm2_(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = qxnrm2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qxnrm2_", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static FunctionDescriptor srot_$descriptor() {
        return srot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static MethodHandle srot_$handle() {
        return srot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static MemorySegment srot_$address() {
        return srot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static void srot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = srot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void drot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static FunctionDescriptor drot_$descriptor() {
        return drot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void drot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MethodHandle drot_$handle() {
        return drot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void drot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MemorySegment drot_$address() {
        return drot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void drot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static void drot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = drot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qrot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qrot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static FunctionDescriptor qrot_$descriptor() {
        return qrot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MethodHandle qrot_$handle() {
        return qrot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MemorySegment qrot_$address() {
        return qrot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static void qrot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = qrot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qrot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csrot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csrot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csrot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static FunctionDescriptor csrot_$descriptor() {
        return csrot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csrot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static MethodHandle csrot_$handle() {
        return csrot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csrot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static MemorySegment csrot_$address() {
        return csrot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csrot_(blasint *, float *, blasint *, float *, blasint *, float *, float *)
     * }
     */
    public static void csrot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = csrot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csrot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zdrot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zdrot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zdrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static FunctionDescriptor zdrot_$descriptor() {
        return zdrot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zdrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MethodHandle zdrot_$handle() {
        return zdrot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zdrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MemorySegment zdrot_$address() {
        return zdrot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zdrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static void zdrot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = zdrot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zdrot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xqrot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xqrot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xqrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static FunctionDescriptor xqrot_$descriptor() {
        return xqrot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xqrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MethodHandle xqrot_$handle() {
        return xqrot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xqrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static MemorySegment xqrot_$address() {
        return xqrot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xqrot_(blasint *, double *, blasint *, double *, blasint *, double *, double *)
     * }
     */
    public static void xqrot_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xqrot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xqrot_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srotg_(float *, float *, float *, float *)
     * }
     */
    public static FunctionDescriptor srotg_$descriptor() {
        return srotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srotg_(float *, float *, float *, float *)
     * }
     */
    public static MethodHandle srotg_$handle() {
        return srotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srotg_(float *, float *, float *, float *)
     * }
     */
    public static MemorySegment srotg_$address() {
        return srotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srotg_(float *, float *, float *, float *)
     * }
     */
    public static void srotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = srotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void drotg_(double *, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor drotg_$descriptor() {
        return drotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void drotg_(double *, double *, double *, double *)
     * }
     */
    public static MethodHandle drotg_$handle() {
        return drotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void drotg_(double *, double *, double *, double *)
     * }
     */
    public static MemorySegment drotg_$address() {
        return drotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void drotg_(double *, double *, double *, double *)
     * }
     */
    public static void drotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = drotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qrotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qrotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qrotg_(double *, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor qrotg_$descriptor() {
        return qrotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qrotg_(double *, double *, double *, double *)
     * }
     */
    public static MethodHandle qrotg_$handle() {
        return qrotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qrotg_(double *, double *, double *, double *)
     * }
     */
    public static MemorySegment qrotg_$address() {
        return qrotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qrotg_(double *, double *, double *, double *)
     * }
     */
    public static void qrotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = qrotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qrotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("crotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void crotg_(float *, float *, float *, float *)
     * }
     */
    public static FunctionDescriptor crotg_$descriptor() {
        return crotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void crotg_(float *, float *, float *, float *)
     * }
     */
    public static MethodHandle crotg_$handle() {
        return crotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void crotg_(float *, float *, float *, float *)
     * }
     */
    public static MemorySegment crotg_$address() {
        return crotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void crotg_(float *, float *, float *, float *)
     * }
     */
    public static void crotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = crotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zrotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zrotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zrotg_(double *, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor zrotg_$descriptor() {
        return zrotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zrotg_(double *, double *, double *, double *)
     * }
     */
    public static MethodHandle zrotg_$handle() {
        return zrotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zrotg_(double *, double *, double *, double *)
     * }
     */
    public static MemorySegment zrotg_$address() {
        return zrotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zrotg_(double *, double *, double *, double *)
     * }
     */
    public static void zrotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = zrotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zrotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xrotg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xrotg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xrotg_(double *, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor xrotg_$descriptor() {
        return xrotg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xrotg_(double *, double *, double *, double *)
     * }
     */
    public static MethodHandle xrotg_$handle() {
        return xrotg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xrotg_(double *, double *, double *, double *)
     * }
     */
    public static MemorySegment xrotg_$address() {
        return xrotg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xrotg_(double *, double *, double *, double *)
     * }
     */
    public static void xrotg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = xrotg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xrotg_", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srotmg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srotmg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srotmg_(float *, float *, float *, float *, float *)
     * }
     */
    public static FunctionDescriptor srotmg_$descriptor() {
        return srotmg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srotmg_(float *, float *, float *, float *, float *)
     * }
     */
    public static MethodHandle srotmg_$handle() {
        return srotmg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srotmg_(float *, float *, float *, float *, float *)
     * }
     */
    public static MemorySegment srotmg_$address() {
        return srotmg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srotmg_(float *, float *, float *, float *, float *)
     * }
     */
    public static void srotmg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = srotmg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srotmg_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drotmg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drotmg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void drotmg_(double *, double *, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor drotmg_$descriptor() {
        return drotmg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void drotmg_(double *, double *, double *, double *, double *)
     * }
     */
    public static MethodHandle drotmg_$handle() {
        return drotmg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void drotmg_(double *, double *, double *, double *, double *)
     * }
     */
    public static MemorySegment drotmg_$address() {
        return drotmg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void drotmg_(double *, double *, double *, double *, double *)
     * }
     */
    public static void drotmg_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = drotmg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drotmg_", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srotm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("srotm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srotm_(blasint *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor srotm_$descriptor() {
        return srotm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srotm_(blasint *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle srotm_$handle() {
        return srotm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srotm_(blasint *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment srotm_$address() {
        return srotm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srotm_(blasint *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static void srotm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = srotm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srotm_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drotm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("drotm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void drotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor drotm_$descriptor() {
        return drotm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void drotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle drotm_$handle() {
        return drotm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void drotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment drotm_$address() {
        return drotm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void drotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void drotm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = drotm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drotm_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qrotm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qrotm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qrotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor qrotm_$descriptor() {
        return qrotm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qrotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle qrotm_$handle() {
        return qrotm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qrotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment qrotm_$address() {
        return qrotm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qrotm_(blasint *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void qrotm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qrotm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qrotm_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sger_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sger_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sger_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sger_$descriptor() {
        return sger_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sger_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sger_$handle() {
        return sger_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sger_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sger_$address() {
        return sger_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sger_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void sger_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = sger_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sger_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dger_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dger_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dger_$descriptor() {
        return dger_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dger_$handle() {
        return dger_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dger_$address() {
        return dger_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dger_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dger_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dger_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qger_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qger_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qger_$descriptor() {
        return qger_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qger_$handle() {
        return qger_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qger_$address() {
        return qger_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qger_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qger_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qger_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qger_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeru_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeru_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeru_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgeru_$descriptor() {
        return cgeru_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeru_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cgeru_$handle() {
        return cgeru_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeru_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cgeru_$address() {
        return cgeru_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeru_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void cgeru_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = cgeru_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeru_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgerc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerc_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgerc_$descriptor() {
        return cgerc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerc_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cgerc_$handle() {
        return cgerc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerc_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cgerc_$address() {
        return cgerc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerc_(blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void cgerc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = cgerc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerc_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeru_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeru_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgeru_$descriptor() {
        return zgeru_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zgeru_$handle() {
        return zgeru_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zgeru_$address() {
        return zgeru_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zgeru_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zgeru_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeru_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgerc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgerc_$descriptor() {
        return zgerc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zgerc_$handle() {
        return zgerc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zgerc_$address() {
        return zgerc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zgerc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zgerc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerc_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgeru_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgeru_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgeru_$descriptor() {
        return xgeru_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xgeru_$handle() {
        return xgeru_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xgeru_$address() {
        return xgeru_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgeru_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xgeru_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xgeru_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgeru_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgerc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgerc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgerc_$descriptor() {
        return xgerc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xgerc_$handle() {
        return xgerc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xgerc_$address() {
        return xgerc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgerc_(blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xgerc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xgerc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgerc_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbgemv_(char *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sbgemv_$descriptor() {
        return sbgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbgemv_(char *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sbgemv_$handle() {
        return sbgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbgemv_(char *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sbgemv_$address() {
        return sbgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbgemv_(char *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sbgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = sbgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgemv_$descriptor() {
        return sgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sgemv_$handle() {
        return sgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sgemv_$address() {
        return sgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = sgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgemv_$descriptor() {
        return dgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dgemv_$handle() {
        return dgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dgemv_$address() {
        return dgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = dgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qgemv_$descriptor() {
        return qgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qgemv_$handle() {
        return qgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qgemv_$address() {
        return qgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = qgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgemv_$descriptor() {
        return cgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgemv_$handle() {
        return cgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgemv_$address() {
        return cgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = cgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgemv_$descriptor() {
        return zgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgemv_$handle() {
        return zgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgemv_$address() {
        return zgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = zgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgemv_$descriptor() {
        return xgemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xgemv_$handle() {
        return xgemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xgemv_$address() {
        return xgemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgemv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xgemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = xgemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor strsv_$descriptor() {
        return strsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle strsv_$handle() {
        return strsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment strsv_$address() {
        return strsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void strsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = strsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrsv_$descriptor() {
        return dtrsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtrsv_$handle() {
        return dtrsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtrsv_$address() {
        return dtrsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtrsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dtrsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrsv_$descriptor() {
        return qtrsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtrsv_$handle() {
        return qtrsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtrsv_$address() {
        return qtrsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtrsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = qtrsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrsv_$descriptor() {
        return ctrsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctrsv_$handle() {
        return ctrsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctrsv_$address() {
        return ctrsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctrsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = ctrsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrsv_$descriptor() {
        return ztrsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztrsv_$handle() {
        return ztrsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztrsv_$address() {
        return ztrsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztrsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = ztrsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrsv_$descriptor() {
        return xtrsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtrsv_$handle() {
        return xtrsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtrsv_$address() {
        return xtrsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtrsv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtrsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xtrsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrsv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor strmv_$descriptor() {
        return strmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle strmv_$handle() {
        return strmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment strmv_$address() {
        return strmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void strmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = strmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrmv_$descriptor() {
        return dtrmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtrmv_$handle() {
        return dtrmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtrmv_$address() {
        return dtrmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtrmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dtrmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrmv_$descriptor() {
        return qtrmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtrmv_$handle() {
        return qtrmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtrmv_$address() {
        return qtrmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtrmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = qtrmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrmv_$descriptor() {
        return ctrmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctrmv_$handle() {
        return ctrmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctrmv_$address() {
        return ctrmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrmv_(char *, char *, char *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctrmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = ctrmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrmv_$descriptor() {
        return ztrmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztrmv_$handle() {
        return ztrmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztrmv_$address() {
        return ztrmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztrmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = ztrmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrmv_$descriptor() {
        return xtrmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtrmv_$handle() {
        return xtrmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtrmv_$address() {
        return xtrmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtrmv_(char *, char *, char *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtrmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xtrmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrmv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor stpsv_$descriptor() {
        return stpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle stpsv_$handle() {
        return stpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment stpsv_$address() {
        return stpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void stpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = stpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtpsv_$descriptor() {
        return dtpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dtpsv_$handle() {
        return dtpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dtpsv_$address() {
        return dtpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dtpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = dtpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtpsv_$descriptor() {
        return qtpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qtpsv_$handle() {
        return qtpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qtpsv_$address() {
        return qtpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qtpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = qtpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctpsv_$descriptor() {
        return ctpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ctpsv_$handle() {
        return ctpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ctpsv_$address() {
        return ctpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpsv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ctpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ctpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztpsv_$descriptor() {
        return ztpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle ztpsv_$handle() {
        return ztpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment ztpsv_$address() {
        return ztpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void ztpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ztpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtpsv_$descriptor() {
        return xtpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xtpsv_$handle() {
        return xtpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xtpsv_$address() {
        return xtpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtpsv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xtpsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xtpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtpsv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor stpmv_$descriptor() {
        return stpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle stpmv_$handle() {
        return stpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment stpmv_$address() {
        return stpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void stpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = stpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtpmv_$descriptor() {
        return dtpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dtpmv_$handle() {
        return dtpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dtpmv_$address() {
        return dtpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dtpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = dtpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtpmv_$descriptor() {
        return qtpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qtpmv_$handle() {
        return qtpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qtpmv_$address() {
        return qtpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qtpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = qtpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctpmv_$descriptor() {
        return ctpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ctpmv_$handle() {
        return ctpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ctpmv_$address() {
        return ctpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpmv_(char *, char *, char *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ctpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ctpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztpmv_$descriptor() {
        return ztpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle ztpmv_$handle() {
        return ztpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment ztpmv_$address() {
        return ztpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void ztpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ztpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtpmv_$descriptor() {
        return xtpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xtpmv_$handle() {
        return xtpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xtpmv_$address() {
        return xtpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtpmv_(char *, char *, char *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xtpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xtpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtpmv_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor stbmv_$descriptor() {
        return stbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle stbmv_$handle() {
        return stbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment stbmv_$address() {
        return stbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void stbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = stbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtbmv_$descriptor() {
        return dtbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtbmv_$handle() {
        return dtbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtbmv_$address() {
        return dtbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dtbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtbmv_$descriptor() {
        return qtbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtbmv_$handle() {
        return qtbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtbmv_$address() {
        return qtbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qtbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctbmv_$descriptor() {
        return ctbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctbmv_$handle() {
        return ctbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctbmv_$address() {
        return ctbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbmv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = ctbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztbmv_$descriptor() {
        return ztbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztbmv_$handle() {
        return ztbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztbmv_$address() {
        return ztbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = ztbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtbmv_$descriptor() {
        return xtbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtbmv_$handle() {
        return xtbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtbmv_$address() {
        return xtbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtbmv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xtbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor stbsv_$descriptor() {
        return stbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle stbsv_$handle() {
        return stbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment stbsv_$address() {
        return stbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void stbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = stbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtbsv_$descriptor() {
        return dtbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtbsv_$handle() {
        return dtbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtbsv_$address() {
        return dtbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dtbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtbsv_$descriptor() {
        return qtbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtbsv_$handle() {
        return qtbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtbsv_$address() {
        return qtbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qtbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctbsv_$descriptor() {
        return ctbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctbsv_$handle() {
        return ctbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctbsv_$address() {
        return ctbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbsv_(char *, char *, char *, blasint *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = ctbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztbsv_$descriptor() {
        return ztbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztbsv_$handle() {
        return ztbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztbsv_$address() {
        return ztbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = ztbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtbsv_$descriptor() {
        return xtbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtbsv_$handle() {
        return xtbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtbsv_$address() {
        return xtbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtbsv_(char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtbsv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xtbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtbsv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssymv_$descriptor() {
        return ssymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ssymv_$handle() {
        return ssymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ssymv_$address() {
        return ssymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ssymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = ssymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsymv_$descriptor() {
        return dsymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dsymv_$handle() {
        return dsymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dsymv_$address() {
        return dsymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dsymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = dsymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsymv_$descriptor() {
        return qsymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qsymv_$handle() {
        return qsymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qsymv_$address() {
        return qsymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qsymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = qsymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csymv_$descriptor() {
        return csymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csymv_$handle() {
        return csymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csymv_$address() {
        return csymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csymv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = csymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsymv_$descriptor() {
        return zsymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsymv_$handle() {
        return zsymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsymv_$address() {
        return zsymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = zsymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsymv_$descriptor() {
        return xsymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsymv_$handle() {
        return xsymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsymv_$address() {
        return xsymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsymv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsymv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = xsymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsymv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sspmv_$descriptor() {
        return sspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sspmv_$handle() {
        return sspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sspmv_$address() {
        return sspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = sspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dspmv_$descriptor() {
        return dspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dspmv_$handle() {
        return dspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dspmv_$address() {
        return dspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qspmv_$descriptor() {
        return qspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qspmv_$handle() {
        return qspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qspmv_$address() {
        return qspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cspmv_$descriptor() {
        return cspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cspmv_$handle() {
        return cspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cspmv_$address() {
        return cspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = cspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zspmv_$descriptor() {
        return zspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zspmv_$handle() {
        return zspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zspmv_$address() {
        return zspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xspmv_$descriptor() {
        return xspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xspmv_$handle() {
        return xspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xspmv_$address() {
        return xspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xspmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xspmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xspmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssyr_$descriptor() {
        return ssyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ssyr_$handle() {
        return ssyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ssyr_$address() {
        return ssyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ssyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ssyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsyr_$descriptor() {
        return dsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dsyr_$handle() {
        return dsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dsyr_$address() {
        return dsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dsyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = dsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsyr_$descriptor() {
        return qsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qsyr_$handle() {
        return qsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qsyr_$address() {
        return qsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qsyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = qsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csyr_$descriptor() {
        return csyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle csyr_$handle() {
        return csyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment csyr_$address() {
        return csyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyr_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void csyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = csyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsyr_$descriptor() {
        return zsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zsyr_$handle() {
        return zsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zsyr_$address() {
        return zsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zsyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = zsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsyr_$descriptor() {
        return xsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xsyr_$handle() {
        return xsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xsyr_$address() {
        return xsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsyr_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xsyr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsyr_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssyr2_$descriptor() {
        return ssyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ssyr2_$handle() {
        return ssyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ssyr2_$address() {
        return ssyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ssyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = ssyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsyr2_$descriptor() {
        return dsyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dsyr2_$handle() {
        return dsyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dsyr2_$address() {
        return dsyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dsyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dsyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsyr2_$descriptor() {
        return qsyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qsyr2_$handle() {
        return qsyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qsyr2_$address() {
        return qsyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qsyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qsyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csyr2_$descriptor() {
        return csyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle csyr2_$handle() {
        return csyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment csyr2_$address() {
        return csyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void csyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = csyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsyr2_$descriptor() {
        return zsyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zsyr2_$handle() {
        return zsyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zsyr2_$address() {
        return zsyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zsyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zsyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsyr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsyr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsyr2_$descriptor() {
        return xsyr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xsyr2_$handle() {
        return xsyr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xsyr2_$address() {
        return xsyr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsyr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xsyr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xsyr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsyr2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor sspr_$descriptor() {
        return sspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle sspr_$handle() {
        return sspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment sspr_$address() {
        return sspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static void sspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = sspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor dspr_$descriptor() {
        return dspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle dspr_$handle() {
        return dspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment dspr_$address() {
        return dspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void dspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = dspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor qspr_$descriptor() {
        return qspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle qspr_$handle() {
        return qspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment qspr_$address() {
        return qspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void qspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor cspr_$descriptor() {
        return cspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle cspr_$handle() {
        return cspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment cspr_$address() {
        return cspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static void cspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = cspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor zspr_$descriptor() {
        return zspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle zspr_$handle() {
        return zspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment zspr_$address() {
        return zspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void zspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor xspr_$descriptor() {
        return xspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle xspr_$handle() {
        return xspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment xspr_$address() {
        return xspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xspr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void xspr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xspr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor sspr2_$descriptor() {
        return sspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle sspr2_$handle() {
        return sspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment sspr2_$address() {
        return sspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static void sspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = sspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor dspr2_$descriptor() {
        return dspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle dspr2_$handle() {
        return dspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment dspr2_$address() {
        return dspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void dspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor qspr2_$descriptor() {
        return qspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle qspr2_$handle() {
        return qspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment qspr2_$address() {
        return qspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void qspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = qspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor cspr2_$descriptor() {
        return cspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle cspr2_$handle() {
        return cspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment cspr2_$address() {
        return cspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static void cspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor zspr2_$descriptor() {
        return zspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle zspr2_$handle() {
        return zspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment zspr2_$address() {
        return zspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void zspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xspr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xspr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor xspr2_$descriptor() {
        return xspr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle xspr2_$handle() {
        return xspr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment xspr2_$address() {
        return xspr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xspr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void xspr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xspr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xspr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cher_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cher_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cher_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cher_$descriptor() {
        return cher_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cher_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cher_$handle() {
        return cher_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cher_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cher_$address() {
        return cher_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cher_(char *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void cher_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = cher_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cher_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zher_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zher_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zher_$descriptor() {
        return zher_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zher_$handle() {
        return zher_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zher_$address() {
        return zher_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zher_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = zher_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zher_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xher_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xher_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xher_$descriptor() {
        return xher_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xher_$handle() {
        return xher_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xher_$address() {
        return xher_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xher_(char *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xher_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xher_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xher_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor chpr_$descriptor() {
        return chpr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle chpr_$handle() {
        return chpr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment chpr_$address() {
        return chpr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpr_(char *, blasint *, float *, float *, blasint *, float *)
     * }
     */
    public static void chpr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = chpr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor zhpr_$descriptor() {
        return zhpr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle zhpr_$handle() {
        return zhpr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment zhpr_$address() {
        return zhpr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void zhpr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zhpr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhpr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhpr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor xhpr_$descriptor() {
        return xhpr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle xhpr_$handle() {
        return xhpr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment xhpr_$address() {
        return xhpr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhpr_(char *, blasint *, double *, double *, blasint *, double *)
     * }
     */
    public static void xhpr_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xhpr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhpr_", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cher2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cher2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cher2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cher2_$descriptor() {
        return cher2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cher2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cher2_$handle() {
        return cher2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cher2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cher2_$address() {
        return cher2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cher2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void cher2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = cher2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cher2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zher2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zher2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zher2_$descriptor() {
        return zher2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zher2_$handle() {
        return zher2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zher2_$address() {
        return zher2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zher2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zher2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zher2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xher2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xher2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xher2_$descriptor() {
        return xher2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xher2_$handle() {
        return xher2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xher2_$address() {
        return xher2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xher2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xher2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xher2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xher2_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static FunctionDescriptor chpr2_$descriptor() {
        return chpr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MethodHandle chpr2_$handle() {
        return chpr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static MemorySegment chpr2_$address() {
        return chpr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpr2_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *)
     * }
     */
    public static void chpr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = chpr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor zhpr2_$descriptor() {
        return zhpr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle zhpr2_$handle() {
        return zhpr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment zhpr2_$address() {
        return zhpr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void zhpr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zhpr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhpr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhpr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static FunctionDescriptor xhpr2_$descriptor() {
        return xhpr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MethodHandle xhpr2_$handle() {
        return xhpr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static MemorySegment xhpr2_$address() {
        return xhpr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhpr2_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *)
     * }
     */
    public static void xhpr2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xhpr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhpr2_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chemv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor chemv_$descriptor() {
        return chemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chemv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle chemv_$handle() {
        return chemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chemv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment chemv_$address() {
        return chemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chemv_(char *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void chemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = chemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zhemv_$descriptor() {
        return zhemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zhemv_$handle() {
        return zhemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zhemv_$address() {
        return zhemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zhemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = zhemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhemv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhemv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xhemv_$descriptor() {
        return xhemv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xhemv_$handle() {
        return xhemv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xhemv_$address() {
        return xhemv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhemv_(char *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xhemv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = xhemv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhemv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor chpmv_$descriptor() {
        return chpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle chpmv_$handle() {
        return chpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment chpmv_$address() {
        return chpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpmv_(char *, blasint *, float *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void chpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = chpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zhpmv_$descriptor() {
        return zhpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zhpmv_$handle() {
        return zhpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zhpmv_$address() {
        return zhpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zhpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zhpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhpmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhpmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xhpmv_$descriptor() {
        return xhpmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xhpmv_$handle() {
        return xhpmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xhpmv_$address() {
        return xhpmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhpmv_(char *, blasint *, double *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xhpmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xhpmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhpmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class snorm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("snorm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int snorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor snorm_$descriptor() {
        return snorm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int snorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle snorm_$handle() {
        return snorm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int snorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment snorm_$address() {
        return snorm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int snorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static int snorm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = snorm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("snorm_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dnorm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dnorm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dnorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dnorm_$descriptor() {
        return dnorm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dnorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dnorm_$handle() {
        return dnorm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dnorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dnorm_$address() {
        return dnorm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dnorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static int dnorm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dnorm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dnorm_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cnorm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cnorm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cnorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cnorm_$descriptor() {
        return cnorm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cnorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cnorm_$handle() {
        return cnorm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cnorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cnorm_$address() {
        return cnorm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cnorm_(char *, blasint *, blasint *, float *, blasint *)
     * }
     */
    public static int cnorm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cnorm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cnorm_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class znorm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("znorm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int znorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor znorm_$descriptor() {
        return znorm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int znorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle znorm_$handle() {
        return znorm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int znorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment znorm_$address() {
        return znorm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int znorm_(char *, blasint *, blasint *, double *, blasint *)
     * }
     */
    public static int znorm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = znorm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("znorm_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgbmv_$descriptor() {
        return sgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sgbmv_$handle() {
        return sgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sgbmv_$address() {
        return sgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = sgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgbmv_$descriptor() {
        return dgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dgbmv_$handle() {
        return dgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dgbmv_$address() {
        return dgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = dgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qgbmv_$descriptor() {
        return qgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qgbmv_$handle() {
        return qgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qgbmv_$address() {
        return qgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = qgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgbmv_$descriptor() {
        return cgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgbmv_$handle() {
        return cgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgbmv_$address() {
        return cgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbmv_(char *, blasint *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = cgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgbmv_$descriptor() {
        return zgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgbmv_$handle() {
        return zgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgbmv_$address() {
        return zgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = zgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgbmv_$descriptor() {
        return xgbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xgbmv_$handle() {
        return xgbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xgbmv_$address() {
        return xgbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgbmv_(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xgbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = xgbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssbmv_$descriptor() {
        return ssbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ssbmv_$handle() {
        return ssbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ssbmv_$address() {
        return ssbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ssbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = ssbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsbmv_$descriptor() {
        return dsbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dsbmv_$handle() {
        return dsbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dsbmv_$address() {
        return dsbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dsbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = dsbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsbmv_$descriptor() {
        return qsbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qsbmv_$handle() {
        return qsbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qsbmv_$address() {
        return qsbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qsbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = qsbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csbmv_$descriptor() {
        return csbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csbmv_$handle() {
        return csbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csbmv_$address() {
        return csbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = csbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsbmv_$descriptor() {
        return zsbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsbmv_$handle() {
        return zsbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsbmv_$address() {
        return zsbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = zsbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsbmv_$descriptor() {
        return xsbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsbmv_$handle() {
        return xsbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsbmv_$address() {
        return xsbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = xsbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor chbmv_$descriptor() {
        return chbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle chbmv_$handle() {
        return chbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment chbmv_$address() {
        return chbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbmv_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void chbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = chbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zhbmv_$descriptor() {
        return zhbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zhbmv_$handle() {
        return zhbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zhbmv_$address() {
        return zhbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zhbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = zhbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhbmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhbmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xhbmv_$descriptor() {
        return xhbmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xhbmv_$handle() {
        return xhbmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xhbmv_$address() {
        return xhbmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhbmv_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xhbmv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = xhbmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhbmv_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sbgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbgemm_(char *, char *, blasint *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sbgemm_$descriptor() {
        return sbgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbgemm_(char *, char *, blasint *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sbgemm_$handle() {
        return sbgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbgemm_(char *, char *, blasint *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sbgemm_$address() {
        return sbgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbgemm_(char *, char *, blasint *, blasint *, blasint *, float *, bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sbgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = sbgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgemm_$descriptor() {
        return sgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sgemm_$handle() {
        return sgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sgemm_$address() {
        return sgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = sgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgemm_$descriptor() {
        return dgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dgemm_$handle() {
        return dgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dgemm_$address() {
        return dgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = dgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qgemm_$descriptor() {
        return qgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qgemm_$handle() {
        return qgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qgemm_$address() {
        return qgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = qgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgemm_$descriptor() {
        return cgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgemm_$handle() {
        return cgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgemm_$address() {
        return cgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemm_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = cgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgemm_$descriptor() {
        return zgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgemm_$handle() {
        return zgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgemm_$address() {
        return zgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = zgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgemm_$descriptor() {
        return xgemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xgemm_$handle() {
        return xgemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xgemm_$address() {
        return xgemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgemm_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xgemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = xgemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemm3m_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgemm3m_$descriptor() {
        return cgemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemm3m_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgemm3m_$handle() {
        return cgemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemm3m_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgemm3m_$address() {
        return cgemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemm3m_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cgemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = cgemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgemm3m_$descriptor() {
        return zgemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgemm3m_$handle() {
        return zgemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgemm3m_$address() {
        return zgemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zgemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = zgemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgemm3m_$descriptor() {
        return xgemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xgemm3m_$handle() {
        return xgemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xgemm3m_$address() {
        return xgemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xgemm3m_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xgemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = xgemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sge2mm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sge2mm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sge2mm_$descriptor() {
        return sge2mm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sge2mm_$handle() {
        return sge2mm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sge2mm_$address() {
        return sge2mm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static int sge2mm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = sge2mm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sge2mm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dge2mm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dge2mm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dge2mm_$descriptor() {
        return dge2mm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dge2mm_$handle() {
        return dge2mm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dge2mm_$address() {
        return dge2mm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int dge2mm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = dge2mm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dge2mm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cge2mm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cge2mm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cge2mm_$descriptor() {
        return cge2mm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cge2mm_$handle() {
        return cge2mm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cge2mm_$address() {
        return cge2mm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cge2mm_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static int cge2mm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = cge2mm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cge2mm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zge2mm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zge2mm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zge2mm_$descriptor() {
        return zge2mm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zge2mm_$handle() {
        return zge2mm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zge2mm_$address() {
        return zge2mm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zge2mm_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int zge2mm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = zge2mm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zge2mm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor strsm_$descriptor() {
        return strsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle strsm_$handle() {
        return strsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment strsm_$address() {
        return strsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void strsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = strsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrsm_$descriptor() {
        return dtrsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtrsm_$handle() {
        return dtrsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtrsm_$address() {
        return dtrsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtrsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = dtrsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrsm_$descriptor() {
        return qtrsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtrsm_$handle() {
        return qtrsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtrsm_$address() {
        return qtrsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtrsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = qtrsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrsm_$descriptor() {
        return ctrsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctrsm_$handle() {
        return ctrsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctrsm_$address() {
        return ctrsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctrsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = ctrsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrsm_$descriptor() {
        return ztrsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztrsm_$handle() {
        return ztrsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztrsm_$address() {
        return ztrsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztrsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = ztrsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrsm_$descriptor() {
        return xtrsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtrsm_$handle() {
        return xtrsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtrsm_$address() {
        return xtrsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtrsm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtrsm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = xtrsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrsm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor strmm_$descriptor() {
        return strmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle strmm_$handle() {
        return strmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment strmm_$address() {
        return strmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void strmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = strmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrmm_$descriptor() {
        return dtrmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dtrmm_$handle() {
        return dtrmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dtrmm_$address() {
        return dtrmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void dtrmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = dtrmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrmm_$descriptor() {
        return qtrmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle qtrmm_$handle() {
        return qtrmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment qtrmm_$address() {
        return qtrmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void qtrmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = qtrmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrmm_$descriptor() {
        return ctrmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle ctrmm_$handle() {
        return ctrmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment ctrmm_$address() {
        return ctrmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrmm_(char *, char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void ctrmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = ctrmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrmm_$descriptor() {
        return ztrmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle ztrmm_$handle() {
        return ztrmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment ztrmm_$address() {
        return ztrmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void ztrmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = ztrmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrmm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrmm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrmm_$descriptor() {
        return xtrmm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle xtrmm_$handle() {
        return xtrmm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment xtrmm_$address() {
        return xtrmm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xtrmm_(char *, char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void xtrmm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = xtrmm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrmm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssymm_$descriptor() {
        return ssymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ssymm_$handle() {
        return ssymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ssymm_$address() {
        return ssymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ssymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = ssymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsymm_$descriptor() {
        return dsymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dsymm_$handle() {
        return dsymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dsymm_$address() {
        return dsymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dsymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = dsymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsymm_$descriptor() {
        return qsymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qsymm_$handle() {
        return qsymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qsymm_$address() {
        return qsymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qsymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = qsymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csymm_$descriptor() {
        return csymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csymm_$handle() {
        return csymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csymm_$address() {
        return csymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csymm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = csymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsymm_$descriptor() {
        return zsymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsymm_$handle() {
        return zsymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsymm_$address() {
        return zsymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zsymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsymm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsymm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsymm_$descriptor() {
        return xsymm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsymm_$handle() {
        return xsymm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsymm_$address() {
        return xsymm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsymm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsymm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xsymm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsymm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csymm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csymm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csymm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csymm3m_$descriptor() {
        return csymm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csymm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csymm3m_$handle() {
        return csymm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csymm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csymm3m_$address() {
        return csymm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csymm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csymm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = csymm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csymm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsymm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsymm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsymm3m_$descriptor() {
        return zsymm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsymm3m_$handle() {
        return zsymm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsymm3m_$address() {
        return zsymm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsymm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zsymm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsymm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsymm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsymm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsymm3m_$descriptor() {
        return xsymm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsymm3m_$handle() {
        return xsymm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsymm3m_$address() {
        return xsymm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsymm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsymm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xsymm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsymm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssyrk_$descriptor() {
        return ssyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ssyrk_$handle() {
        return ssyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ssyrk_$address() {
        return ssyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ssyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = ssyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsyrk_$descriptor() {
        return dsyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dsyrk_$handle() {
        return dsyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dsyrk_$address() {
        return dsyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dsyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = dsyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsyrk_$descriptor() {
        return qsyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qsyrk_$handle() {
        return qsyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qsyrk_$address() {
        return qsyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qsyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = qsyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csyrk_$descriptor() {
        return csyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csyrk_$handle() {
        return csyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csyrk_$address() {
        return csyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyrk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = csyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsyrk_$descriptor() {
        return zsyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsyrk_$handle() {
        return zsyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsyrk_$address() {
        return zsyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = zsyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsyrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsyrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsyrk_$descriptor() {
        return xsyrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsyrk_$handle() {
        return xsyrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsyrk_$address() {
        return xsyrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsyrk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsyrk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = xsyrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsyrk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor ssyr2k_$descriptor() {
        return ssyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle ssyr2k_$handle() {
        return ssyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment ssyr2k_$address() {
        return ssyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void ssyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = ssyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dsyr2k_$descriptor() {
        return dsyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dsyr2k_$handle() {
        return dsyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dsyr2k_$address() {
        return dsyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dsyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = dsyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qsyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qsyr2k_$descriptor() {
        return qsyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qsyr2k_$handle() {
        return qsyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qsyr2k_$address() {
        return qsyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void qsyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = qsyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor csyr2k_$descriptor() {
        return csyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle csyr2k_$handle() {
        return csyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment csyr2k_$address() {
        return csyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyr2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void csyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = csyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zsyr2k_$descriptor() {
        return zsyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zsyr2k_$handle() {
        return zsyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zsyr2k_$address() {
        return zsyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zsyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zsyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xsyr2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xsyr2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xsyr2k_$descriptor() {
        return xsyr2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xsyr2k_$handle() {
        return xsyr2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xsyr2k_$address() {
        return xsyr2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xsyr2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xsyr2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xsyr2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xsyr2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chemm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor chemm_$descriptor() {
        return chemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chemm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle chemm_$handle() {
        return chemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chemm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment chemm_$address() {
        return chemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chemm_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void chemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = chemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zhemm_$descriptor() {
        return zhemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zhemm_$handle() {
        return zhemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zhemm_$address() {
        return zhemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zhemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zhemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhemm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhemm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xhemm_$descriptor() {
        return xhemm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xhemm_$handle() {
        return xhemm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xhemm_$address() {
        return xhemm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhemm_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xhemm_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xhemm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhemm_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chemm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor chemm3m_$descriptor() {
        return chemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chemm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle chemm3m_$handle() {
        return chemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chemm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment chemm3m_$address() {
        return chemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chemm3m_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void chemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = chemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zhemm3m_$descriptor() {
        return zhemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zhemm3m_$handle() {
        return zhemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zhemm3m_$address() {
        return zhemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zhemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zhemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xhemm3m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xhemm3m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xhemm3m_$descriptor() {
        return xhemm3m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xhemm3m_$handle() {
        return xhemm3m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xhemm3m_$address() {
        return xhemm3m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xhemm3m_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xhemm3m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xhemm3m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xhemm3m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cherk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cherk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cherk_$descriptor() {
        return cherk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cherk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cherk_$handle() {
        return cherk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cherk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cherk_$address() {
        return cherk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cherk_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cherk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = cherk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zherk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zherk_$descriptor() {
        return zherk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zherk_$handle() {
        return zherk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zherk_$address() {
        return zherk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zherk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = zherk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xherk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xherk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xherk_$descriptor() {
        return xherk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xherk_$handle() {
        return xherk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xherk_$address() {
        return xherk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xherk_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xherk_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = xherk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xherk_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cher2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cher2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cher2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cher2k_$descriptor() {
        return cher2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cher2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cher2k_$handle() {
        return cher2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cher2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cher2k_$address() {
        return cher2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cher2k_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cher2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = cher2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cher2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zher2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zher2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zher2k_$descriptor() {
        return zher2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zher2k_$handle() {
        return zher2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zher2k_$address() {
        return zher2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zher2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zher2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zher2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xher2k_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xher2k_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xher2k_$descriptor() {
        return xher2k_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xher2k_$handle() {
        return xher2k_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xher2k_$address() {
        return xher2k_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xher2k_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void xher2k_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = xher2k_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xher2k_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cher2m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cher2m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cher2m_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cher2m_$descriptor() {
        return cher2m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cher2m_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cher2m_$handle() {
        return cher2m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cher2m_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cher2m_$address() {
        return cher2m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cher2m_(char *, char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static int cher2m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = cher2m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cher2m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zher2m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zher2m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zher2m_$descriptor() {
        return zher2m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zher2m_$handle() {
        return zher2m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zher2m_$address() {
        return zher2m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int zher2m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = zher2m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zher2m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xher2m_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xher2m_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xher2m_$descriptor() {
        return xher2m_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xher2m_$handle() {
        return xher2m_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xher2m_$address() {
        return xher2m_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xher2m_(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int xher2m_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = xher2m_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xher2m_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgemt_$descriptor() {
        return sgemt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sgemt_$handle() {
        return sgemt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sgemt_$address() {
        return sgemt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int sgemt_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = sgemt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemt_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgemt_$descriptor() {
        return dgemt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dgemt_$handle() {
        return dgemt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dgemt_$address() {
        return dgemt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int dgemt_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dgemt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemt_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgemt_$descriptor() {
        return cgemt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cgemt_$handle() {
        return cgemt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cgemt_$address() {
        return cgemt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgemt_(char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int cgemt_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cgemt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemt_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgemt_$descriptor() {
        return zgemt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zgemt_$handle() {
        return zgemt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zgemt_$address() {
        return zgemt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgemt_(char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int zgemt_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zgemt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemt_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgema_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgema_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgema_$descriptor() {
        return sgema_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sgema_$handle() {
        return sgema_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sgema_$address() {
        return sgema_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int sgema_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = sgema_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgema_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgema_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgema_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgema_$descriptor() {
        return dgema_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dgema_$handle() {
        return dgema_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dgema_$address() {
        return dgema_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int dgema_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = dgema_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgema_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgema_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgema_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgema_$descriptor() {
        return cgema_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cgema_$handle() {
        return cgema_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cgema_$address() {
        return cgema_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgema_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int cgema_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = cgema_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgema_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgema_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgema_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgema_$descriptor() {
        return zgema_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zgema_$handle() {
        return zgema_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zgema_$address() {
        return zgema_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgema_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int zgema_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zgema_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgema_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgems_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgems_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgems_$descriptor() {
        return sgems_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle sgems_$handle() {
        return sgems_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment sgems_$address() {
        return sgems_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int sgems_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = sgems_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgems_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgems_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgems_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgems_$descriptor() {
        return dgems_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle dgems_$handle() {
        return dgems_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment dgems_$address() {
        return dgems_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int dgems_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = dgems_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgems_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgems_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgems_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgems_$descriptor() {
        return cgems_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle cgems_$handle() {
        return cgems_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment cgems_$address() {
        return cgems_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgems_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static int cgems_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = cgems_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgems_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgems_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgems_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgems_$descriptor() {
        return zgems_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zgems_$handle() {
        return zgems_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zgems_$address() {
        return zgems_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgems_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static int zgems_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = zgems_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgems_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgemc_$descriptor() {
        return sgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sgemc_$handle() {
        return sgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sgemc_$address() {
        return sgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static int sgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = sgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgemc_$descriptor() {
        return dgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dgemc_$handle() {
        return dgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dgemc_$address() {
        return dgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int dgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = dgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor qgemc_$descriptor() {
        return qgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle qgemc_$handle() {
        return qgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment qgemc_$address() {
        return qgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int qgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = qgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgemc_$descriptor() {
        return cgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgemc_$handle() {
        return cgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgemc_$address() {
        return cgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgemc_(char *, char *, blasint *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static int cgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = cgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgemc_$descriptor() {
        return zgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgemc_$handle() {
        return zgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgemc_$address() {
        return zgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int zgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = zgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgemc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgemc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor xgemc_$descriptor() {
        return xgemc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle xgemc_$handle() {
        return xgemc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment xgemc_$address() {
        return xgemc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xgemc_(char *, char *, blasint *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static int xgemc_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14) {
        var mh$ = xgemc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgemc_", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor sgetf2_$descriptor() {
        return sgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle sgetf2_$handle() {
        return sgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment sgetf2_$address() {
        return sgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static int sgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = sgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dgetf2_$descriptor() {
        return dgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dgetf2_$handle() {
        return dgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dgetf2_$address() {
        return dgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int dgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = dgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qgetf2_$descriptor() {
        return qgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qgetf2_$handle() {
        return qgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qgetf2_$address() {
        return qgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int qgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cgetf2_$descriptor() {
        return cgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cgetf2_$handle() {
        return cgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cgetf2_$address() {
        return cgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetf2_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static int cgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = cgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zgetf2_$descriptor() {
        return zgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zgetf2_$handle() {
        return zgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zgetf2_$address() {
        return zgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int zgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xgetf2_$descriptor() {
        return xgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xgetf2_$handle() {
        return xgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xgetf2_$address() {
        return xgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xgetf2_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int xgetf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgetf2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor sgetrf_$descriptor() {
        return sgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle sgetrf_$handle() {
        return sgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment sgetrf_$address() {
        return sgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static int sgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = sgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dgetrf_$descriptor() {
        return dgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dgetrf_$handle() {
        return dgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dgetrf_$address() {
        return dgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int dgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = dgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qgetrf_$descriptor() {
        return qgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qgetrf_$handle() {
        return qgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qgetrf_$address() {
        return qgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int qgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cgetrf_$descriptor() {
        return cgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cgetrf_$handle() {
        return cgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cgetrf_$address() {
        return cgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetrf_(blasint *, blasint *, float *, blasint *, blasint *, blasint *)
     * }
     */
    public static int cgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = cgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zgetrf_$descriptor() {
        return zgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zgetrf_$handle() {
        return zgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zgetrf_$address() {
        return zgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int zgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = zgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xgetrf_$descriptor() {
        return xgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xgetrf_$handle() {
        return xgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xgetrf_$address() {
        return xgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xgetrf_(blasint *, blasint *, double *, blasint *, blasint *, blasint *)
     * }
     */
    public static int xgetrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgetrf_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor slaswp_$descriptor() {
        return slaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle slaswp_$handle() {
        return slaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment slaswp_$address() {
        return slaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int slaswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = slaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dlaswp_$descriptor() {
        return dlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dlaswp_$handle() {
        return dlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dlaswp_$address() {
        return dlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int dlaswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = dlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qlaswp_$descriptor() {
        return qlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qlaswp_$handle() {
        return qlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qlaswp_$address() {
        return qlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int qlaswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = qlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qlaswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("claswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor claswp_$descriptor() {
        return claswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle claswp_$handle() {
        return claswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment claswp_$address() {
        return claswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claswp_(blasint *, float *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int claswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = claswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zlaswp_$descriptor() {
        return zlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zlaswp_$handle() {
        return zlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zlaswp_$address() {
        return zlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int zlaswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = zlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xlaswp_$descriptor() {
        return xlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xlaswp_$handle() {
        return xlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xlaswp_$address() {
        return xlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xlaswp_(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *)
     * }
     */
    public static int xlaswp_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = xlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xlaswp_", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor sgetrs_$descriptor() {
        return sgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle sgetrs_$handle() {
        return sgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment sgetrs_$address() {
        return sgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int sgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = sgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dgetrs_$descriptor() {
        return dgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dgetrs_$handle() {
        return dgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dgetrs_$address() {
        return dgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = dgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qgetrs_$descriptor() {
        return qgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qgetrs_$handle() {
        return qgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qgetrs_$address() {
        return qgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = qgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cgetrs_$descriptor() {
        return cgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cgetrs_$handle() {
        return cgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cgetrs_$address() {
        return cgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetrs_(char *, blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = cgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zgetrs_$descriptor() {
        return zgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zgetrs_$handle() {
        return zgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zgetrs_$address() {
        return zgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xgetrs_$descriptor() {
        return xgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xgetrs_$handle() {
        return xgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xgetrs_$address() {
        return xgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xgetrs_(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xgetrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = xgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgetrs_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor sgesv_$descriptor() {
        return sgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle sgesv_$handle() {
        return sgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment sgesv_$address() {
        return sgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int sgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = sgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dgesv_$descriptor() {
        return dgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dgesv_$handle() {
        return dgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dgesv_$address() {
        return dgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qgesv_$descriptor() {
        return qgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qgesv_$handle() {
        return qgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qgesv_$address() {
        return qgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = qgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cgesv_$descriptor() {
        return cgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cgesv_$handle() {
        return cgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cgesv_$address() {
        return cgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesv_(blasint *, blasint *, float *, blasint *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zgesv_$descriptor() {
        return zgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zgesv_$handle() {
        return zgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zgesv_$address() {
        return zgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xgesv_$descriptor() {
        return xgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xgesv_$handle() {
        return xgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xgesv_$address() {
        return xgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xgesv_(blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xgesv_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xgesv_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor spotf2_$descriptor() {
        return spotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle spotf2_$handle() {
        return spotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment spotf2_$address() {
        return spotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int spotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = spotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dpotf2_$descriptor() {
        return dpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dpotf2_$handle() {
        return dpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dpotf2_$address() {
        return dpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dpotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qpotf2_$descriptor() {
        return qpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qpotf2_$handle() {
        return qpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qpotf2_$address() {
        return qpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qpotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qpotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

